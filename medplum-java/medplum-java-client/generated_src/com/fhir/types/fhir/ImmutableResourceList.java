package com.fhir.types.fhir;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.NotThreadSafe;
import org.immutables.value.Generated;

/**
 * {@code ImmutableResourceList} contains immutable implementation classes generated from
 * abstract value types defined as nested inside {@link ResourceList}.
 * @see ImmutableResourceList.InternalLinkageValue
 * @see ImmutableResourceList.InternalMedicinalProductManufacturedValue
 * @see ImmutableResourceList.InternalCoverageEligibilityRequestValue
 * @see ImmutableResourceList.InternalObservationDefinitionValue
 * @see ImmutableResourceList.InternalTaskValue
 * @see ImmutableResourceList.InternalCommunicationValue
 * @see ImmutableResourceList.InternalJsonWebKeyValue
 * @see ImmutableResourceList.InternalDetectedIssueValue
 * @see ImmutableResourceList.InternalEvidenceVariableValue
 * @see ImmutableResourceList.InternalCompositionValue
 * @see ImmutableResourceList.InternalCoverageEligibilityResponseValue
 * @see ImmutableResourceList.InternalExplanationOfBenefitValue
 * @see ImmutableResourceList.InternalDeviceRequestValue
 * @see ImmutableResourceList.InternalMessageDefinitionValue
 * @see ImmutableResourceList.InternalCommunicationRequestValue
 * @see ImmutableResourceList.InternalBundleValue
 * @see ImmutableResourceList.InternalPractitionerRoleValue
 * @see ImmutableResourceList.InternalSupplyRequestValue
 * @see ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue
 * @see ImmutableResourceList.InternalDeviceDefinitionValue
 * @see ImmutableResourceList.InternalGuidanceResponseValue
 * @see ImmutableResourceList.InternalImagingStudyValue
 * @see ImmutableResourceList.InternalDeviceMetricValue
 * @see ImmutableResourceList.InternalMolecularSequenceValue
 * @see ImmutableResourceList.InternalImmunizationRecommendationValue
 * @see ImmutableResourceList.InternalParametersValue
 * @see ImmutableResourceList.InternalChargeItemValue
 * @see ImmutableResourceList.InternalMedicinalProductAuthorizationValue
 * @see ImmutableResourceList.InternalOrganizationValue
 * @see ImmutableResourceList.InternalBodyStructureValue
 * @see ImmutableResourceList.InternalContractValue
 * @see ImmutableResourceList.InternalMedicationDispenseValue
 * @see ImmutableResourceList.InternalRiskAssessmentValue
 * @see ImmutableResourceList.InternalAppointmentValue
 * @see ImmutableResourceList.InternalListValue
 * @see ImmutableResourceList.InternalExampleScenarioValue
 * @see ImmutableResourceList.InternalSupplyDeliveryValue
 * @see ImmutableResourceList.InternalFamilyMemberHistoryValue
 * @see ImmutableResourceList.InternalProcedureValue
 * @see ImmutableResourceList.InternalDocumentManifestValue
 * @see ImmutableResourceList.InternalMedicationStatementValue
 * @see ImmutableResourceList.InternalTestReportValue
 * @see ImmutableResourceList.InternalMedicationAdministrationValue
 * @see ImmutableResourceList.InternalPaymentNoticeValue
 * @see ImmutableResourceList.InternalActivityDefinitionValue
 * @see ImmutableResourceList.InternalDiagnosticReportValue
 * @see ImmutableResourceList.InternalNutritionOrderValue
 * @see ImmutableResourceList.InternalSpecimenDefinitionValue
 * @see ImmutableResourceList.InternalMedicationRequestValue
 * @see ImmutableResourceList.InternalClaimResponseValue
 * @see ImmutableResourceList.InternalEffectEvidenceSynthesisValue
 * @see ImmutableResourceList.InternalResearchElementDefinitionValue
 * @see ImmutableResourceList.InternalAppointmentResponseValue
 * @see ImmutableResourceList.InternalGraphDefinitionValue
 * @see ImmutableResourceList.InternalClinicalImpressionValue
 * @see ImmutableResourceList.InternalScheduleValue
 * @see ImmutableResourceList.InternalCapabilityStatementValue
 * @see ImmutableResourceList.InternalMedicinalProductPackagedValue
 * @see ImmutableResourceList.InternalMedicinalProductIngredientValue
 * @see ImmutableResourceList.InternalGroupValue
 * @see ImmutableResourceList.InternalMediaValue
 * @see ImmutableResourceList.InternalPaymentReconciliationValue
 * @see ImmutableResourceList.InternalEnrollmentRequestValue
 * @see ImmutableResourceList.InternalCareTeamValue
 * @see ImmutableResourceList.InternalInvoiceValue
 * @see ImmutableResourceList.InternalTestScriptValue
 * @see ImmutableResourceList.InternalEncounterValue
 * @see ImmutableResourceList.InternalAllergyIntoleranceValue
 * @see ImmutableResourceList.InternalEnrollmentResponseValue
 * @see ImmutableResourceList.InternalHealthcareServiceValue
 * @see ImmutableResourceList.InternalSubstanceValue
 * @see ImmutableResourceList.InternalPlanDefinitionValue
 * @see ImmutableResourceList.InternalFlagValue
 * @see ImmutableResourceList.InternalUserValue
 * @see ImmutableResourceList.InternalSpecimenValue
 * @see ImmutableResourceList.InternalMedicinalProductContraindicationValue
 * @see ImmutableResourceList.InternalDeviceValue
 * @see ImmutableResourceList.InternalSubstanceSourceMaterialValue
 * @see ImmutableResourceList.InternalRequestGroupValue
 * @see ImmutableResourceList.InternalStructureDefinitionValue
 * @see ImmutableResourceList.InternalAccessPolicyValue
 * @see ImmutableResourceList.InternalMeasureValue
 * @see ImmutableResourceList.InternalMedicinalProductValue
 * @see ImmutableResourceList.InternalLoginValue
 * @see ImmutableResourceList.InternalAuditEventValue
 * @see ImmutableResourceList.InternalMeasureReportValue
 * @see ImmutableResourceList.InternalMedicinalProductIndicationValue
 * @see ImmutableResourceList.InternalPractitionerValue
 * @see ImmutableResourceList.InternalCoverageValue
 * @see ImmutableResourceList.InternalResearchDefinitionValue
 * @see ImmutableResourceList.InternalResearchStudyValue
 * @see ImmutableResourceList.InternalEvidenceValue
 * @see ImmutableResourceList.InternalResearchSubjectValue
 * @see ImmutableResourceList.InternalVisionPrescriptionValue
 * @see ImmutableResourceList.InternalChargeItemDefinitionValue
 * @see ImmutableResourceList.InternalConditionValue
 * @see ImmutableResourceList.InternalPersonValue
 * @see ImmutableResourceList.InternalRiskEvidenceSynthesisValue
 * @see ImmutableResourceList.InternalSearchParameterValue
 * @see ImmutableResourceList.InternalInsurancePlanValue
 * @see ImmutableResourceList.InternalPasswordChangeRequestValue
 * @see ImmutableResourceList.InternalStructureMapValue
 * @see ImmutableResourceList.InternalSubscriptionValue
 * @see ImmutableResourceList.InternalOperationDefinitionValue
 * @see ImmutableResourceList.InternalBotValue
 * @see ImmutableResourceList.InternalOrganizationAffiliationValue
 * @see ImmutableResourceList.InternalNamingSystemValue
 * @see ImmutableResourceList.InternalOperationOutcomeValue
 * @see ImmutableResourceList.InternalPatientValue
 * @see ImmutableResourceList.InternalConsentValue
 * @see ImmutableResourceList.InternalCompartmentDefinitionValue
 * @see ImmutableResourceList.InternalSubstanceNucleicAcidValue
 * @see ImmutableResourceList.InternalCatalogEntryValue
 * @see ImmutableResourceList.InternalSubstanceProteinValue
 * @see ImmutableResourceList.InternalImmunizationValue
 * @see ImmutableResourceList.InternalRefreshTokenValue
 * @see ImmutableResourceList.InternalBiologicallyDerivedProductValue
 * @see ImmutableResourceList.InternalDeviceUseStatementValue
 * @see ImmutableResourceList.InternalProvenanceValue
 * @see ImmutableResourceList.InternalClaimValue
 * @see ImmutableResourceList.InternalServiceRequestValue
 * @see ImmutableResourceList.InternalSubstanceReferenceInformationValue
 * @see ImmutableResourceList.InternalMedicationValue
 * @see ImmutableResourceList.InternalDocumentReferenceValue
 * @see ImmutableResourceList.InternalImmunizationEvaluationValue
 * @see ImmutableResourceList.InternalMedicinalProductInteractionValue
 * @see ImmutableResourceList.InternalBasicValue
 * @see ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue
 * @see ImmutableResourceList.InternalImplementationGuideValue
 * @see ImmutableResourceList.InternalCarePlanValue
 * @see ImmutableResourceList.InternalObservationValue
 * @see ImmutableResourceList.InternalAccountValue
 * @see ImmutableResourceList.InternalQuestionnaireResponseValue
 * @see ImmutableResourceList.InternalTerminologyCapabilitiesValue
 * @see ImmutableResourceList.InternalUserConfigurationValue
 * @see ImmutableResourceList.InternalProjectValue
 * @see ImmutableResourceList.InternalConceptMapValue
 * @see ImmutableResourceList.InternalLocationValue
 * @see ImmutableResourceList.InternalEpisodeOfCareValue
 * @see ImmutableResourceList.InternalGoalValue
 * @see ImmutableResourceList.InternalEventDefinitionValue
 * @see ImmutableResourceList.InternalVerificationResultValue
 * @see ImmutableResourceList.InternalValueSetValue
 * @see ImmutableResourceList.InternalSubstanceSpecificationValue
 * @see ImmutableResourceList.InternalSubstancePolymerValue
 * @see ImmutableResourceList.InternalBinaryValue
 * @see ImmutableResourceList.InternalLibraryValue
 * @see ImmutableResourceList.InternalClientApplicationValue
 * @see ImmutableResourceList.InternalMessageHeaderValue
 * @see ImmutableResourceList.InternalCodeSystemValue
 * @see ImmutableResourceList.InternalMedicationKnowledgeValue
 * @see ImmutableResourceList.InternalEndpointValue
 * @see ImmutableResourceList.InternalRelatedPersonValue
 * @see ImmutableResourceList.InternalSlotValue
 * @see ImmutableResourceList.InternalAdverseEventValue
 * @see ImmutableResourceList.InternalQuestionnaireValue
 * @see ImmutableResourceList.Unknown
 */
@Generated(from = "ResourceList", generator = "Immutables")
@SuppressWarnings({"all"})
@SuppressFBWarnings
@ParametersAreNonnullByDefault
@javax.annotation.processing.Generated("org.immutables.processor.ProxyProcessor")
public final class ImmutableResourceList {
  private ImmutableResourceList() {}

  /**
   * Immutable implementation of {@link ResourceList.InternalLinkageValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalLinkageValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalLinkageValue", generator = "Immutables")
  @Immutable
  static final class InternalLinkageValue implements ResourceList.InternalLinkageValue {
    private final Linkage linkage;

    private InternalLinkageValue(Linkage linkage) {
      this.linkage = linkage;
    }

    /**
     * @return The value of the {@code linkage} attribute
     */
    @JsonProperty("linkage")
    @JsonValue
    @Override
    public Linkage linkage() {
      return linkage;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalLinkageValue#linkage() linkage} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for linkage
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalLinkageValue withLinkage(Linkage value) {
      if (this.linkage == value) return this;
      Linkage newValue = Objects.requireNonNull(value, "linkage");
      return new ImmutableResourceList.InternalLinkageValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalLinkageValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalLinkageValue
          && equalTo((ImmutableResourceList.InternalLinkageValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalLinkageValue another) {
      return linkage.equals(another.linkage);
    }

    /**
     * Computes a hash code from attributes: {@code linkage}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + linkage.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalLinkageValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalLinkageValue{"
          + "linkage=" + linkage
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalLinkageValue fromJson(Linkage jsonValue) {
      ImmutableResourceList.InternalLinkageValue.Builder builder = ImmutableResourceList.InternalLinkageValue.builder();
      builder.linkage(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalLinkageValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalLinkageValue instance
     */
    public static ImmutableResourceList.InternalLinkageValue copyOf(ResourceList.InternalLinkageValue instance) {
      if (instance instanceof ImmutableResourceList.InternalLinkageValue) {
        return (ImmutableResourceList.InternalLinkageValue) instance;
      }
      return ImmutableResourceList.InternalLinkageValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalLinkageValue InternalLinkageValue}.
     * <pre>
     * ImmutableResourceList.InternalLinkageValue.builder()
     *    .linkage(com.fhir.types.fhir.Linkage) // required {@link ResourceList.InternalLinkageValue#linkage() linkage}
     *    .build();
     * </pre>
     * @return A new InternalLinkageValue builder
     */
    public static ImmutableResourceList.InternalLinkageValue.Builder builder() {
      return new ImmutableResourceList.InternalLinkageValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalLinkageValue InternalLinkageValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalLinkageValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_LINKAGE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Linkage linkage;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalLinkageValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalLinkageValue instance) {
        Objects.requireNonNull(instance, "instance");
        linkage(instance.linkage());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalLinkageValue#linkage() linkage} attribute.
       * @param linkage The value for linkage 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("linkage")
      public final Builder linkage(Linkage linkage) {
        this.linkage = Objects.requireNonNull(linkage, "linkage");
        initBits &= ~INIT_BIT_LINKAGE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalLinkageValue InternalLinkageValue}.
       * @return An immutable instance of InternalLinkageValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalLinkageValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalLinkageValue(linkage);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_LINKAGE) != 0) attributes.add("linkage");
        return "Cannot build InternalLinkageValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductManufacturedValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductManufacturedValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductManufacturedValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductManufacturedValue
      implements ResourceList.InternalMedicinalProductManufacturedValue {
    private final MedicinalProductManufactured medicinalProductManufactured;

    private InternalMedicinalProductManufacturedValue(MedicinalProductManufactured medicinalProductManufactured) {
      this.medicinalProductManufactured = medicinalProductManufactured;
    }

    /**
     * @return The value of the {@code medicinalProductManufactured} attribute
     */
    @JsonProperty("medicinalProductManufactured")
    @JsonValue
    @Override
    public MedicinalProductManufactured medicinalProductManufactured() {
      return medicinalProductManufactured;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductManufacturedValue#medicinalProductManufactured() medicinalProductManufactured} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProductManufactured
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductManufacturedValue withMedicinalProductManufactured(MedicinalProductManufactured value) {
      if (this.medicinalProductManufactured == value) return this;
      MedicinalProductManufactured newValue = Objects.requireNonNull(value, "medicinalProductManufactured");
      return new ImmutableResourceList.InternalMedicinalProductManufacturedValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductManufacturedValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductManufacturedValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductManufacturedValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductManufacturedValue another) {
      return medicinalProductManufactured.equals(another.medicinalProductManufactured);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProductManufactured}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProductManufactured.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductManufacturedValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductManufacturedValue{"
          + "medicinalProductManufactured=" + medicinalProductManufactured
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductManufacturedValue fromJson(MedicinalProductManufactured jsonValue) {
      ImmutableResourceList.InternalMedicinalProductManufacturedValue.Builder builder = ImmutableResourceList.InternalMedicinalProductManufacturedValue.builder();
      builder.medicinalProductManufactured(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductManufacturedValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductManufacturedValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductManufacturedValue copyOf(ResourceList.InternalMedicinalProductManufacturedValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductManufacturedValue) {
        return (ImmutableResourceList.InternalMedicinalProductManufacturedValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductManufacturedValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductManufacturedValue InternalMedicinalProductManufacturedValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductManufacturedValue.builder()
     *    .medicinalProductManufactured(com.fhir.types.fhir.MedicinalProductManufactured) // required {@link ResourceList.InternalMedicinalProductManufacturedValue#medicinalProductManufactured() medicinalProductManufactured}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductManufacturedValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductManufacturedValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductManufacturedValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductManufacturedValue InternalMedicinalProductManufacturedValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductManufacturedValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT_MANUFACTURED = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProductManufactured medicinalProductManufactured;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductManufacturedValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductManufacturedValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProductManufactured(instance.medicinalProductManufactured());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductManufacturedValue#medicinalProductManufactured() medicinalProductManufactured} attribute.
       * @param medicinalProductManufactured The value for medicinalProductManufactured 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProductManufactured")
      public final Builder medicinalProductManufactured(MedicinalProductManufactured medicinalProductManufactured) {
        this.medicinalProductManufactured = Objects.requireNonNull(medicinalProductManufactured, "medicinalProductManufactured");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT_MANUFACTURED;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductManufacturedValue InternalMedicinalProductManufacturedValue}.
       * @return An immutable instance of InternalMedicinalProductManufacturedValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductManufacturedValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductManufacturedValue(medicinalProductManufactured);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT_MANUFACTURED) != 0) attributes.add("medicinalProductManufactured");
        return "Cannot build InternalMedicinalProductManufacturedValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCoverageEligibilityRequestValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCoverageEligibilityRequestValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCoverageEligibilityRequestValue", generator = "Immutables")
  @Immutable
  static final class InternalCoverageEligibilityRequestValue
      implements ResourceList.InternalCoverageEligibilityRequestValue {
    private final CoverageEligibilityRequest coverageEligibilityRequest;

    private InternalCoverageEligibilityRequestValue(CoverageEligibilityRequest coverageEligibilityRequest) {
      this.coverageEligibilityRequest = coverageEligibilityRequest;
    }

    /**
     * @return The value of the {@code coverageEligibilityRequest} attribute
     */
    @JsonProperty("coverageEligibilityRequest")
    @JsonValue
    @Override
    public CoverageEligibilityRequest coverageEligibilityRequest() {
      return coverageEligibilityRequest;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCoverageEligibilityRequestValue#coverageEligibilityRequest() coverageEligibilityRequest} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for coverageEligibilityRequest
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCoverageEligibilityRequestValue withCoverageEligibilityRequest(CoverageEligibilityRequest value) {
      if (this.coverageEligibilityRequest == value) return this;
      CoverageEligibilityRequest newValue = Objects.requireNonNull(value, "coverageEligibilityRequest");
      return new ImmutableResourceList.InternalCoverageEligibilityRequestValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCoverageEligibilityRequestValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCoverageEligibilityRequestValue
          && equalTo((ImmutableResourceList.InternalCoverageEligibilityRequestValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCoverageEligibilityRequestValue another) {
      return coverageEligibilityRequest.equals(another.coverageEligibilityRequest);
    }

    /**
     * Computes a hash code from attributes: {@code coverageEligibilityRequest}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + coverageEligibilityRequest.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCoverageEligibilityRequestValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCoverageEligibilityRequestValue{"
          + "coverageEligibilityRequest=" + coverageEligibilityRequest
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCoverageEligibilityRequestValue fromJson(CoverageEligibilityRequest jsonValue) {
      ImmutableResourceList.InternalCoverageEligibilityRequestValue.Builder builder = ImmutableResourceList.InternalCoverageEligibilityRequestValue.builder();
      builder.coverageEligibilityRequest(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCoverageEligibilityRequestValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCoverageEligibilityRequestValue instance
     */
    public static ImmutableResourceList.InternalCoverageEligibilityRequestValue copyOf(ResourceList.InternalCoverageEligibilityRequestValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCoverageEligibilityRequestValue) {
        return (ImmutableResourceList.InternalCoverageEligibilityRequestValue) instance;
      }
      return ImmutableResourceList.InternalCoverageEligibilityRequestValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCoverageEligibilityRequestValue InternalCoverageEligibilityRequestValue}.
     * <pre>
     * ImmutableResourceList.InternalCoverageEligibilityRequestValue.builder()
     *    .coverageEligibilityRequest(com.fhir.types.fhir.CoverageEligibilityRequest) // required {@link ResourceList.InternalCoverageEligibilityRequestValue#coverageEligibilityRequest() coverageEligibilityRequest}
     *    .build();
     * </pre>
     * @return A new InternalCoverageEligibilityRequestValue builder
     */
    public static ImmutableResourceList.InternalCoverageEligibilityRequestValue.Builder builder() {
      return new ImmutableResourceList.InternalCoverageEligibilityRequestValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCoverageEligibilityRequestValue InternalCoverageEligibilityRequestValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCoverageEligibilityRequestValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_COVERAGE_ELIGIBILITY_REQUEST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable CoverageEligibilityRequest coverageEligibilityRequest;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCoverageEligibilityRequestValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCoverageEligibilityRequestValue instance) {
        Objects.requireNonNull(instance, "instance");
        coverageEligibilityRequest(instance.coverageEligibilityRequest());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCoverageEligibilityRequestValue#coverageEligibilityRequest() coverageEligibilityRequest} attribute.
       * @param coverageEligibilityRequest The value for coverageEligibilityRequest 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("coverageEligibilityRequest")
      public final Builder coverageEligibilityRequest(CoverageEligibilityRequest coverageEligibilityRequest) {
        this.coverageEligibilityRequest = Objects.requireNonNull(coverageEligibilityRequest, "coverageEligibilityRequest");
        initBits &= ~INIT_BIT_COVERAGE_ELIGIBILITY_REQUEST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCoverageEligibilityRequestValue InternalCoverageEligibilityRequestValue}.
       * @return An immutable instance of InternalCoverageEligibilityRequestValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCoverageEligibilityRequestValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCoverageEligibilityRequestValue(coverageEligibilityRequest);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_COVERAGE_ELIGIBILITY_REQUEST) != 0) attributes.add("coverageEligibilityRequest");
        return "Cannot build InternalCoverageEligibilityRequestValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalObservationDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalObservationDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalObservationDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalObservationDefinitionValue
      implements ResourceList.InternalObservationDefinitionValue {
    private final ObservationDefinition observationDefinition;

    private InternalObservationDefinitionValue(ObservationDefinition observationDefinition) {
      this.observationDefinition = observationDefinition;
    }

    /**
     * @return The value of the {@code observationDefinition} attribute
     */
    @JsonProperty("observationDefinition")
    @JsonValue
    @Override
    public ObservationDefinition observationDefinition() {
      return observationDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalObservationDefinitionValue#observationDefinition() observationDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for observationDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalObservationDefinitionValue withObservationDefinition(ObservationDefinition value) {
      if (this.observationDefinition == value) return this;
      ObservationDefinition newValue = Objects.requireNonNull(value, "observationDefinition");
      return new ImmutableResourceList.InternalObservationDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalObservationDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalObservationDefinitionValue
          && equalTo((ImmutableResourceList.InternalObservationDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalObservationDefinitionValue another) {
      return observationDefinition.equals(another.observationDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code observationDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + observationDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalObservationDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalObservationDefinitionValue{"
          + "observationDefinition=" + observationDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalObservationDefinitionValue fromJson(ObservationDefinition jsonValue) {
      ImmutableResourceList.InternalObservationDefinitionValue.Builder builder = ImmutableResourceList.InternalObservationDefinitionValue.builder();
      builder.observationDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalObservationDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalObservationDefinitionValue instance
     */
    public static ImmutableResourceList.InternalObservationDefinitionValue copyOf(ResourceList.InternalObservationDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalObservationDefinitionValue) {
        return (ImmutableResourceList.InternalObservationDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalObservationDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalObservationDefinitionValue InternalObservationDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalObservationDefinitionValue.builder()
     *    .observationDefinition(com.fhir.types.fhir.ObservationDefinition) // required {@link ResourceList.InternalObservationDefinitionValue#observationDefinition() observationDefinition}
     *    .build();
     * </pre>
     * @return A new InternalObservationDefinitionValue builder
     */
    public static ImmutableResourceList.InternalObservationDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalObservationDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalObservationDefinitionValue InternalObservationDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalObservationDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_OBSERVATION_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ObservationDefinition observationDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalObservationDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalObservationDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        observationDefinition(instance.observationDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalObservationDefinitionValue#observationDefinition() observationDefinition} attribute.
       * @param observationDefinition The value for observationDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("observationDefinition")
      public final Builder observationDefinition(ObservationDefinition observationDefinition) {
        this.observationDefinition = Objects.requireNonNull(observationDefinition, "observationDefinition");
        initBits &= ~INIT_BIT_OBSERVATION_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalObservationDefinitionValue InternalObservationDefinitionValue}.
       * @return An immutable instance of InternalObservationDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalObservationDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalObservationDefinitionValue(observationDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_OBSERVATION_DEFINITION) != 0) attributes.add("observationDefinition");
        return "Cannot build InternalObservationDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalTaskValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalTaskValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalTaskValue", generator = "Immutables")
  @Immutable
  static final class InternalTaskValue implements ResourceList.InternalTaskValue {
    private final Task task;

    private InternalTaskValue(Task task) {
      this.task = task;
    }

    /**
     * @return The value of the {@code task} attribute
     */
    @JsonProperty("task")
    @JsonValue
    @Override
    public Task task() {
      return task;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalTaskValue#task() task} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for task
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalTaskValue withTask(Task value) {
      if (this.task == value) return this;
      Task newValue = Objects.requireNonNull(value, "task");
      return new ImmutableResourceList.InternalTaskValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalTaskValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalTaskValue
          && equalTo((ImmutableResourceList.InternalTaskValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalTaskValue another) {
      return task.equals(another.task);
    }

    /**
     * Computes a hash code from attributes: {@code task}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + task.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalTaskValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalTaskValue{"
          + "task=" + task
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalTaskValue fromJson(Task jsonValue) {
      ImmutableResourceList.InternalTaskValue.Builder builder = ImmutableResourceList.InternalTaskValue.builder();
      builder.task(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalTaskValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalTaskValue instance
     */
    public static ImmutableResourceList.InternalTaskValue copyOf(ResourceList.InternalTaskValue instance) {
      if (instance instanceof ImmutableResourceList.InternalTaskValue) {
        return (ImmutableResourceList.InternalTaskValue) instance;
      }
      return ImmutableResourceList.InternalTaskValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalTaskValue InternalTaskValue}.
     * <pre>
     * ImmutableResourceList.InternalTaskValue.builder()
     *    .task(com.fhir.types.fhir.Task) // required {@link ResourceList.InternalTaskValue#task() task}
     *    .build();
     * </pre>
     * @return A new InternalTaskValue builder
     */
    public static ImmutableResourceList.InternalTaskValue.Builder builder() {
      return new ImmutableResourceList.InternalTaskValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalTaskValue InternalTaskValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalTaskValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_TASK = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Task task;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalTaskValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalTaskValue instance) {
        Objects.requireNonNull(instance, "instance");
        task(instance.task());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalTaskValue#task() task} attribute.
       * @param task The value for task 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("task")
      public final Builder task(Task task) {
        this.task = Objects.requireNonNull(task, "task");
        initBits &= ~INIT_BIT_TASK;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalTaskValue InternalTaskValue}.
       * @return An immutable instance of InternalTaskValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalTaskValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalTaskValue(task);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_TASK) != 0) attributes.add("task");
        return "Cannot build InternalTaskValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCommunicationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCommunicationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCommunicationValue", generator = "Immutables")
  @Immutable
  static final class InternalCommunicationValue
      implements ResourceList.InternalCommunicationValue {
    private final Communication communication;

    private InternalCommunicationValue(Communication communication) {
      this.communication = communication;
    }

    /**
     * @return The value of the {@code communication} attribute
     */
    @JsonProperty("communication")
    @JsonValue
    @Override
    public Communication communication() {
      return communication;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCommunicationValue#communication() communication} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for communication
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCommunicationValue withCommunication(Communication value) {
      if (this.communication == value) return this;
      Communication newValue = Objects.requireNonNull(value, "communication");
      return new ImmutableResourceList.InternalCommunicationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCommunicationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCommunicationValue
          && equalTo((ImmutableResourceList.InternalCommunicationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCommunicationValue another) {
      return communication.equals(another.communication);
    }

    /**
     * Computes a hash code from attributes: {@code communication}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + communication.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCommunicationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCommunicationValue{"
          + "communication=" + communication
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCommunicationValue fromJson(Communication jsonValue) {
      ImmutableResourceList.InternalCommunicationValue.Builder builder = ImmutableResourceList.InternalCommunicationValue.builder();
      builder.communication(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCommunicationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCommunicationValue instance
     */
    public static ImmutableResourceList.InternalCommunicationValue copyOf(ResourceList.InternalCommunicationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCommunicationValue) {
        return (ImmutableResourceList.InternalCommunicationValue) instance;
      }
      return ImmutableResourceList.InternalCommunicationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCommunicationValue InternalCommunicationValue}.
     * <pre>
     * ImmutableResourceList.InternalCommunicationValue.builder()
     *    .communication(com.fhir.types.fhir.Communication) // required {@link ResourceList.InternalCommunicationValue#communication() communication}
     *    .build();
     * </pre>
     * @return A new InternalCommunicationValue builder
     */
    public static ImmutableResourceList.InternalCommunicationValue.Builder builder() {
      return new ImmutableResourceList.InternalCommunicationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCommunicationValue InternalCommunicationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCommunicationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_COMMUNICATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Communication communication;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCommunicationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCommunicationValue instance) {
        Objects.requireNonNull(instance, "instance");
        communication(instance.communication());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCommunicationValue#communication() communication} attribute.
       * @param communication The value for communication 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("communication")
      public final Builder communication(Communication communication) {
        this.communication = Objects.requireNonNull(communication, "communication");
        initBits &= ~INIT_BIT_COMMUNICATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCommunicationValue InternalCommunicationValue}.
       * @return An immutable instance of InternalCommunicationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCommunicationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCommunicationValue(communication);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_COMMUNICATION) != 0) attributes.add("communication");
        return "Cannot build InternalCommunicationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalJsonWebKeyValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalJsonWebKeyValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalJsonWebKeyValue", generator = "Immutables")
  @Immutable
  static final class InternalJsonWebKeyValue
      implements ResourceList.InternalJsonWebKeyValue {
    private final JsonWebKey jsonWebKey;

    private InternalJsonWebKeyValue(JsonWebKey jsonWebKey) {
      this.jsonWebKey = jsonWebKey;
    }

    /**
     * @return The value of the {@code jsonWebKey} attribute
     */
    @JsonProperty("jsonWebKey")
    @JsonValue
    @Override
    public JsonWebKey jsonWebKey() {
      return jsonWebKey;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalJsonWebKeyValue#jsonWebKey() jsonWebKey} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for jsonWebKey
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalJsonWebKeyValue withJsonWebKey(JsonWebKey value) {
      if (this.jsonWebKey == value) return this;
      JsonWebKey newValue = Objects.requireNonNull(value, "jsonWebKey");
      return new ImmutableResourceList.InternalJsonWebKeyValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalJsonWebKeyValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalJsonWebKeyValue
          && equalTo((ImmutableResourceList.InternalJsonWebKeyValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalJsonWebKeyValue another) {
      return jsonWebKey.equals(another.jsonWebKey);
    }

    /**
     * Computes a hash code from attributes: {@code jsonWebKey}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + jsonWebKey.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalJsonWebKeyValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalJsonWebKeyValue{"
          + "jsonWebKey=" + jsonWebKey
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalJsonWebKeyValue fromJson(JsonWebKey jsonValue) {
      ImmutableResourceList.InternalJsonWebKeyValue.Builder builder = ImmutableResourceList.InternalJsonWebKeyValue.builder();
      builder.jsonWebKey(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalJsonWebKeyValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalJsonWebKeyValue instance
     */
    public static ImmutableResourceList.InternalJsonWebKeyValue copyOf(ResourceList.InternalJsonWebKeyValue instance) {
      if (instance instanceof ImmutableResourceList.InternalJsonWebKeyValue) {
        return (ImmutableResourceList.InternalJsonWebKeyValue) instance;
      }
      return ImmutableResourceList.InternalJsonWebKeyValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalJsonWebKeyValue InternalJsonWebKeyValue}.
     * <pre>
     * ImmutableResourceList.InternalJsonWebKeyValue.builder()
     *    .jsonWebKey(com.fhir.types.fhir.JsonWebKey) // required {@link ResourceList.InternalJsonWebKeyValue#jsonWebKey() jsonWebKey}
     *    .build();
     * </pre>
     * @return A new InternalJsonWebKeyValue builder
     */
    public static ImmutableResourceList.InternalJsonWebKeyValue.Builder builder() {
      return new ImmutableResourceList.InternalJsonWebKeyValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalJsonWebKeyValue InternalJsonWebKeyValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalJsonWebKeyValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_JSON_WEB_KEY = 0x1L;
      private long initBits = 0x1L;

      private @Nullable JsonWebKey jsonWebKey;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalJsonWebKeyValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalJsonWebKeyValue instance) {
        Objects.requireNonNull(instance, "instance");
        jsonWebKey(instance.jsonWebKey());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalJsonWebKeyValue#jsonWebKey() jsonWebKey} attribute.
       * @param jsonWebKey The value for jsonWebKey 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("jsonWebKey")
      public final Builder jsonWebKey(JsonWebKey jsonWebKey) {
        this.jsonWebKey = Objects.requireNonNull(jsonWebKey, "jsonWebKey");
        initBits &= ~INIT_BIT_JSON_WEB_KEY;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalJsonWebKeyValue InternalJsonWebKeyValue}.
       * @return An immutable instance of InternalJsonWebKeyValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalJsonWebKeyValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalJsonWebKeyValue(jsonWebKey);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_JSON_WEB_KEY) != 0) attributes.add("jsonWebKey");
        return "Cannot build InternalJsonWebKeyValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalDetectedIssueValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalDetectedIssueValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalDetectedIssueValue", generator = "Immutables")
  @Immutable
  static final class InternalDetectedIssueValue
      implements ResourceList.InternalDetectedIssueValue {
    private final DetectedIssue detectedIssue;

    private InternalDetectedIssueValue(DetectedIssue detectedIssue) {
      this.detectedIssue = detectedIssue;
    }

    /**
     * @return The value of the {@code detectedIssue} attribute
     */
    @JsonProperty("detectedIssue")
    @JsonValue
    @Override
    public DetectedIssue detectedIssue() {
      return detectedIssue;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalDetectedIssueValue#detectedIssue() detectedIssue} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for detectedIssue
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalDetectedIssueValue withDetectedIssue(DetectedIssue value) {
      if (this.detectedIssue == value) return this;
      DetectedIssue newValue = Objects.requireNonNull(value, "detectedIssue");
      return new ImmutableResourceList.InternalDetectedIssueValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalDetectedIssueValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalDetectedIssueValue
          && equalTo((ImmutableResourceList.InternalDetectedIssueValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalDetectedIssueValue another) {
      return detectedIssue.equals(another.detectedIssue);
    }

    /**
     * Computes a hash code from attributes: {@code detectedIssue}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + detectedIssue.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalDetectedIssueValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalDetectedIssueValue{"
          + "detectedIssue=" + detectedIssue
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalDetectedIssueValue fromJson(DetectedIssue jsonValue) {
      ImmutableResourceList.InternalDetectedIssueValue.Builder builder = ImmutableResourceList.InternalDetectedIssueValue.builder();
      builder.detectedIssue(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalDetectedIssueValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalDetectedIssueValue instance
     */
    public static ImmutableResourceList.InternalDetectedIssueValue copyOf(ResourceList.InternalDetectedIssueValue instance) {
      if (instance instanceof ImmutableResourceList.InternalDetectedIssueValue) {
        return (ImmutableResourceList.InternalDetectedIssueValue) instance;
      }
      return ImmutableResourceList.InternalDetectedIssueValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalDetectedIssueValue InternalDetectedIssueValue}.
     * <pre>
     * ImmutableResourceList.InternalDetectedIssueValue.builder()
     *    .detectedIssue(com.fhir.types.fhir.DetectedIssue) // required {@link ResourceList.InternalDetectedIssueValue#detectedIssue() detectedIssue}
     *    .build();
     * </pre>
     * @return A new InternalDetectedIssueValue builder
     */
    public static ImmutableResourceList.InternalDetectedIssueValue.Builder builder() {
      return new ImmutableResourceList.InternalDetectedIssueValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalDetectedIssueValue InternalDetectedIssueValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalDetectedIssueValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_DETECTED_ISSUE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable DetectedIssue detectedIssue;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalDetectedIssueValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalDetectedIssueValue instance) {
        Objects.requireNonNull(instance, "instance");
        detectedIssue(instance.detectedIssue());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalDetectedIssueValue#detectedIssue() detectedIssue} attribute.
       * @param detectedIssue The value for detectedIssue 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("detectedIssue")
      public final Builder detectedIssue(DetectedIssue detectedIssue) {
        this.detectedIssue = Objects.requireNonNull(detectedIssue, "detectedIssue");
        initBits &= ~INIT_BIT_DETECTED_ISSUE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalDetectedIssueValue InternalDetectedIssueValue}.
       * @return An immutable instance of InternalDetectedIssueValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalDetectedIssueValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalDetectedIssueValue(detectedIssue);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_DETECTED_ISSUE) != 0) attributes.add("detectedIssue");
        return "Cannot build InternalDetectedIssueValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalEvidenceVariableValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalEvidenceVariableValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalEvidenceVariableValue", generator = "Immutables")
  @Immutable
  static final class InternalEvidenceVariableValue
      implements ResourceList.InternalEvidenceVariableValue {
    private final EvidenceVariable evidenceVariable;

    private InternalEvidenceVariableValue(EvidenceVariable evidenceVariable) {
      this.evidenceVariable = evidenceVariable;
    }

    /**
     * @return The value of the {@code evidenceVariable} attribute
     */
    @JsonProperty("evidenceVariable")
    @JsonValue
    @Override
    public EvidenceVariable evidenceVariable() {
      return evidenceVariable;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalEvidenceVariableValue#evidenceVariable() evidenceVariable} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for evidenceVariable
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalEvidenceVariableValue withEvidenceVariable(EvidenceVariable value) {
      if (this.evidenceVariable == value) return this;
      EvidenceVariable newValue = Objects.requireNonNull(value, "evidenceVariable");
      return new ImmutableResourceList.InternalEvidenceVariableValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalEvidenceVariableValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalEvidenceVariableValue
          && equalTo((ImmutableResourceList.InternalEvidenceVariableValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalEvidenceVariableValue another) {
      return evidenceVariable.equals(another.evidenceVariable);
    }

    /**
     * Computes a hash code from attributes: {@code evidenceVariable}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + evidenceVariable.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalEvidenceVariableValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalEvidenceVariableValue{"
          + "evidenceVariable=" + evidenceVariable
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalEvidenceVariableValue fromJson(EvidenceVariable jsonValue) {
      ImmutableResourceList.InternalEvidenceVariableValue.Builder builder = ImmutableResourceList.InternalEvidenceVariableValue.builder();
      builder.evidenceVariable(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalEvidenceVariableValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalEvidenceVariableValue instance
     */
    public static ImmutableResourceList.InternalEvidenceVariableValue copyOf(ResourceList.InternalEvidenceVariableValue instance) {
      if (instance instanceof ImmutableResourceList.InternalEvidenceVariableValue) {
        return (ImmutableResourceList.InternalEvidenceVariableValue) instance;
      }
      return ImmutableResourceList.InternalEvidenceVariableValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalEvidenceVariableValue InternalEvidenceVariableValue}.
     * <pre>
     * ImmutableResourceList.InternalEvidenceVariableValue.builder()
     *    .evidenceVariable(com.fhir.types.fhir.EvidenceVariable) // required {@link ResourceList.InternalEvidenceVariableValue#evidenceVariable() evidenceVariable}
     *    .build();
     * </pre>
     * @return A new InternalEvidenceVariableValue builder
     */
    public static ImmutableResourceList.InternalEvidenceVariableValue.Builder builder() {
      return new ImmutableResourceList.InternalEvidenceVariableValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalEvidenceVariableValue InternalEvidenceVariableValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalEvidenceVariableValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_EVIDENCE_VARIABLE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable EvidenceVariable evidenceVariable;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalEvidenceVariableValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalEvidenceVariableValue instance) {
        Objects.requireNonNull(instance, "instance");
        evidenceVariable(instance.evidenceVariable());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalEvidenceVariableValue#evidenceVariable() evidenceVariable} attribute.
       * @param evidenceVariable The value for evidenceVariable 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("evidenceVariable")
      public final Builder evidenceVariable(EvidenceVariable evidenceVariable) {
        this.evidenceVariable = Objects.requireNonNull(evidenceVariable, "evidenceVariable");
        initBits &= ~INIT_BIT_EVIDENCE_VARIABLE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalEvidenceVariableValue InternalEvidenceVariableValue}.
       * @return An immutable instance of InternalEvidenceVariableValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalEvidenceVariableValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalEvidenceVariableValue(evidenceVariable);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_EVIDENCE_VARIABLE) != 0) attributes.add("evidenceVariable");
        return "Cannot build InternalEvidenceVariableValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCompositionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCompositionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCompositionValue", generator = "Immutables")
  @Immutable
  static final class InternalCompositionValue
      implements ResourceList.InternalCompositionValue {
    private final Composition composition;

    private InternalCompositionValue(Composition composition) {
      this.composition = composition;
    }

    /**
     * @return The value of the {@code composition} attribute
     */
    @JsonProperty("composition")
    @JsonValue
    @Override
    public Composition composition() {
      return composition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCompositionValue#composition() composition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for composition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCompositionValue withComposition(Composition value) {
      if (this.composition == value) return this;
      Composition newValue = Objects.requireNonNull(value, "composition");
      return new ImmutableResourceList.InternalCompositionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCompositionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCompositionValue
          && equalTo((ImmutableResourceList.InternalCompositionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCompositionValue another) {
      return composition.equals(another.composition);
    }

    /**
     * Computes a hash code from attributes: {@code composition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + composition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCompositionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCompositionValue{"
          + "composition=" + composition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCompositionValue fromJson(Composition jsonValue) {
      ImmutableResourceList.InternalCompositionValue.Builder builder = ImmutableResourceList.InternalCompositionValue.builder();
      builder.composition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCompositionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCompositionValue instance
     */
    public static ImmutableResourceList.InternalCompositionValue copyOf(ResourceList.InternalCompositionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCompositionValue) {
        return (ImmutableResourceList.InternalCompositionValue) instance;
      }
      return ImmutableResourceList.InternalCompositionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCompositionValue InternalCompositionValue}.
     * <pre>
     * ImmutableResourceList.InternalCompositionValue.builder()
     *    .composition(com.fhir.types.fhir.Composition) // required {@link ResourceList.InternalCompositionValue#composition() composition}
     *    .build();
     * </pre>
     * @return A new InternalCompositionValue builder
     */
    public static ImmutableResourceList.InternalCompositionValue.Builder builder() {
      return new ImmutableResourceList.InternalCompositionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCompositionValue InternalCompositionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCompositionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_COMPOSITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Composition composition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCompositionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCompositionValue instance) {
        Objects.requireNonNull(instance, "instance");
        composition(instance.composition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCompositionValue#composition() composition} attribute.
       * @param composition The value for composition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("composition")
      public final Builder composition(Composition composition) {
        this.composition = Objects.requireNonNull(composition, "composition");
        initBits &= ~INIT_BIT_COMPOSITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCompositionValue InternalCompositionValue}.
       * @return An immutable instance of InternalCompositionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCompositionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCompositionValue(composition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_COMPOSITION) != 0) attributes.add("composition");
        return "Cannot build InternalCompositionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCoverageEligibilityResponseValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCoverageEligibilityResponseValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCoverageEligibilityResponseValue", generator = "Immutables")
  @Immutable
  static final class InternalCoverageEligibilityResponseValue
      implements ResourceList.InternalCoverageEligibilityResponseValue {
    private final CoverageEligibilityResponse coverageEligibilityResponse;

    private InternalCoverageEligibilityResponseValue(CoverageEligibilityResponse coverageEligibilityResponse) {
      this.coverageEligibilityResponse = coverageEligibilityResponse;
    }

    /**
     * @return The value of the {@code coverageEligibilityResponse} attribute
     */
    @JsonProperty("coverageEligibilityResponse")
    @JsonValue
    @Override
    public CoverageEligibilityResponse coverageEligibilityResponse() {
      return coverageEligibilityResponse;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCoverageEligibilityResponseValue#coverageEligibilityResponse() coverageEligibilityResponse} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for coverageEligibilityResponse
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCoverageEligibilityResponseValue withCoverageEligibilityResponse(CoverageEligibilityResponse value) {
      if (this.coverageEligibilityResponse == value) return this;
      CoverageEligibilityResponse newValue = Objects.requireNonNull(value, "coverageEligibilityResponse");
      return new ImmutableResourceList.InternalCoverageEligibilityResponseValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCoverageEligibilityResponseValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCoverageEligibilityResponseValue
          && equalTo((ImmutableResourceList.InternalCoverageEligibilityResponseValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCoverageEligibilityResponseValue another) {
      return coverageEligibilityResponse.equals(another.coverageEligibilityResponse);
    }

    /**
     * Computes a hash code from attributes: {@code coverageEligibilityResponse}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + coverageEligibilityResponse.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCoverageEligibilityResponseValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCoverageEligibilityResponseValue{"
          + "coverageEligibilityResponse=" + coverageEligibilityResponse
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCoverageEligibilityResponseValue fromJson(CoverageEligibilityResponse jsonValue) {
      ImmutableResourceList.InternalCoverageEligibilityResponseValue.Builder builder = ImmutableResourceList.InternalCoverageEligibilityResponseValue.builder();
      builder.coverageEligibilityResponse(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCoverageEligibilityResponseValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCoverageEligibilityResponseValue instance
     */
    public static ImmutableResourceList.InternalCoverageEligibilityResponseValue copyOf(ResourceList.InternalCoverageEligibilityResponseValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCoverageEligibilityResponseValue) {
        return (ImmutableResourceList.InternalCoverageEligibilityResponseValue) instance;
      }
      return ImmutableResourceList.InternalCoverageEligibilityResponseValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCoverageEligibilityResponseValue InternalCoverageEligibilityResponseValue}.
     * <pre>
     * ImmutableResourceList.InternalCoverageEligibilityResponseValue.builder()
     *    .coverageEligibilityResponse(com.fhir.types.fhir.CoverageEligibilityResponse) // required {@link ResourceList.InternalCoverageEligibilityResponseValue#coverageEligibilityResponse() coverageEligibilityResponse}
     *    .build();
     * </pre>
     * @return A new InternalCoverageEligibilityResponseValue builder
     */
    public static ImmutableResourceList.InternalCoverageEligibilityResponseValue.Builder builder() {
      return new ImmutableResourceList.InternalCoverageEligibilityResponseValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCoverageEligibilityResponseValue InternalCoverageEligibilityResponseValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCoverageEligibilityResponseValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_COVERAGE_ELIGIBILITY_RESPONSE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable CoverageEligibilityResponse coverageEligibilityResponse;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCoverageEligibilityResponseValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCoverageEligibilityResponseValue instance) {
        Objects.requireNonNull(instance, "instance");
        coverageEligibilityResponse(instance.coverageEligibilityResponse());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCoverageEligibilityResponseValue#coverageEligibilityResponse() coverageEligibilityResponse} attribute.
       * @param coverageEligibilityResponse The value for coverageEligibilityResponse 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("coverageEligibilityResponse")
      public final Builder coverageEligibilityResponse(CoverageEligibilityResponse coverageEligibilityResponse) {
        this.coverageEligibilityResponse = Objects.requireNonNull(coverageEligibilityResponse, "coverageEligibilityResponse");
        initBits &= ~INIT_BIT_COVERAGE_ELIGIBILITY_RESPONSE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCoverageEligibilityResponseValue InternalCoverageEligibilityResponseValue}.
       * @return An immutable instance of InternalCoverageEligibilityResponseValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCoverageEligibilityResponseValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCoverageEligibilityResponseValue(coverageEligibilityResponse);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_COVERAGE_ELIGIBILITY_RESPONSE) != 0) attributes.add("coverageEligibilityResponse");
        return "Cannot build InternalCoverageEligibilityResponseValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalExplanationOfBenefitValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalExplanationOfBenefitValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalExplanationOfBenefitValue", generator = "Immutables")
  @Immutable
  static final class InternalExplanationOfBenefitValue
      implements ResourceList.InternalExplanationOfBenefitValue {
    private final ExplanationOfBenefit explanationOfBenefit;

    private InternalExplanationOfBenefitValue(ExplanationOfBenefit explanationOfBenefit) {
      this.explanationOfBenefit = explanationOfBenefit;
    }

    /**
     * @return The value of the {@code explanationOfBenefit} attribute
     */
    @JsonProperty("explanationOfBenefit")
    @JsonValue
    @Override
    public ExplanationOfBenefit explanationOfBenefit() {
      return explanationOfBenefit;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalExplanationOfBenefitValue#explanationOfBenefit() explanationOfBenefit} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for explanationOfBenefit
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalExplanationOfBenefitValue withExplanationOfBenefit(ExplanationOfBenefit value) {
      if (this.explanationOfBenefit == value) return this;
      ExplanationOfBenefit newValue = Objects.requireNonNull(value, "explanationOfBenefit");
      return new ImmutableResourceList.InternalExplanationOfBenefitValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalExplanationOfBenefitValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalExplanationOfBenefitValue
          && equalTo((ImmutableResourceList.InternalExplanationOfBenefitValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalExplanationOfBenefitValue another) {
      return explanationOfBenefit.equals(another.explanationOfBenefit);
    }

    /**
     * Computes a hash code from attributes: {@code explanationOfBenefit}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + explanationOfBenefit.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalExplanationOfBenefitValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalExplanationOfBenefitValue{"
          + "explanationOfBenefit=" + explanationOfBenefit
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalExplanationOfBenefitValue fromJson(ExplanationOfBenefit jsonValue) {
      ImmutableResourceList.InternalExplanationOfBenefitValue.Builder builder = ImmutableResourceList.InternalExplanationOfBenefitValue.builder();
      builder.explanationOfBenefit(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalExplanationOfBenefitValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalExplanationOfBenefitValue instance
     */
    public static ImmutableResourceList.InternalExplanationOfBenefitValue copyOf(ResourceList.InternalExplanationOfBenefitValue instance) {
      if (instance instanceof ImmutableResourceList.InternalExplanationOfBenefitValue) {
        return (ImmutableResourceList.InternalExplanationOfBenefitValue) instance;
      }
      return ImmutableResourceList.InternalExplanationOfBenefitValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalExplanationOfBenefitValue InternalExplanationOfBenefitValue}.
     * <pre>
     * ImmutableResourceList.InternalExplanationOfBenefitValue.builder()
     *    .explanationOfBenefit(com.fhir.types.fhir.ExplanationOfBenefit) // required {@link ResourceList.InternalExplanationOfBenefitValue#explanationOfBenefit() explanationOfBenefit}
     *    .build();
     * </pre>
     * @return A new InternalExplanationOfBenefitValue builder
     */
    public static ImmutableResourceList.InternalExplanationOfBenefitValue.Builder builder() {
      return new ImmutableResourceList.InternalExplanationOfBenefitValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalExplanationOfBenefitValue InternalExplanationOfBenefitValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalExplanationOfBenefitValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_EXPLANATION_OF_BENEFIT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ExplanationOfBenefit explanationOfBenefit;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalExplanationOfBenefitValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalExplanationOfBenefitValue instance) {
        Objects.requireNonNull(instance, "instance");
        explanationOfBenefit(instance.explanationOfBenefit());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalExplanationOfBenefitValue#explanationOfBenefit() explanationOfBenefit} attribute.
       * @param explanationOfBenefit The value for explanationOfBenefit 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("explanationOfBenefit")
      public final Builder explanationOfBenefit(ExplanationOfBenefit explanationOfBenefit) {
        this.explanationOfBenefit = Objects.requireNonNull(explanationOfBenefit, "explanationOfBenefit");
        initBits &= ~INIT_BIT_EXPLANATION_OF_BENEFIT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalExplanationOfBenefitValue InternalExplanationOfBenefitValue}.
       * @return An immutable instance of InternalExplanationOfBenefitValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalExplanationOfBenefitValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalExplanationOfBenefitValue(explanationOfBenefit);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_EXPLANATION_OF_BENEFIT) != 0) attributes.add("explanationOfBenefit");
        return "Cannot build InternalExplanationOfBenefitValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalDeviceRequestValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalDeviceRequestValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalDeviceRequestValue", generator = "Immutables")
  @Immutable
  static final class InternalDeviceRequestValue
      implements ResourceList.InternalDeviceRequestValue {
    private final DeviceRequest deviceRequest;

    private InternalDeviceRequestValue(DeviceRequest deviceRequest) {
      this.deviceRequest = deviceRequest;
    }

    /**
     * @return The value of the {@code deviceRequest} attribute
     */
    @JsonProperty("deviceRequest")
    @JsonValue
    @Override
    public DeviceRequest deviceRequest() {
      return deviceRequest;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalDeviceRequestValue#deviceRequest() deviceRequest} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for deviceRequest
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalDeviceRequestValue withDeviceRequest(DeviceRequest value) {
      if (this.deviceRequest == value) return this;
      DeviceRequest newValue = Objects.requireNonNull(value, "deviceRequest");
      return new ImmutableResourceList.InternalDeviceRequestValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalDeviceRequestValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalDeviceRequestValue
          && equalTo((ImmutableResourceList.InternalDeviceRequestValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalDeviceRequestValue another) {
      return deviceRequest.equals(another.deviceRequest);
    }

    /**
     * Computes a hash code from attributes: {@code deviceRequest}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + deviceRequest.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalDeviceRequestValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalDeviceRequestValue{"
          + "deviceRequest=" + deviceRequest
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalDeviceRequestValue fromJson(DeviceRequest jsonValue) {
      ImmutableResourceList.InternalDeviceRequestValue.Builder builder = ImmutableResourceList.InternalDeviceRequestValue.builder();
      builder.deviceRequest(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalDeviceRequestValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalDeviceRequestValue instance
     */
    public static ImmutableResourceList.InternalDeviceRequestValue copyOf(ResourceList.InternalDeviceRequestValue instance) {
      if (instance instanceof ImmutableResourceList.InternalDeviceRequestValue) {
        return (ImmutableResourceList.InternalDeviceRequestValue) instance;
      }
      return ImmutableResourceList.InternalDeviceRequestValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalDeviceRequestValue InternalDeviceRequestValue}.
     * <pre>
     * ImmutableResourceList.InternalDeviceRequestValue.builder()
     *    .deviceRequest(com.fhir.types.fhir.DeviceRequest) // required {@link ResourceList.InternalDeviceRequestValue#deviceRequest() deviceRequest}
     *    .build();
     * </pre>
     * @return A new InternalDeviceRequestValue builder
     */
    public static ImmutableResourceList.InternalDeviceRequestValue.Builder builder() {
      return new ImmutableResourceList.InternalDeviceRequestValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalDeviceRequestValue InternalDeviceRequestValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalDeviceRequestValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_DEVICE_REQUEST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable DeviceRequest deviceRequest;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalDeviceRequestValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalDeviceRequestValue instance) {
        Objects.requireNonNull(instance, "instance");
        deviceRequest(instance.deviceRequest());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalDeviceRequestValue#deviceRequest() deviceRequest} attribute.
       * @param deviceRequest The value for deviceRequest 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("deviceRequest")
      public final Builder deviceRequest(DeviceRequest deviceRequest) {
        this.deviceRequest = Objects.requireNonNull(deviceRequest, "deviceRequest");
        initBits &= ~INIT_BIT_DEVICE_REQUEST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalDeviceRequestValue InternalDeviceRequestValue}.
       * @return An immutable instance of InternalDeviceRequestValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalDeviceRequestValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalDeviceRequestValue(deviceRequest);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_DEVICE_REQUEST) != 0) attributes.add("deviceRequest");
        return "Cannot build InternalDeviceRequestValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMessageDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMessageDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMessageDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalMessageDefinitionValue
      implements ResourceList.InternalMessageDefinitionValue {
    private final MessageDefinition messageDefinition;

    private InternalMessageDefinitionValue(MessageDefinition messageDefinition) {
      this.messageDefinition = messageDefinition;
    }

    /**
     * @return The value of the {@code messageDefinition} attribute
     */
    @JsonProperty("messageDefinition")
    @JsonValue
    @Override
    public MessageDefinition messageDefinition() {
      return messageDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMessageDefinitionValue#messageDefinition() messageDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for messageDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMessageDefinitionValue withMessageDefinition(MessageDefinition value) {
      if (this.messageDefinition == value) return this;
      MessageDefinition newValue = Objects.requireNonNull(value, "messageDefinition");
      return new ImmutableResourceList.InternalMessageDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMessageDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMessageDefinitionValue
          && equalTo((ImmutableResourceList.InternalMessageDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMessageDefinitionValue another) {
      return messageDefinition.equals(another.messageDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code messageDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + messageDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMessageDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMessageDefinitionValue{"
          + "messageDefinition=" + messageDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMessageDefinitionValue fromJson(MessageDefinition jsonValue) {
      ImmutableResourceList.InternalMessageDefinitionValue.Builder builder = ImmutableResourceList.InternalMessageDefinitionValue.builder();
      builder.messageDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMessageDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMessageDefinitionValue instance
     */
    public static ImmutableResourceList.InternalMessageDefinitionValue copyOf(ResourceList.InternalMessageDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMessageDefinitionValue) {
        return (ImmutableResourceList.InternalMessageDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalMessageDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMessageDefinitionValue InternalMessageDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalMessageDefinitionValue.builder()
     *    .messageDefinition(com.fhir.types.fhir.MessageDefinition) // required {@link ResourceList.InternalMessageDefinitionValue#messageDefinition() messageDefinition}
     *    .build();
     * </pre>
     * @return A new InternalMessageDefinitionValue builder
     */
    public static ImmutableResourceList.InternalMessageDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalMessageDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMessageDefinitionValue InternalMessageDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMessageDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MESSAGE_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MessageDefinition messageDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMessageDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMessageDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        messageDefinition(instance.messageDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMessageDefinitionValue#messageDefinition() messageDefinition} attribute.
       * @param messageDefinition The value for messageDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("messageDefinition")
      public final Builder messageDefinition(MessageDefinition messageDefinition) {
        this.messageDefinition = Objects.requireNonNull(messageDefinition, "messageDefinition");
        initBits &= ~INIT_BIT_MESSAGE_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMessageDefinitionValue InternalMessageDefinitionValue}.
       * @return An immutable instance of InternalMessageDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMessageDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMessageDefinitionValue(messageDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MESSAGE_DEFINITION) != 0) attributes.add("messageDefinition");
        return "Cannot build InternalMessageDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCommunicationRequestValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCommunicationRequestValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCommunicationRequestValue", generator = "Immutables")
  @Immutable
  static final class InternalCommunicationRequestValue
      implements ResourceList.InternalCommunicationRequestValue {
    private final CommunicationRequest communicationRequest;

    private InternalCommunicationRequestValue(CommunicationRequest communicationRequest) {
      this.communicationRequest = communicationRequest;
    }

    /**
     * @return The value of the {@code communicationRequest} attribute
     */
    @JsonProperty("communicationRequest")
    @JsonValue
    @Override
    public CommunicationRequest communicationRequest() {
      return communicationRequest;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCommunicationRequestValue#communicationRequest() communicationRequest} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for communicationRequest
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCommunicationRequestValue withCommunicationRequest(CommunicationRequest value) {
      if (this.communicationRequest == value) return this;
      CommunicationRequest newValue = Objects.requireNonNull(value, "communicationRequest");
      return new ImmutableResourceList.InternalCommunicationRequestValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCommunicationRequestValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCommunicationRequestValue
          && equalTo((ImmutableResourceList.InternalCommunicationRequestValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCommunicationRequestValue another) {
      return communicationRequest.equals(another.communicationRequest);
    }

    /**
     * Computes a hash code from attributes: {@code communicationRequest}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + communicationRequest.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCommunicationRequestValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCommunicationRequestValue{"
          + "communicationRequest=" + communicationRequest
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCommunicationRequestValue fromJson(CommunicationRequest jsonValue) {
      ImmutableResourceList.InternalCommunicationRequestValue.Builder builder = ImmutableResourceList.InternalCommunicationRequestValue.builder();
      builder.communicationRequest(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCommunicationRequestValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCommunicationRequestValue instance
     */
    public static ImmutableResourceList.InternalCommunicationRequestValue copyOf(ResourceList.InternalCommunicationRequestValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCommunicationRequestValue) {
        return (ImmutableResourceList.InternalCommunicationRequestValue) instance;
      }
      return ImmutableResourceList.InternalCommunicationRequestValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCommunicationRequestValue InternalCommunicationRequestValue}.
     * <pre>
     * ImmutableResourceList.InternalCommunicationRequestValue.builder()
     *    .communicationRequest(com.fhir.types.fhir.CommunicationRequest) // required {@link ResourceList.InternalCommunicationRequestValue#communicationRequest() communicationRequest}
     *    .build();
     * </pre>
     * @return A new InternalCommunicationRequestValue builder
     */
    public static ImmutableResourceList.InternalCommunicationRequestValue.Builder builder() {
      return new ImmutableResourceList.InternalCommunicationRequestValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCommunicationRequestValue InternalCommunicationRequestValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCommunicationRequestValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_COMMUNICATION_REQUEST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable CommunicationRequest communicationRequest;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCommunicationRequestValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCommunicationRequestValue instance) {
        Objects.requireNonNull(instance, "instance");
        communicationRequest(instance.communicationRequest());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCommunicationRequestValue#communicationRequest() communicationRequest} attribute.
       * @param communicationRequest The value for communicationRequest 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("communicationRequest")
      public final Builder communicationRequest(CommunicationRequest communicationRequest) {
        this.communicationRequest = Objects.requireNonNull(communicationRequest, "communicationRequest");
        initBits &= ~INIT_BIT_COMMUNICATION_REQUEST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCommunicationRequestValue InternalCommunicationRequestValue}.
       * @return An immutable instance of InternalCommunicationRequestValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCommunicationRequestValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCommunicationRequestValue(communicationRequest);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_COMMUNICATION_REQUEST) != 0) attributes.add("communicationRequest");
        return "Cannot build InternalCommunicationRequestValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalBundleValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalBundleValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalBundleValue", generator = "Immutables")
  @Immutable
  static final class InternalBundleValue implements ResourceList.InternalBundleValue {
    private final Bundle bundle;

    private InternalBundleValue(Bundle bundle) {
      this.bundle = bundle;
    }

    /**
     * @return The value of the {@code bundle} attribute
     */
    @JsonProperty("bundle")
    @JsonValue
    @Override
    public Bundle bundle() {
      return bundle;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalBundleValue#bundle() bundle} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for bundle
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalBundleValue withBundle(Bundle value) {
      if (this.bundle == value) return this;
      Bundle newValue = Objects.requireNonNull(value, "bundle");
      return new ImmutableResourceList.InternalBundleValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalBundleValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalBundleValue
          && equalTo((ImmutableResourceList.InternalBundleValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalBundleValue another) {
      return bundle.equals(another.bundle);
    }

    /**
     * Computes a hash code from attributes: {@code bundle}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + bundle.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalBundleValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalBundleValue{"
          + "bundle=" + bundle
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalBundleValue fromJson(Bundle jsonValue) {
      ImmutableResourceList.InternalBundleValue.Builder builder = ImmutableResourceList.InternalBundleValue.builder();
      builder.bundle(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalBundleValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalBundleValue instance
     */
    public static ImmutableResourceList.InternalBundleValue copyOf(ResourceList.InternalBundleValue instance) {
      if (instance instanceof ImmutableResourceList.InternalBundleValue) {
        return (ImmutableResourceList.InternalBundleValue) instance;
      }
      return ImmutableResourceList.InternalBundleValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalBundleValue InternalBundleValue}.
     * <pre>
     * ImmutableResourceList.InternalBundleValue.builder()
     *    .bundle(com.fhir.types.fhir.Bundle) // required {@link ResourceList.InternalBundleValue#bundle() bundle}
     *    .build();
     * </pre>
     * @return A new InternalBundleValue builder
     */
    public static ImmutableResourceList.InternalBundleValue.Builder builder() {
      return new ImmutableResourceList.InternalBundleValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalBundleValue InternalBundleValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalBundleValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_BUNDLE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Bundle bundle;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalBundleValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalBundleValue instance) {
        Objects.requireNonNull(instance, "instance");
        bundle(instance.bundle());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalBundleValue#bundle() bundle} attribute.
       * @param bundle The value for bundle 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("bundle")
      public final Builder bundle(Bundle bundle) {
        this.bundle = Objects.requireNonNull(bundle, "bundle");
        initBits &= ~INIT_BIT_BUNDLE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalBundleValue InternalBundleValue}.
       * @return An immutable instance of InternalBundleValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalBundleValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalBundleValue(bundle);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_BUNDLE) != 0) attributes.add("bundle");
        return "Cannot build InternalBundleValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalPractitionerRoleValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalPractitionerRoleValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalPractitionerRoleValue", generator = "Immutables")
  @Immutable
  static final class InternalPractitionerRoleValue
      implements ResourceList.InternalPractitionerRoleValue {
    private final PractitionerRole practitionerRole;

    private InternalPractitionerRoleValue(PractitionerRole practitionerRole) {
      this.practitionerRole = practitionerRole;
    }

    /**
     * @return The value of the {@code practitionerRole} attribute
     */
    @JsonProperty("practitionerRole")
    @JsonValue
    @Override
    public PractitionerRole practitionerRole() {
      return practitionerRole;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalPractitionerRoleValue#practitionerRole() practitionerRole} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for practitionerRole
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalPractitionerRoleValue withPractitionerRole(PractitionerRole value) {
      if (this.practitionerRole == value) return this;
      PractitionerRole newValue = Objects.requireNonNull(value, "practitionerRole");
      return new ImmutableResourceList.InternalPractitionerRoleValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalPractitionerRoleValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalPractitionerRoleValue
          && equalTo((ImmutableResourceList.InternalPractitionerRoleValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalPractitionerRoleValue another) {
      return practitionerRole.equals(another.practitionerRole);
    }

    /**
     * Computes a hash code from attributes: {@code practitionerRole}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + practitionerRole.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalPractitionerRoleValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalPractitionerRoleValue{"
          + "practitionerRole=" + practitionerRole
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalPractitionerRoleValue fromJson(PractitionerRole jsonValue) {
      ImmutableResourceList.InternalPractitionerRoleValue.Builder builder = ImmutableResourceList.InternalPractitionerRoleValue.builder();
      builder.practitionerRole(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalPractitionerRoleValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalPractitionerRoleValue instance
     */
    public static ImmutableResourceList.InternalPractitionerRoleValue copyOf(ResourceList.InternalPractitionerRoleValue instance) {
      if (instance instanceof ImmutableResourceList.InternalPractitionerRoleValue) {
        return (ImmutableResourceList.InternalPractitionerRoleValue) instance;
      }
      return ImmutableResourceList.InternalPractitionerRoleValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalPractitionerRoleValue InternalPractitionerRoleValue}.
     * <pre>
     * ImmutableResourceList.InternalPractitionerRoleValue.builder()
     *    .practitionerRole(com.fhir.types.fhir.PractitionerRole) // required {@link ResourceList.InternalPractitionerRoleValue#practitionerRole() practitionerRole}
     *    .build();
     * </pre>
     * @return A new InternalPractitionerRoleValue builder
     */
    public static ImmutableResourceList.InternalPractitionerRoleValue.Builder builder() {
      return new ImmutableResourceList.InternalPractitionerRoleValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalPractitionerRoleValue InternalPractitionerRoleValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalPractitionerRoleValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PRACTITIONER_ROLE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable PractitionerRole practitionerRole;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalPractitionerRoleValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalPractitionerRoleValue instance) {
        Objects.requireNonNull(instance, "instance");
        practitionerRole(instance.practitionerRole());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalPractitionerRoleValue#practitionerRole() practitionerRole} attribute.
       * @param practitionerRole The value for practitionerRole 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("practitionerRole")
      public final Builder practitionerRole(PractitionerRole practitionerRole) {
        this.practitionerRole = Objects.requireNonNull(practitionerRole, "practitionerRole");
        initBits &= ~INIT_BIT_PRACTITIONER_ROLE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalPractitionerRoleValue InternalPractitionerRoleValue}.
       * @return An immutable instance of InternalPractitionerRoleValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalPractitionerRoleValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalPractitionerRoleValue(practitionerRole);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PRACTITIONER_ROLE) != 0) attributes.add("practitionerRole");
        return "Cannot build InternalPractitionerRoleValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSupplyRequestValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSupplyRequestValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSupplyRequestValue", generator = "Immutables")
  @Immutable
  static final class InternalSupplyRequestValue
      implements ResourceList.InternalSupplyRequestValue {
    private final SupplyRequest supplyRequest;

    private InternalSupplyRequestValue(SupplyRequest supplyRequest) {
      this.supplyRequest = supplyRequest;
    }

    /**
     * @return The value of the {@code supplyRequest} attribute
     */
    @JsonProperty("supplyRequest")
    @JsonValue
    @Override
    public SupplyRequest supplyRequest() {
      return supplyRequest;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSupplyRequestValue#supplyRequest() supplyRequest} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for supplyRequest
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSupplyRequestValue withSupplyRequest(SupplyRequest value) {
      if (this.supplyRequest == value) return this;
      SupplyRequest newValue = Objects.requireNonNull(value, "supplyRequest");
      return new ImmutableResourceList.InternalSupplyRequestValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSupplyRequestValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSupplyRequestValue
          && equalTo((ImmutableResourceList.InternalSupplyRequestValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSupplyRequestValue another) {
      return supplyRequest.equals(another.supplyRequest);
    }

    /**
     * Computes a hash code from attributes: {@code supplyRequest}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + supplyRequest.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSupplyRequestValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSupplyRequestValue{"
          + "supplyRequest=" + supplyRequest
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSupplyRequestValue fromJson(SupplyRequest jsonValue) {
      ImmutableResourceList.InternalSupplyRequestValue.Builder builder = ImmutableResourceList.InternalSupplyRequestValue.builder();
      builder.supplyRequest(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSupplyRequestValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSupplyRequestValue instance
     */
    public static ImmutableResourceList.InternalSupplyRequestValue copyOf(ResourceList.InternalSupplyRequestValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSupplyRequestValue) {
        return (ImmutableResourceList.InternalSupplyRequestValue) instance;
      }
      return ImmutableResourceList.InternalSupplyRequestValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSupplyRequestValue InternalSupplyRequestValue}.
     * <pre>
     * ImmutableResourceList.InternalSupplyRequestValue.builder()
     *    .supplyRequest(com.fhir.types.fhir.SupplyRequest) // required {@link ResourceList.InternalSupplyRequestValue#supplyRequest() supplyRequest}
     *    .build();
     * </pre>
     * @return A new InternalSupplyRequestValue builder
     */
    public static ImmutableResourceList.InternalSupplyRequestValue.Builder builder() {
      return new ImmutableResourceList.InternalSupplyRequestValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSupplyRequestValue InternalSupplyRequestValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSupplyRequestValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUPPLY_REQUEST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SupplyRequest supplyRequest;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSupplyRequestValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSupplyRequestValue instance) {
        Objects.requireNonNull(instance, "instance");
        supplyRequest(instance.supplyRequest());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSupplyRequestValue#supplyRequest() supplyRequest} attribute.
       * @param supplyRequest The value for supplyRequest 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("supplyRequest")
      public final Builder supplyRequest(SupplyRequest supplyRequest) {
        this.supplyRequest = Objects.requireNonNull(supplyRequest, "supplyRequest");
        initBits &= ~INIT_BIT_SUPPLY_REQUEST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSupplyRequestValue InternalSupplyRequestValue}.
       * @return An immutable instance of InternalSupplyRequestValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSupplyRequestValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSupplyRequestValue(supplyRequest);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUPPLY_REQUEST) != 0) attributes.add("supplyRequest");
        return "Cannot build InternalSupplyRequestValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductPharmaceuticalValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductPharmaceuticalValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductPharmaceuticalValue
      implements ResourceList.InternalMedicinalProductPharmaceuticalValue {
    private final MedicinalProductPharmaceutical medicinalProductPharmaceutical;

    private InternalMedicinalProductPharmaceuticalValue(MedicinalProductPharmaceutical medicinalProductPharmaceutical) {
      this.medicinalProductPharmaceutical = medicinalProductPharmaceutical;
    }

    /**
     * @return The value of the {@code medicinalProductPharmaceutical} attribute
     */
    @JsonProperty("medicinalProductPharmaceutical")
    @JsonValue
    @Override
    public MedicinalProductPharmaceutical medicinalProductPharmaceutical() {
      return medicinalProductPharmaceutical;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductPharmaceuticalValue#medicinalProductPharmaceutical() medicinalProductPharmaceutical} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProductPharmaceutical
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue withMedicinalProductPharmaceutical(MedicinalProductPharmaceutical value) {
      if (this.medicinalProductPharmaceutical == value) return this;
      MedicinalProductPharmaceutical newValue = Objects.requireNonNull(value, "medicinalProductPharmaceutical");
      return new ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductPharmaceuticalValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue another) {
      return medicinalProductPharmaceutical.equals(another.medicinalProductPharmaceutical);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProductPharmaceutical}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProductPharmaceutical.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductPharmaceuticalValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductPharmaceuticalValue{"
          + "medicinalProductPharmaceutical=" + medicinalProductPharmaceutical
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue fromJson(MedicinalProductPharmaceutical jsonValue) {
      ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue.Builder builder = ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue.builder();
      builder.medicinalProductPharmaceutical(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductPharmaceuticalValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductPharmaceuticalValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue copyOf(ResourceList.InternalMedicinalProductPharmaceuticalValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue) {
        return (ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue InternalMedicinalProductPharmaceuticalValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue.builder()
     *    .medicinalProductPharmaceutical(com.fhir.types.fhir.MedicinalProductPharmaceutical) // required {@link ResourceList.InternalMedicinalProductPharmaceuticalValue#medicinalProductPharmaceutical() medicinalProductPharmaceutical}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductPharmaceuticalValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue InternalMedicinalProductPharmaceuticalValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductPharmaceuticalValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT_PHARMACEUTICAL = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProductPharmaceutical medicinalProductPharmaceutical;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductPharmaceuticalValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductPharmaceuticalValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProductPharmaceutical(instance.medicinalProductPharmaceutical());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductPharmaceuticalValue#medicinalProductPharmaceutical() medicinalProductPharmaceutical} attribute.
       * @param medicinalProductPharmaceutical The value for medicinalProductPharmaceutical 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProductPharmaceutical")
      public final Builder medicinalProductPharmaceutical(MedicinalProductPharmaceutical medicinalProductPharmaceutical) {
        this.medicinalProductPharmaceutical = Objects.requireNonNull(medicinalProductPharmaceutical, "medicinalProductPharmaceutical");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT_PHARMACEUTICAL;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue InternalMedicinalProductPharmaceuticalValue}.
       * @return An immutable instance of InternalMedicinalProductPharmaceuticalValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductPharmaceuticalValue(medicinalProductPharmaceutical);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT_PHARMACEUTICAL) != 0) attributes.add("medicinalProductPharmaceutical");
        return "Cannot build InternalMedicinalProductPharmaceuticalValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalDeviceDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalDeviceDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalDeviceDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalDeviceDefinitionValue
      implements ResourceList.InternalDeviceDefinitionValue {
    private final DeviceDefinition deviceDefinition;

    private InternalDeviceDefinitionValue(DeviceDefinition deviceDefinition) {
      this.deviceDefinition = deviceDefinition;
    }

    /**
     * @return The value of the {@code deviceDefinition} attribute
     */
    @JsonProperty("deviceDefinition")
    @JsonValue
    @Override
    public DeviceDefinition deviceDefinition() {
      return deviceDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalDeviceDefinitionValue#deviceDefinition() deviceDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for deviceDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalDeviceDefinitionValue withDeviceDefinition(DeviceDefinition value) {
      if (this.deviceDefinition == value) return this;
      DeviceDefinition newValue = Objects.requireNonNull(value, "deviceDefinition");
      return new ImmutableResourceList.InternalDeviceDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalDeviceDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalDeviceDefinitionValue
          && equalTo((ImmutableResourceList.InternalDeviceDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalDeviceDefinitionValue another) {
      return deviceDefinition.equals(another.deviceDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code deviceDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + deviceDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalDeviceDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalDeviceDefinitionValue{"
          + "deviceDefinition=" + deviceDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalDeviceDefinitionValue fromJson(DeviceDefinition jsonValue) {
      ImmutableResourceList.InternalDeviceDefinitionValue.Builder builder = ImmutableResourceList.InternalDeviceDefinitionValue.builder();
      builder.deviceDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalDeviceDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalDeviceDefinitionValue instance
     */
    public static ImmutableResourceList.InternalDeviceDefinitionValue copyOf(ResourceList.InternalDeviceDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalDeviceDefinitionValue) {
        return (ImmutableResourceList.InternalDeviceDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalDeviceDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalDeviceDefinitionValue InternalDeviceDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalDeviceDefinitionValue.builder()
     *    .deviceDefinition(com.fhir.types.fhir.DeviceDefinition) // required {@link ResourceList.InternalDeviceDefinitionValue#deviceDefinition() deviceDefinition}
     *    .build();
     * </pre>
     * @return A new InternalDeviceDefinitionValue builder
     */
    public static ImmutableResourceList.InternalDeviceDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalDeviceDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalDeviceDefinitionValue InternalDeviceDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalDeviceDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_DEVICE_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable DeviceDefinition deviceDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalDeviceDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalDeviceDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        deviceDefinition(instance.deviceDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalDeviceDefinitionValue#deviceDefinition() deviceDefinition} attribute.
       * @param deviceDefinition The value for deviceDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("deviceDefinition")
      public final Builder deviceDefinition(DeviceDefinition deviceDefinition) {
        this.deviceDefinition = Objects.requireNonNull(deviceDefinition, "deviceDefinition");
        initBits &= ~INIT_BIT_DEVICE_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalDeviceDefinitionValue InternalDeviceDefinitionValue}.
       * @return An immutable instance of InternalDeviceDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalDeviceDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalDeviceDefinitionValue(deviceDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_DEVICE_DEFINITION) != 0) attributes.add("deviceDefinition");
        return "Cannot build InternalDeviceDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalGuidanceResponseValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalGuidanceResponseValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalGuidanceResponseValue", generator = "Immutables")
  @Immutable
  static final class InternalGuidanceResponseValue
      implements ResourceList.InternalGuidanceResponseValue {
    private final GuidanceResponse guidanceResponse;

    private InternalGuidanceResponseValue(GuidanceResponse guidanceResponse) {
      this.guidanceResponse = guidanceResponse;
    }

    /**
     * @return The value of the {@code guidanceResponse} attribute
     */
    @JsonProperty("guidanceResponse")
    @JsonValue
    @Override
    public GuidanceResponse guidanceResponse() {
      return guidanceResponse;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalGuidanceResponseValue#guidanceResponse() guidanceResponse} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for guidanceResponse
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalGuidanceResponseValue withGuidanceResponse(GuidanceResponse value) {
      if (this.guidanceResponse == value) return this;
      GuidanceResponse newValue = Objects.requireNonNull(value, "guidanceResponse");
      return new ImmutableResourceList.InternalGuidanceResponseValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalGuidanceResponseValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalGuidanceResponseValue
          && equalTo((ImmutableResourceList.InternalGuidanceResponseValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalGuidanceResponseValue another) {
      return guidanceResponse.equals(another.guidanceResponse);
    }

    /**
     * Computes a hash code from attributes: {@code guidanceResponse}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + guidanceResponse.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalGuidanceResponseValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalGuidanceResponseValue{"
          + "guidanceResponse=" + guidanceResponse
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalGuidanceResponseValue fromJson(GuidanceResponse jsonValue) {
      ImmutableResourceList.InternalGuidanceResponseValue.Builder builder = ImmutableResourceList.InternalGuidanceResponseValue.builder();
      builder.guidanceResponse(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalGuidanceResponseValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalGuidanceResponseValue instance
     */
    public static ImmutableResourceList.InternalGuidanceResponseValue copyOf(ResourceList.InternalGuidanceResponseValue instance) {
      if (instance instanceof ImmutableResourceList.InternalGuidanceResponseValue) {
        return (ImmutableResourceList.InternalGuidanceResponseValue) instance;
      }
      return ImmutableResourceList.InternalGuidanceResponseValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalGuidanceResponseValue InternalGuidanceResponseValue}.
     * <pre>
     * ImmutableResourceList.InternalGuidanceResponseValue.builder()
     *    .guidanceResponse(com.fhir.types.fhir.GuidanceResponse) // required {@link ResourceList.InternalGuidanceResponseValue#guidanceResponse() guidanceResponse}
     *    .build();
     * </pre>
     * @return A new InternalGuidanceResponseValue builder
     */
    public static ImmutableResourceList.InternalGuidanceResponseValue.Builder builder() {
      return new ImmutableResourceList.InternalGuidanceResponseValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalGuidanceResponseValue InternalGuidanceResponseValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalGuidanceResponseValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_GUIDANCE_RESPONSE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable GuidanceResponse guidanceResponse;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalGuidanceResponseValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalGuidanceResponseValue instance) {
        Objects.requireNonNull(instance, "instance");
        guidanceResponse(instance.guidanceResponse());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalGuidanceResponseValue#guidanceResponse() guidanceResponse} attribute.
       * @param guidanceResponse The value for guidanceResponse 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("guidanceResponse")
      public final Builder guidanceResponse(GuidanceResponse guidanceResponse) {
        this.guidanceResponse = Objects.requireNonNull(guidanceResponse, "guidanceResponse");
        initBits &= ~INIT_BIT_GUIDANCE_RESPONSE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalGuidanceResponseValue InternalGuidanceResponseValue}.
       * @return An immutable instance of InternalGuidanceResponseValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalGuidanceResponseValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalGuidanceResponseValue(guidanceResponse);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_GUIDANCE_RESPONSE) != 0) attributes.add("guidanceResponse");
        return "Cannot build InternalGuidanceResponseValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalImagingStudyValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalImagingStudyValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalImagingStudyValue", generator = "Immutables")
  @Immutable
  static final class InternalImagingStudyValue
      implements ResourceList.InternalImagingStudyValue {
    private final ImagingStudy imagingStudy;

    private InternalImagingStudyValue(ImagingStudy imagingStudy) {
      this.imagingStudy = imagingStudy;
    }

    /**
     * @return The value of the {@code imagingStudy} attribute
     */
    @JsonProperty("imagingStudy")
    @JsonValue
    @Override
    public ImagingStudy imagingStudy() {
      return imagingStudy;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalImagingStudyValue#imagingStudy() imagingStudy} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for imagingStudy
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalImagingStudyValue withImagingStudy(ImagingStudy value) {
      if (this.imagingStudy == value) return this;
      ImagingStudy newValue = Objects.requireNonNull(value, "imagingStudy");
      return new ImmutableResourceList.InternalImagingStudyValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalImagingStudyValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalImagingStudyValue
          && equalTo((ImmutableResourceList.InternalImagingStudyValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalImagingStudyValue another) {
      return imagingStudy.equals(another.imagingStudy);
    }

    /**
     * Computes a hash code from attributes: {@code imagingStudy}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + imagingStudy.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalImagingStudyValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalImagingStudyValue{"
          + "imagingStudy=" + imagingStudy
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalImagingStudyValue fromJson(ImagingStudy jsonValue) {
      ImmutableResourceList.InternalImagingStudyValue.Builder builder = ImmutableResourceList.InternalImagingStudyValue.builder();
      builder.imagingStudy(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalImagingStudyValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalImagingStudyValue instance
     */
    public static ImmutableResourceList.InternalImagingStudyValue copyOf(ResourceList.InternalImagingStudyValue instance) {
      if (instance instanceof ImmutableResourceList.InternalImagingStudyValue) {
        return (ImmutableResourceList.InternalImagingStudyValue) instance;
      }
      return ImmutableResourceList.InternalImagingStudyValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalImagingStudyValue InternalImagingStudyValue}.
     * <pre>
     * ImmutableResourceList.InternalImagingStudyValue.builder()
     *    .imagingStudy(com.fhir.types.fhir.ImagingStudy) // required {@link ResourceList.InternalImagingStudyValue#imagingStudy() imagingStudy}
     *    .build();
     * </pre>
     * @return A new InternalImagingStudyValue builder
     */
    public static ImmutableResourceList.InternalImagingStudyValue.Builder builder() {
      return new ImmutableResourceList.InternalImagingStudyValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalImagingStudyValue InternalImagingStudyValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalImagingStudyValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_IMAGING_STUDY = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ImagingStudy imagingStudy;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalImagingStudyValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalImagingStudyValue instance) {
        Objects.requireNonNull(instance, "instance");
        imagingStudy(instance.imagingStudy());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalImagingStudyValue#imagingStudy() imagingStudy} attribute.
       * @param imagingStudy The value for imagingStudy 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("imagingStudy")
      public final Builder imagingStudy(ImagingStudy imagingStudy) {
        this.imagingStudy = Objects.requireNonNull(imagingStudy, "imagingStudy");
        initBits &= ~INIT_BIT_IMAGING_STUDY;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalImagingStudyValue InternalImagingStudyValue}.
       * @return An immutable instance of InternalImagingStudyValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalImagingStudyValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalImagingStudyValue(imagingStudy);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_IMAGING_STUDY) != 0) attributes.add("imagingStudy");
        return "Cannot build InternalImagingStudyValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalDeviceMetricValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalDeviceMetricValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalDeviceMetricValue", generator = "Immutables")
  @Immutable
  static final class InternalDeviceMetricValue
      implements ResourceList.InternalDeviceMetricValue {
    private final DeviceMetric deviceMetric;

    private InternalDeviceMetricValue(DeviceMetric deviceMetric) {
      this.deviceMetric = deviceMetric;
    }

    /**
     * @return The value of the {@code deviceMetric} attribute
     */
    @JsonProperty("deviceMetric")
    @JsonValue
    @Override
    public DeviceMetric deviceMetric() {
      return deviceMetric;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalDeviceMetricValue#deviceMetric() deviceMetric} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for deviceMetric
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalDeviceMetricValue withDeviceMetric(DeviceMetric value) {
      if (this.deviceMetric == value) return this;
      DeviceMetric newValue = Objects.requireNonNull(value, "deviceMetric");
      return new ImmutableResourceList.InternalDeviceMetricValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalDeviceMetricValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalDeviceMetricValue
          && equalTo((ImmutableResourceList.InternalDeviceMetricValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalDeviceMetricValue another) {
      return deviceMetric.equals(another.deviceMetric);
    }

    /**
     * Computes a hash code from attributes: {@code deviceMetric}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + deviceMetric.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalDeviceMetricValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalDeviceMetricValue{"
          + "deviceMetric=" + deviceMetric
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalDeviceMetricValue fromJson(DeviceMetric jsonValue) {
      ImmutableResourceList.InternalDeviceMetricValue.Builder builder = ImmutableResourceList.InternalDeviceMetricValue.builder();
      builder.deviceMetric(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalDeviceMetricValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalDeviceMetricValue instance
     */
    public static ImmutableResourceList.InternalDeviceMetricValue copyOf(ResourceList.InternalDeviceMetricValue instance) {
      if (instance instanceof ImmutableResourceList.InternalDeviceMetricValue) {
        return (ImmutableResourceList.InternalDeviceMetricValue) instance;
      }
      return ImmutableResourceList.InternalDeviceMetricValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalDeviceMetricValue InternalDeviceMetricValue}.
     * <pre>
     * ImmutableResourceList.InternalDeviceMetricValue.builder()
     *    .deviceMetric(com.fhir.types.fhir.DeviceMetric) // required {@link ResourceList.InternalDeviceMetricValue#deviceMetric() deviceMetric}
     *    .build();
     * </pre>
     * @return A new InternalDeviceMetricValue builder
     */
    public static ImmutableResourceList.InternalDeviceMetricValue.Builder builder() {
      return new ImmutableResourceList.InternalDeviceMetricValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalDeviceMetricValue InternalDeviceMetricValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalDeviceMetricValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_DEVICE_METRIC = 0x1L;
      private long initBits = 0x1L;

      private @Nullable DeviceMetric deviceMetric;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalDeviceMetricValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalDeviceMetricValue instance) {
        Objects.requireNonNull(instance, "instance");
        deviceMetric(instance.deviceMetric());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalDeviceMetricValue#deviceMetric() deviceMetric} attribute.
       * @param deviceMetric The value for deviceMetric 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("deviceMetric")
      public final Builder deviceMetric(DeviceMetric deviceMetric) {
        this.deviceMetric = Objects.requireNonNull(deviceMetric, "deviceMetric");
        initBits &= ~INIT_BIT_DEVICE_METRIC;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalDeviceMetricValue InternalDeviceMetricValue}.
       * @return An immutable instance of InternalDeviceMetricValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalDeviceMetricValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalDeviceMetricValue(deviceMetric);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_DEVICE_METRIC) != 0) attributes.add("deviceMetric");
        return "Cannot build InternalDeviceMetricValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMolecularSequenceValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMolecularSequenceValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMolecularSequenceValue", generator = "Immutables")
  @Immutable
  static final class InternalMolecularSequenceValue
      implements ResourceList.InternalMolecularSequenceValue {
    private final MolecularSequence molecularSequence;

    private InternalMolecularSequenceValue(MolecularSequence molecularSequence) {
      this.molecularSequence = molecularSequence;
    }

    /**
     * @return The value of the {@code molecularSequence} attribute
     */
    @JsonProperty("molecularSequence")
    @JsonValue
    @Override
    public MolecularSequence molecularSequence() {
      return molecularSequence;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMolecularSequenceValue#molecularSequence() molecularSequence} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for molecularSequence
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMolecularSequenceValue withMolecularSequence(MolecularSequence value) {
      if (this.molecularSequence == value) return this;
      MolecularSequence newValue = Objects.requireNonNull(value, "molecularSequence");
      return new ImmutableResourceList.InternalMolecularSequenceValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMolecularSequenceValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMolecularSequenceValue
          && equalTo((ImmutableResourceList.InternalMolecularSequenceValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMolecularSequenceValue another) {
      return molecularSequence.equals(another.molecularSequence);
    }

    /**
     * Computes a hash code from attributes: {@code molecularSequence}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + molecularSequence.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMolecularSequenceValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMolecularSequenceValue{"
          + "molecularSequence=" + molecularSequence
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMolecularSequenceValue fromJson(MolecularSequence jsonValue) {
      ImmutableResourceList.InternalMolecularSequenceValue.Builder builder = ImmutableResourceList.InternalMolecularSequenceValue.builder();
      builder.molecularSequence(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMolecularSequenceValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMolecularSequenceValue instance
     */
    public static ImmutableResourceList.InternalMolecularSequenceValue copyOf(ResourceList.InternalMolecularSequenceValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMolecularSequenceValue) {
        return (ImmutableResourceList.InternalMolecularSequenceValue) instance;
      }
      return ImmutableResourceList.InternalMolecularSequenceValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMolecularSequenceValue InternalMolecularSequenceValue}.
     * <pre>
     * ImmutableResourceList.InternalMolecularSequenceValue.builder()
     *    .molecularSequence(com.fhir.types.fhir.MolecularSequence) // required {@link ResourceList.InternalMolecularSequenceValue#molecularSequence() molecularSequence}
     *    .build();
     * </pre>
     * @return A new InternalMolecularSequenceValue builder
     */
    public static ImmutableResourceList.InternalMolecularSequenceValue.Builder builder() {
      return new ImmutableResourceList.InternalMolecularSequenceValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMolecularSequenceValue InternalMolecularSequenceValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMolecularSequenceValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MOLECULAR_SEQUENCE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MolecularSequence molecularSequence;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMolecularSequenceValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMolecularSequenceValue instance) {
        Objects.requireNonNull(instance, "instance");
        molecularSequence(instance.molecularSequence());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMolecularSequenceValue#molecularSequence() molecularSequence} attribute.
       * @param molecularSequence The value for molecularSequence 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("molecularSequence")
      public final Builder molecularSequence(MolecularSequence molecularSequence) {
        this.molecularSequence = Objects.requireNonNull(molecularSequence, "molecularSequence");
        initBits &= ~INIT_BIT_MOLECULAR_SEQUENCE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMolecularSequenceValue InternalMolecularSequenceValue}.
       * @return An immutable instance of InternalMolecularSequenceValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMolecularSequenceValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMolecularSequenceValue(molecularSequence);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MOLECULAR_SEQUENCE) != 0) attributes.add("molecularSequence");
        return "Cannot build InternalMolecularSequenceValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalImmunizationRecommendationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalImmunizationRecommendationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalImmunizationRecommendationValue", generator = "Immutables")
  @Immutable
  static final class InternalImmunizationRecommendationValue
      implements ResourceList.InternalImmunizationRecommendationValue {
    private final ImmunizationRecommendation immunizationRecommendation;

    private InternalImmunizationRecommendationValue(ImmunizationRecommendation immunizationRecommendation) {
      this.immunizationRecommendation = immunizationRecommendation;
    }

    /**
     * @return The value of the {@code immunizationRecommendation} attribute
     */
    @JsonProperty("immunizationRecommendation")
    @JsonValue
    @Override
    public ImmunizationRecommendation immunizationRecommendation() {
      return immunizationRecommendation;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalImmunizationRecommendationValue#immunizationRecommendation() immunizationRecommendation} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for immunizationRecommendation
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalImmunizationRecommendationValue withImmunizationRecommendation(ImmunizationRecommendation value) {
      if (this.immunizationRecommendation == value) return this;
      ImmunizationRecommendation newValue = Objects.requireNonNull(value, "immunizationRecommendation");
      return new ImmutableResourceList.InternalImmunizationRecommendationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalImmunizationRecommendationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalImmunizationRecommendationValue
          && equalTo((ImmutableResourceList.InternalImmunizationRecommendationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalImmunizationRecommendationValue another) {
      return immunizationRecommendation.equals(another.immunizationRecommendation);
    }

    /**
     * Computes a hash code from attributes: {@code immunizationRecommendation}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + immunizationRecommendation.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalImmunizationRecommendationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalImmunizationRecommendationValue{"
          + "immunizationRecommendation=" + immunizationRecommendation
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalImmunizationRecommendationValue fromJson(ImmunizationRecommendation jsonValue) {
      ImmutableResourceList.InternalImmunizationRecommendationValue.Builder builder = ImmutableResourceList.InternalImmunizationRecommendationValue.builder();
      builder.immunizationRecommendation(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalImmunizationRecommendationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalImmunizationRecommendationValue instance
     */
    public static ImmutableResourceList.InternalImmunizationRecommendationValue copyOf(ResourceList.InternalImmunizationRecommendationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalImmunizationRecommendationValue) {
        return (ImmutableResourceList.InternalImmunizationRecommendationValue) instance;
      }
      return ImmutableResourceList.InternalImmunizationRecommendationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalImmunizationRecommendationValue InternalImmunizationRecommendationValue}.
     * <pre>
     * ImmutableResourceList.InternalImmunizationRecommendationValue.builder()
     *    .immunizationRecommendation(com.fhir.types.fhir.ImmunizationRecommendation) // required {@link ResourceList.InternalImmunizationRecommendationValue#immunizationRecommendation() immunizationRecommendation}
     *    .build();
     * </pre>
     * @return A new InternalImmunizationRecommendationValue builder
     */
    public static ImmutableResourceList.InternalImmunizationRecommendationValue.Builder builder() {
      return new ImmutableResourceList.InternalImmunizationRecommendationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalImmunizationRecommendationValue InternalImmunizationRecommendationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalImmunizationRecommendationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_IMMUNIZATION_RECOMMENDATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ImmunizationRecommendation immunizationRecommendation;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalImmunizationRecommendationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalImmunizationRecommendationValue instance) {
        Objects.requireNonNull(instance, "instance");
        immunizationRecommendation(instance.immunizationRecommendation());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalImmunizationRecommendationValue#immunizationRecommendation() immunizationRecommendation} attribute.
       * @param immunizationRecommendation The value for immunizationRecommendation 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("immunizationRecommendation")
      public final Builder immunizationRecommendation(ImmunizationRecommendation immunizationRecommendation) {
        this.immunizationRecommendation = Objects.requireNonNull(immunizationRecommendation, "immunizationRecommendation");
        initBits &= ~INIT_BIT_IMMUNIZATION_RECOMMENDATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalImmunizationRecommendationValue InternalImmunizationRecommendationValue}.
       * @return An immutable instance of InternalImmunizationRecommendationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalImmunizationRecommendationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalImmunizationRecommendationValue(immunizationRecommendation);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_IMMUNIZATION_RECOMMENDATION) != 0) attributes.add("immunizationRecommendation");
        return "Cannot build InternalImmunizationRecommendationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalParametersValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalParametersValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalParametersValue", generator = "Immutables")
  @Immutable
  static final class InternalParametersValue
      implements ResourceList.InternalParametersValue {
    private final Parameters parameters;

    private InternalParametersValue(Parameters parameters) {
      this.parameters = parameters;
    }

    /**
     * @return The value of the {@code parameters} attribute
     */
    @JsonProperty("parameters")
    @JsonValue
    @Override
    public Parameters parameters() {
      return parameters;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalParametersValue#parameters() parameters} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for parameters
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalParametersValue withParameters(Parameters value) {
      if (this.parameters == value) return this;
      Parameters newValue = Objects.requireNonNull(value, "parameters");
      return new ImmutableResourceList.InternalParametersValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalParametersValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalParametersValue
          && equalTo((ImmutableResourceList.InternalParametersValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalParametersValue another) {
      return parameters.equals(another.parameters);
    }

    /**
     * Computes a hash code from attributes: {@code parameters}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + parameters.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalParametersValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalParametersValue{"
          + "parameters=" + parameters
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalParametersValue fromJson(Parameters jsonValue) {
      ImmutableResourceList.InternalParametersValue.Builder builder = ImmutableResourceList.InternalParametersValue.builder();
      builder.parameters(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalParametersValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalParametersValue instance
     */
    public static ImmutableResourceList.InternalParametersValue copyOf(ResourceList.InternalParametersValue instance) {
      if (instance instanceof ImmutableResourceList.InternalParametersValue) {
        return (ImmutableResourceList.InternalParametersValue) instance;
      }
      return ImmutableResourceList.InternalParametersValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalParametersValue InternalParametersValue}.
     * <pre>
     * ImmutableResourceList.InternalParametersValue.builder()
     *    .parameters(com.fhir.types.fhir.Parameters) // required {@link ResourceList.InternalParametersValue#parameters() parameters}
     *    .build();
     * </pre>
     * @return A new InternalParametersValue builder
     */
    public static ImmutableResourceList.InternalParametersValue.Builder builder() {
      return new ImmutableResourceList.InternalParametersValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalParametersValue InternalParametersValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalParametersValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PARAMETERS = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Parameters parameters;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalParametersValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalParametersValue instance) {
        Objects.requireNonNull(instance, "instance");
        parameters(instance.parameters());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalParametersValue#parameters() parameters} attribute.
       * @param parameters The value for parameters 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("parameters")
      public final Builder parameters(Parameters parameters) {
        this.parameters = Objects.requireNonNull(parameters, "parameters");
        initBits &= ~INIT_BIT_PARAMETERS;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalParametersValue InternalParametersValue}.
       * @return An immutable instance of InternalParametersValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalParametersValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalParametersValue(parameters);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PARAMETERS) != 0) attributes.add("parameters");
        return "Cannot build InternalParametersValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalChargeItemValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalChargeItemValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalChargeItemValue", generator = "Immutables")
  @Immutable
  static final class InternalChargeItemValue
      implements ResourceList.InternalChargeItemValue {
    private final ChargeItem chargeItem;

    private InternalChargeItemValue(ChargeItem chargeItem) {
      this.chargeItem = chargeItem;
    }

    /**
     * @return The value of the {@code chargeItem} attribute
     */
    @JsonProperty("chargeItem")
    @JsonValue
    @Override
    public ChargeItem chargeItem() {
      return chargeItem;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalChargeItemValue#chargeItem() chargeItem} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for chargeItem
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalChargeItemValue withChargeItem(ChargeItem value) {
      if (this.chargeItem == value) return this;
      ChargeItem newValue = Objects.requireNonNull(value, "chargeItem");
      return new ImmutableResourceList.InternalChargeItemValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalChargeItemValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalChargeItemValue
          && equalTo((ImmutableResourceList.InternalChargeItemValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalChargeItemValue another) {
      return chargeItem.equals(another.chargeItem);
    }

    /**
     * Computes a hash code from attributes: {@code chargeItem}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + chargeItem.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalChargeItemValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalChargeItemValue{"
          + "chargeItem=" + chargeItem
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalChargeItemValue fromJson(ChargeItem jsonValue) {
      ImmutableResourceList.InternalChargeItemValue.Builder builder = ImmutableResourceList.InternalChargeItemValue.builder();
      builder.chargeItem(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalChargeItemValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalChargeItemValue instance
     */
    public static ImmutableResourceList.InternalChargeItemValue copyOf(ResourceList.InternalChargeItemValue instance) {
      if (instance instanceof ImmutableResourceList.InternalChargeItemValue) {
        return (ImmutableResourceList.InternalChargeItemValue) instance;
      }
      return ImmutableResourceList.InternalChargeItemValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalChargeItemValue InternalChargeItemValue}.
     * <pre>
     * ImmutableResourceList.InternalChargeItemValue.builder()
     *    .chargeItem(com.fhir.types.fhir.ChargeItem) // required {@link ResourceList.InternalChargeItemValue#chargeItem() chargeItem}
     *    .build();
     * </pre>
     * @return A new InternalChargeItemValue builder
     */
    public static ImmutableResourceList.InternalChargeItemValue.Builder builder() {
      return new ImmutableResourceList.InternalChargeItemValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalChargeItemValue InternalChargeItemValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalChargeItemValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CHARGE_ITEM = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ChargeItem chargeItem;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalChargeItemValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalChargeItemValue instance) {
        Objects.requireNonNull(instance, "instance");
        chargeItem(instance.chargeItem());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalChargeItemValue#chargeItem() chargeItem} attribute.
       * @param chargeItem The value for chargeItem 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("chargeItem")
      public final Builder chargeItem(ChargeItem chargeItem) {
        this.chargeItem = Objects.requireNonNull(chargeItem, "chargeItem");
        initBits &= ~INIT_BIT_CHARGE_ITEM;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalChargeItemValue InternalChargeItemValue}.
       * @return An immutable instance of InternalChargeItemValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalChargeItemValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalChargeItemValue(chargeItem);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CHARGE_ITEM) != 0) attributes.add("chargeItem");
        return "Cannot build InternalChargeItemValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductAuthorizationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductAuthorizationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductAuthorizationValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductAuthorizationValue
      implements ResourceList.InternalMedicinalProductAuthorizationValue {
    private final MedicinalProductAuthorization medicinalProductAuthorization;

    private InternalMedicinalProductAuthorizationValue(MedicinalProductAuthorization medicinalProductAuthorization) {
      this.medicinalProductAuthorization = medicinalProductAuthorization;
    }

    /**
     * @return The value of the {@code medicinalProductAuthorization} attribute
     */
    @JsonProperty("medicinalProductAuthorization")
    @JsonValue
    @Override
    public MedicinalProductAuthorization medicinalProductAuthorization() {
      return medicinalProductAuthorization;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductAuthorizationValue#medicinalProductAuthorization() medicinalProductAuthorization} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProductAuthorization
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductAuthorizationValue withMedicinalProductAuthorization(MedicinalProductAuthorization value) {
      if (this.medicinalProductAuthorization == value) return this;
      MedicinalProductAuthorization newValue = Objects.requireNonNull(value, "medicinalProductAuthorization");
      return new ImmutableResourceList.InternalMedicinalProductAuthorizationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductAuthorizationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductAuthorizationValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductAuthorizationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductAuthorizationValue another) {
      return medicinalProductAuthorization.equals(another.medicinalProductAuthorization);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProductAuthorization}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProductAuthorization.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductAuthorizationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductAuthorizationValue{"
          + "medicinalProductAuthorization=" + medicinalProductAuthorization
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductAuthorizationValue fromJson(MedicinalProductAuthorization jsonValue) {
      ImmutableResourceList.InternalMedicinalProductAuthorizationValue.Builder builder = ImmutableResourceList.InternalMedicinalProductAuthorizationValue.builder();
      builder.medicinalProductAuthorization(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductAuthorizationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductAuthorizationValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductAuthorizationValue copyOf(ResourceList.InternalMedicinalProductAuthorizationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductAuthorizationValue) {
        return (ImmutableResourceList.InternalMedicinalProductAuthorizationValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductAuthorizationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductAuthorizationValue InternalMedicinalProductAuthorizationValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductAuthorizationValue.builder()
     *    .medicinalProductAuthorization(com.fhir.types.fhir.MedicinalProductAuthorization) // required {@link ResourceList.InternalMedicinalProductAuthorizationValue#medicinalProductAuthorization() medicinalProductAuthorization}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductAuthorizationValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductAuthorizationValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductAuthorizationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductAuthorizationValue InternalMedicinalProductAuthorizationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductAuthorizationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT_AUTHORIZATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProductAuthorization medicinalProductAuthorization;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductAuthorizationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductAuthorizationValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProductAuthorization(instance.medicinalProductAuthorization());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductAuthorizationValue#medicinalProductAuthorization() medicinalProductAuthorization} attribute.
       * @param medicinalProductAuthorization The value for medicinalProductAuthorization 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProductAuthorization")
      public final Builder medicinalProductAuthorization(MedicinalProductAuthorization medicinalProductAuthorization) {
        this.medicinalProductAuthorization = Objects.requireNonNull(medicinalProductAuthorization, "medicinalProductAuthorization");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT_AUTHORIZATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductAuthorizationValue InternalMedicinalProductAuthorizationValue}.
       * @return An immutable instance of InternalMedicinalProductAuthorizationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductAuthorizationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductAuthorizationValue(medicinalProductAuthorization);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT_AUTHORIZATION) != 0) attributes.add("medicinalProductAuthorization");
        return "Cannot build InternalMedicinalProductAuthorizationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalOrganizationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalOrganizationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalOrganizationValue", generator = "Immutables")
  @Immutable
  static final class InternalOrganizationValue
      implements ResourceList.InternalOrganizationValue {
    private final Organization organization;

    private InternalOrganizationValue(Organization organization) {
      this.organization = organization;
    }

    /**
     * @return The value of the {@code organization} attribute
     */
    @JsonProperty("organization")
    @JsonValue
    @Override
    public Organization organization() {
      return organization;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalOrganizationValue#organization() organization} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for organization
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalOrganizationValue withOrganization(Organization value) {
      if (this.organization == value) return this;
      Organization newValue = Objects.requireNonNull(value, "organization");
      return new ImmutableResourceList.InternalOrganizationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalOrganizationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalOrganizationValue
          && equalTo((ImmutableResourceList.InternalOrganizationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalOrganizationValue another) {
      return organization.equals(another.organization);
    }

    /**
     * Computes a hash code from attributes: {@code organization}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + organization.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalOrganizationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalOrganizationValue{"
          + "organization=" + organization
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalOrganizationValue fromJson(Organization jsonValue) {
      ImmutableResourceList.InternalOrganizationValue.Builder builder = ImmutableResourceList.InternalOrganizationValue.builder();
      builder.organization(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalOrganizationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalOrganizationValue instance
     */
    public static ImmutableResourceList.InternalOrganizationValue copyOf(ResourceList.InternalOrganizationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalOrganizationValue) {
        return (ImmutableResourceList.InternalOrganizationValue) instance;
      }
      return ImmutableResourceList.InternalOrganizationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalOrganizationValue InternalOrganizationValue}.
     * <pre>
     * ImmutableResourceList.InternalOrganizationValue.builder()
     *    .organization(com.fhir.types.fhir.Organization) // required {@link ResourceList.InternalOrganizationValue#organization() organization}
     *    .build();
     * </pre>
     * @return A new InternalOrganizationValue builder
     */
    public static ImmutableResourceList.InternalOrganizationValue.Builder builder() {
      return new ImmutableResourceList.InternalOrganizationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalOrganizationValue InternalOrganizationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalOrganizationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ORGANIZATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Organization organization;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalOrganizationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalOrganizationValue instance) {
        Objects.requireNonNull(instance, "instance");
        organization(instance.organization());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalOrganizationValue#organization() organization} attribute.
       * @param organization The value for organization 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("organization")
      public final Builder organization(Organization organization) {
        this.organization = Objects.requireNonNull(organization, "organization");
        initBits &= ~INIT_BIT_ORGANIZATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalOrganizationValue InternalOrganizationValue}.
       * @return An immutable instance of InternalOrganizationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalOrganizationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalOrganizationValue(organization);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ORGANIZATION) != 0) attributes.add("organization");
        return "Cannot build InternalOrganizationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalBodyStructureValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalBodyStructureValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalBodyStructureValue", generator = "Immutables")
  @Immutable
  static final class InternalBodyStructureValue
      implements ResourceList.InternalBodyStructureValue {
    private final BodyStructure bodyStructure;

    private InternalBodyStructureValue(BodyStructure bodyStructure) {
      this.bodyStructure = bodyStructure;
    }

    /**
     * @return The value of the {@code bodyStructure} attribute
     */
    @JsonProperty("bodyStructure")
    @JsonValue
    @Override
    public BodyStructure bodyStructure() {
      return bodyStructure;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalBodyStructureValue#bodyStructure() bodyStructure} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for bodyStructure
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalBodyStructureValue withBodyStructure(BodyStructure value) {
      if (this.bodyStructure == value) return this;
      BodyStructure newValue = Objects.requireNonNull(value, "bodyStructure");
      return new ImmutableResourceList.InternalBodyStructureValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalBodyStructureValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalBodyStructureValue
          && equalTo((ImmutableResourceList.InternalBodyStructureValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalBodyStructureValue another) {
      return bodyStructure.equals(another.bodyStructure);
    }

    /**
     * Computes a hash code from attributes: {@code bodyStructure}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + bodyStructure.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalBodyStructureValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalBodyStructureValue{"
          + "bodyStructure=" + bodyStructure
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalBodyStructureValue fromJson(BodyStructure jsonValue) {
      ImmutableResourceList.InternalBodyStructureValue.Builder builder = ImmutableResourceList.InternalBodyStructureValue.builder();
      builder.bodyStructure(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalBodyStructureValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalBodyStructureValue instance
     */
    public static ImmutableResourceList.InternalBodyStructureValue copyOf(ResourceList.InternalBodyStructureValue instance) {
      if (instance instanceof ImmutableResourceList.InternalBodyStructureValue) {
        return (ImmutableResourceList.InternalBodyStructureValue) instance;
      }
      return ImmutableResourceList.InternalBodyStructureValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalBodyStructureValue InternalBodyStructureValue}.
     * <pre>
     * ImmutableResourceList.InternalBodyStructureValue.builder()
     *    .bodyStructure(com.fhir.types.fhir.BodyStructure) // required {@link ResourceList.InternalBodyStructureValue#bodyStructure() bodyStructure}
     *    .build();
     * </pre>
     * @return A new InternalBodyStructureValue builder
     */
    public static ImmutableResourceList.InternalBodyStructureValue.Builder builder() {
      return new ImmutableResourceList.InternalBodyStructureValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalBodyStructureValue InternalBodyStructureValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalBodyStructureValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_BODY_STRUCTURE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable BodyStructure bodyStructure;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalBodyStructureValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalBodyStructureValue instance) {
        Objects.requireNonNull(instance, "instance");
        bodyStructure(instance.bodyStructure());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalBodyStructureValue#bodyStructure() bodyStructure} attribute.
       * @param bodyStructure The value for bodyStructure 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("bodyStructure")
      public final Builder bodyStructure(BodyStructure bodyStructure) {
        this.bodyStructure = Objects.requireNonNull(bodyStructure, "bodyStructure");
        initBits &= ~INIT_BIT_BODY_STRUCTURE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalBodyStructureValue InternalBodyStructureValue}.
       * @return An immutable instance of InternalBodyStructureValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalBodyStructureValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalBodyStructureValue(bodyStructure);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_BODY_STRUCTURE) != 0) attributes.add("bodyStructure");
        return "Cannot build InternalBodyStructureValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalContractValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalContractValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalContractValue", generator = "Immutables")
  @Immutable
  static final class InternalContractValue implements ResourceList.InternalContractValue {
    private final Contract contract;

    private InternalContractValue(Contract contract) {
      this.contract = contract;
    }

    /**
     * @return The value of the {@code contract} attribute
     */
    @JsonProperty("contract")
    @JsonValue
    @Override
    public Contract contract() {
      return contract;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalContractValue#contract() contract} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for contract
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalContractValue withContract(Contract value) {
      if (this.contract == value) return this;
      Contract newValue = Objects.requireNonNull(value, "contract");
      return new ImmutableResourceList.InternalContractValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalContractValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalContractValue
          && equalTo((ImmutableResourceList.InternalContractValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalContractValue another) {
      return contract.equals(another.contract);
    }

    /**
     * Computes a hash code from attributes: {@code contract}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + contract.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalContractValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalContractValue{"
          + "contract=" + contract
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalContractValue fromJson(Contract jsonValue) {
      ImmutableResourceList.InternalContractValue.Builder builder = ImmutableResourceList.InternalContractValue.builder();
      builder.contract(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalContractValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalContractValue instance
     */
    public static ImmutableResourceList.InternalContractValue copyOf(ResourceList.InternalContractValue instance) {
      if (instance instanceof ImmutableResourceList.InternalContractValue) {
        return (ImmutableResourceList.InternalContractValue) instance;
      }
      return ImmutableResourceList.InternalContractValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalContractValue InternalContractValue}.
     * <pre>
     * ImmutableResourceList.InternalContractValue.builder()
     *    .contract(com.fhir.types.fhir.Contract) // required {@link ResourceList.InternalContractValue#contract() contract}
     *    .build();
     * </pre>
     * @return A new InternalContractValue builder
     */
    public static ImmutableResourceList.InternalContractValue.Builder builder() {
      return new ImmutableResourceList.InternalContractValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalContractValue InternalContractValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalContractValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CONTRACT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Contract contract;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalContractValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalContractValue instance) {
        Objects.requireNonNull(instance, "instance");
        contract(instance.contract());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalContractValue#contract() contract} attribute.
       * @param contract The value for contract 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("contract")
      public final Builder contract(Contract contract) {
        this.contract = Objects.requireNonNull(contract, "contract");
        initBits &= ~INIT_BIT_CONTRACT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalContractValue InternalContractValue}.
       * @return An immutable instance of InternalContractValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalContractValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalContractValue(contract);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CONTRACT) != 0) attributes.add("contract");
        return "Cannot build InternalContractValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicationDispenseValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicationDispenseValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicationDispenseValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicationDispenseValue
      implements ResourceList.InternalMedicationDispenseValue {
    private final MedicationDispense medicationDispense;

    private InternalMedicationDispenseValue(MedicationDispense medicationDispense) {
      this.medicationDispense = medicationDispense;
    }

    /**
     * @return The value of the {@code medicationDispense} attribute
     */
    @JsonProperty("medicationDispense")
    @JsonValue
    @Override
    public MedicationDispense medicationDispense() {
      return medicationDispense;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicationDispenseValue#medicationDispense() medicationDispense} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicationDispense
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicationDispenseValue withMedicationDispense(MedicationDispense value) {
      if (this.medicationDispense == value) return this;
      MedicationDispense newValue = Objects.requireNonNull(value, "medicationDispense");
      return new ImmutableResourceList.InternalMedicationDispenseValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicationDispenseValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicationDispenseValue
          && equalTo((ImmutableResourceList.InternalMedicationDispenseValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicationDispenseValue another) {
      return medicationDispense.equals(another.medicationDispense);
    }

    /**
     * Computes a hash code from attributes: {@code medicationDispense}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicationDispense.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicationDispenseValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicationDispenseValue{"
          + "medicationDispense=" + medicationDispense
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicationDispenseValue fromJson(MedicationDispense jsonValue) {
      ImmutableResourceList.InternalMedicationDispenseValue.Builder builder = ImmutableResourceList.InternalMedicationDispenseValue.builder();
      builder.medicationDispense(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicationDispenseValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicationDispenseValue instance
     */
    public static ImmutableResourceList.InternalMedicationDispenseValue copyOf(ResourceList.InternalMedicationDispenseValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicationDispenseValue) {
        return (ImmutableResourceList.InternalMedicationDispenseValue) instance;
      }
      return ImmutableResourceList.InternalMedicationDispenseValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicationDispenseValue InternalMedicationDispenseValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicationDispenseValue.builder()
     *    .medicationDispense(com.fhir.types.fhir.MedicationDispense) // required {@link ResourceList.InternalMedicationDispenseValue#medicationDispense() medicationDispense}
     *    .build();
     * </pre>
     * @return A new InternalMedicationDispenseValue builder
     */
    public static ImmutableResourceList.InternalMedicationDispenseValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicationDispenseValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicationDispenseValue InternalMedicationDispenseValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicationDispenseValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICATION_DISPENSE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicationDispense medicationDispense;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicationDispenseValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicationDispenseValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicationDispense(instance.medicationDispense());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicationDispenseValue#medicationDispense() medicationDispense} attribute.
       * @param medicationDispense The value for medicationDispense 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicationDispense")
      public final Builder medicationDispense(MedicationDispense medicationDispense) {
        this.medicationDispense = Objects.requireNonNull(medicationDispense, "medicationDispense");
        initBits &= ~INIT_BIT_MEDICATION_DISPENSE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicationDispenseValue InternalMedicationDispenseValue}.
       * @return An immutable instance of InternalMedicationDispenseValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicationDispenseValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicationDispenseValue(medicationDispense);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICATION_DISPENSE) != 0) attributes.add("medicationDispense");
        return "Cannot build InternalMedicationDispenseValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalRiskAssessmentValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalRiskAssessmentValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalRiskAssessmentValue", generator = "Immutables")
  @Immutable
  static final class InternalRiskAssessmentValue
      implements ResourceList.InternalRiskAssessmentValue {
    private final RiskAssessment riskAssessment;

    private InternalRiskAssessmentValue(RiskAssessment riskAssessment) {
      this.riskAssessment = riskAssessment;
    }

    /**
     * @return The value of the {@code riskAssessment} attribute
     */
    @JsonProperty("riskAssessment")
    @JsonValue
    @Override
    public RiskAssessment riskAssessment() {
      return riskAssessment;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalRiskAssessmentValue#riskAssessment() riskAssessment} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for riskAssessment
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalRiskAssessmentValue withRiskAssessment(RiskAssessment value) {
      if (this.riskAssessment == value) return this;
      RiskAssessment newValue = Objects.requireNonNull(value, "riskAssessment");
      return new ImmutableResourceList.InternalRiskAssessmentValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalRiskAssessmentValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalRiskAssessmentValue
          && equalTo((ImmutableResourceList.InternalRiskAssessmentValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalRiskAssessmentValue another) {
      return riskAssessment.equals(another.riskAssessment);
    }

    /**
     * Computes a hash code from attributes: {@code riskAssessment}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + riskAssessment.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalRiskAssessmentValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalRiskAssessmentValue{"
          + "riskAssessment=" + riskAssessment
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalRiskAssessmentValue fromJson(RiskAssessment jsonValue) {
      ImmutableResourceList.InternalRiskAssessmentValue.Builder builder = ImmutableResourceList.InternalRiskAssessmentValue.builder();
      builder.riskAssessment(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalRiskAssessmentValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalRiskAssessmentValue instance
     */
    public static ImmutableResourceList.InternalRiskAssessmentValue copyOf(ResourceList.InternalRiskAssessmentValue instance) {
      if (instance instanceof ImmutableResourceList.InternalRiskAssessmentValue) {
        return (ImmutableResourceList.InternalRiskAssessmentValue) instance;
      }
      return ImmutableResourceList.InternalRiskAssessmentValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalRiskAssessmentValue InternalRiskAssessmentValue}.
     * <pre>
     * ImmutableResourceList.InternalRiskAssessmentValue.builder()
     *    .riskAssessment(com.fhir.types.fhir.RiskAssessment) // required {@link ResourceList.InternalRiskAssessmentValue#riskAssessment() riskAssessment}
     *    .build();
     * </pre>
     * @return A new InternalRiskAssessmentValue builder
     */
    public static ImmutableResourceList.InternalRiskAssessmentValue.Builder builder() {
      return new ImmutableResourceList.InternalRiskAssessmentValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalRiskAssessmentValue InternalRiskAssessmentValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalRiskAssessmentValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_RISK_ASSESSMENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable RiskAssessment riskAssessment;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalRiskAssessmentValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalRiskAssessmentValue instance) {
        Objects.requireNonNull(instance, "instance");
        riskAssessment(instance.riskAssessment());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalRiskAssessmentValue#riskAssessment() riskAssessment} attribute.
       * @param riskAssessment The value for riskAssessment 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("riskAssessment")
      public final Builder riskAssessment(RiskAssessment riskAssessment) {
        this.riskAssessment = Objects.requireNonNull(riskAssessment, "riskAssessment");
        initBits &= ~INIT_BIT_RISK_ASSESSMENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalRiskAssessmentValue InternalRiskAssessmentValue}.
       * @return An immutable instance of InternalRiskAssessmentValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalRiskAssessmentValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalRiskAssessmentValue(riskAssessment);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_RISK_ASSESSMENT) != 0) attributes.add("riskAssessment");
        return "Cannot build InternalRiskAssessmentValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalAppointmentValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalAppointmentValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalAppointmentValue", generator = "Immutables")
  @Immutable
  static final class InternalAppointmentValue
      implements ResourceList.InternalAppointmentValue {
    private final Appointment appointment;

    private InternalAppointmentValue(Appointment appointment) {
      this.appointment = appointment;
    }

    /**
     * @return The value of the {@code appointment} attribute
     */
    @JsonProperty("appointment")
    @JsonValue
    @Override
    public Appointment appointment() {
      return appointment;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalAppointmentValue#appointment() appointment} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for appointment
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalAppointmentValue withAppointment(Appointment value) {
      if (this.appointment == value) return this;
      Appointment newValue = Objects.requireNonNull(value, "appointment");
      return new ImmutableResourceList.InternalAppointmentValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalAppointmentValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalAppointmentValue
          && equalTo((ImmutableResourceList.InternalAppointmentValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalAppointmentValue another) {
      return appointment.equals(another.appointment);
    }

    /**
     * Computes a hash code from attributes: {@code appointment}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + appointment.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalAppointmentValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalAppointmentValue{"
          + "appointment=" + appointment
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalAppointmentValue fromJson(Appointment jsonValue) {
      ImmutableResourceList.InternalAppointmentValue.Builder builder = ImmutableResourceList.InternalAppointmentValue.builder();
      builder.appointment(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalAppointmentValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalAppointmentValue instance
     */
    public static ImmutableResourceList.InternalAppointmentValue copyOf(ResourceList.InternalAppointmentValue instance) {
      if (instance instanceof ImmutableResourceList.InternalAppointmentValue) {
        return (ImmutableResourceList.InternalAppointmentValue) instance;
      }
      return ImmutableResourceList.InternalAppointmentValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalAppointmentValue InternalAppointmentValue}.
     * <pre>
     * ImmutableResourceList.InternalAppointmentValue.builder()
     *    .appointment(com.fhir.types.fhir.Appointment) // required {@link ResourceList.InternalAppointmentValue#appointment() appointment}
     *    .build();
     * </pre>
     * @return A new InternalAppointmentValue builder
     */
    public static ImmutableResourceList.InternalAppointmentValue.Builder builder() {
      return new ImmutableResourceList.InternalAppointmentValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalAppointmentValue InternalAppointmentValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalAppointmentValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_APPOINTMENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Appointment appointment;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalAppointmentValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalAppointmentValue instance) {
        Objects.requireNonNull(instance, "instance");
        appointment(instance.appointment());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalAppointmentValue#appointment() appointment} attribute.
       * @param appointment The value for appointment 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("appointment")
      public final Builder appointment(Appointment appointment) {
        this.appointment = Objects.requireNonNull(appointment, "appointment");
        initBits &= ~INIT_BIT_APPOINTMENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalAppointmentValue InternalAppointmentValue}.
       * @return An immutable instance of InternalAppointmentValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalAppointmentValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalAppointmentValue(appointment);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_APPOINTMENT) != 0) attributes.add("appointment");
        return "Cannot build InternalAppointmentValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalListValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalListValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalListValue", generator = "Immutables")
  @Immutable
  static final class InternalListValue implements ResourceList.InternalListValue {
    private final com.fhir.types.fhir.List list;

    private InternalListValue(com.fhir.types.fhir.List list) {
      this.list = list;
    }

    /**
     * @return The value of the {@code list} attribute
     */
    @JsonProperty("list")
    @JsonValue
    @Override
    public com.fhir.types.fhir.List list() {
      return list;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalListValue#list() list} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for list
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalListValue withList(com.fhir.types.fhir.List value) {
      if (this.list == value) return this;
      com.fhir.types.fhir.List newValue = Objects.requireNonNull(value, "list");
      return new ImmutableResourceList.InternalListValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalListValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalListValue
          && equalTo((ImmutableResourceList.InternalListValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalListValue another) {
      return list.equals(another.list);
    }

    /**
     * Computes a hash code from attributes: {@code list}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + list.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalListValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalListValue{"
          + "list=" + list
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalListValue fromJson(com.fhir.types.fhir.List jsonValue) {
      ImmutableResourceList.InternalListValue.Builder builder = ImmutableResourceList.InternalListValue.builder();
      builder.list(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalListValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalListValue instance
     */
    public static ImmutableResourceList.InternalListValue copyOf(ResourceList.InternalListValue instance) {
      if (instance instanceof ImmutableResourceList.InternalListValue) {
        return (ImmutableResourceList.InternalListValue) instance;
      }
      return ImmutableResourceList.InternalListValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalListValue InternalListValue}.
     * <pre>
     * ImmutableResourceList.InternalListValue.builder()
     *    .list(com.fhir.types.fhir.List) // required {@link ResourceList.InternalListValue#list() list}
     *    .build();
     * </pre>
     * @return A new InternalListValue builder
     */
    public static ImmutableResourceList.InternalListValue.Builder builder() {
      return new ImmutableResourceList.InternalListValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalListValue InternalListValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalListValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_LIST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable com.fhir.types.fhir.List list;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalListValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalListValue instance) {
        Objects.requireNonNull(instance, "instance");
        list(instance.list());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalListValue#list() list} attribute.
       * @param list The value for list 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("list")
      public final Builder list(com.fhir.types.fhir.List list) {
        this.list = Objects.requireNonNull(list, "list");
        initBits &= ~INIT_BIT_LIST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalListValue InternalListValue}.
       * @return An immutable instance of InternalListValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalListValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalListValue(list);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_LIST) != 0) attributes.add("list");
        return "Cannot build InternalListValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalExampleScenarioValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalExampleScenarioValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalExampleScenarioValue", generator = "Immutables")
  @Immutable
  static final class InternalExampleScenarioValue
      implements ResourceList.InternalExampleScenarioValue {
    private final ExampleScenario exampleScenario;

    private InternalExampleScenarioValue(ExampleScenario exampleScenario) {
      this.exampleScenario = exampleScenario;
    }

    /**
     * @return The value of the {@code exampleScenario} attribute
     */
    @JsonProperty("exampleScenario")
    @JsonValue
    @Override
    public ExampleScenario exampleScenario() {
      return exampleScenario;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalExampleScenarioValue#exampleScenario() exampleScenario} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for exampleScenario
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalExampleScenarioValue withExampleScenario(ExampleScenario value) {
      if (this.exampleScenario == value) return this;
      ExampleScenario newValue = Objects.requireNonNull(value, "exampleScenario");
      return new ImmutableResourceList.InternalExampleScenarioValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalExampleScenarioValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalExampleScenarioValue
          && equalTo((ImmutableResourceList.InternalExampleScenarioValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalExampleScenarioValue another) {
      return exampleScenario.equals(another.exampleScenario);
    }

    /**
     * Computes a hash code from attributes: {@code exampleScenario}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + exampleScenario.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalExampleScenarioValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalExampleScenarioValue{"
          + "exampleScenario=" + exampleScenario
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalExampleScenarioValue fromJson(ExampleScenario jsonValue) {
      ImmutableResourceList.InternalExampleScenarioValue.Builder builder = ImmutableResourceList.InternalExampleScenarioValue.builder();
      builder.exampleScenario(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalExampleScenarioValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalExampleScenarioValue instance
     */
    public static ImmutableResourceList.InternalExampleScenarioValue copyOf(ResourceList.InternalExampleScenarioValue instance) {
      if (instance instanceof ImmutableResourceList.InternalExampleScenarioValue) {
        return (ImmutableResourceList.InternalExampleScenarioValue) instance;
      }
      return ImmutableResourceList.InternalExampleScenarioValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalExampleScenarioValue InternalExampleScenarioValue}.
     * <pre>
     * ImmutableResourceList.InternalExampleScenarioValue.builder()
     *    .exampleScenario(com.fhir.types.fhir.ExampleScenario) // required {@link ResourceList.InternalExampleScenarioValue#exampleScenario() exampleScenario}
     *    .build();
     * </pre>
     * @return A new InternalExampleScenarioValue builder
     */
    public static ImmutableResourceList.InternalExampleScenarioValue.Builder builder() {
      return new ImmutableResourceList.InternalExampleScenarioValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalExampleScenarioValue InternalExampleScenarioValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalExampleScenarioValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_EXAMPLE_SCENARIO = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ExampleScenario exampleScenario;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalExampleScenarioValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalExampleScenarioValue instance) {
        Objects.requireNonNull(instance, "instance");
        exampleScenario(instance.exampleScenario());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalExampleScenarioValue#exampleScenario() exampleScenario} attribute.
       * @param exampleScenario The value for exampleScenario 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("exampleScenario")
      public final Builder exampleScenario(ExampleScenario exampleScenario) {
        this.exampleScenario = Objects.requireNonNull(exampleScenario, "exampleScenario");
        initBits &= ~INIT_BIT_EXAMPLE_SCENARIO;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalExampleScenarioValue InternalExampleScenarioValue}.
       * @return An immutable instance of InternalExampleScenarioValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalExampleScenarioValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalExampleScenarioValue(exampleScenario);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_EXAMPLE_SCENARIO) != 0) attributes.add("exampleScenario");
        return "Cannot build InternalExampleScenarioValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSupplyDeliveryValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSupplyDeliveryValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSupplyDeliveryValue", generator = "Immutables")
  @Immutable
  static final class InternalSupplyDeliveryValue
      implements ResourceList.InternalSupplyDeliveryValue {
    private final SupplyDelivery supplyDelivery;

    private InternalSupplyDeliveryValue(SupplyDelivery supplyDelivery) {
      this.supplyDelivery = supplyDelivery;
    }

    /**
     * @return The value of the {@code supplyDelivery} attribute
     */
    @JsonProperty("supplyDelivery")
    @JsonValue
    @Override
    public SupplyDelivery supplyDelivery() {
      return supplyDelivery;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSupplyDeliveryValue#supplyDelivery() supplyDelivery} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for supplyDelivery
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSupplyDeliveryValue withSupplyDelivery(SupplyDelivery value) {
      if (this.supplyDelivery == value) return this;
      SupplyDelivery newValue = Objects.requireNonNull(value, "supplyDelivery");
      return new ImmutableResourceList.InternalSupplyDeliveryValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSupplyDeliveryValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSupplyDeliveryValue
          && equalTo((ImmutableResourceList.InternalSupplyDeliveryValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSupplyDeliveryValue another) {
      return supplyDelivery.equals(another.supplyDelivery);
    }

    /**
     * Computes a hash code from attributes: {@code supplyDelivery}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + supplyDelivery.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSupplyDeliveryValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSupplyDeliveryValue{"
          + "supplyDelivery=" + supplyDelivery
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSupplyDeliveryValue fromJson(SupplyDelivery jsonValue) {
      ImmutableResourceList.InternalSupplyDeliveryValue.Builder builder = ImmutableResourceList.InternalSupplyDeliveryValue.builder();
      builder.supplyDelivery(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSupplyDeliveryValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSupplyDeliveryValue instance
     */
    public static ImmutableResourceList.InternalSupplyDeliveryValue copyOf(ResourceList.InternalSupplyDeliveryValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSupplyDeliveryValue) {
        return (ImmutableResourceList.InternalSupplyDeliveryValue) instance;
      }
      return ImmutableResourceList.InternalSupplyDeliveryValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSupplyDeliveryValue InternalSupplyDeliveryValue}.
     * <pre>
     * ImmutableResourceList.InternalSupplyDeliveryValue.builder()
     *    .supplyDelivery(com.fhir.types.fhir.SupplyDelivery) // required {@link ResourceList.InternalSupplyDeliveryValue#supplyDelivery() supplyDelivery}
     *    .build();
     * </pre>
     * @return A new InternalSupplyDeliveryValue builder
     */
    public static ImmutableResourceList.InternalSupplyDeliveryValue.Builder builder() {
      return new ImmutableResourceList.InternalSupplyDeliveryValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSupplyDeliveryValue InternalSupplyDeliveryValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSupplyDeliveryValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUPPLY_DELIVERY = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SupplyDelivery supplyDelivery;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSupplyDeliveryValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSupplyDeliveryValue instance) {
        Objects.requireNonNull(instance, "instance");
        supplyDelivery(instance.supplyDelivery());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSupplyDeliveryValue#supplyDelivery() supplyDelivery} attribute.
       * @param supplyDelivery The value for supplyDelivery 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("supplyDelivery")
      public final Builder supplyDelivery(SupplyDelivery supplyDelivery) {
        this.supplyDelivery = Objects.requireNonNull(supplyDelivery, "supplyDelivery");
        initBits &= ~INIT_BIT_SUPPLY_DELIVERY;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSupplyDeliveryValue InternalSupplyDeliveryValue}.
       * @return An immutable instance of InternalSupplyDeliveryValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSupplyDeliveryValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSupplyDeliveryValue(supplyDelivery);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUPPLY_DELIVERY) != 0) attributes.add("supplyDelivery");
        return "Cannot build InternalSupplyDeliveryValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalFamilyMemberHistoryValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalFamilyMemberHistoryValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalFamilyMemberHistoryValue", generator = "Immutables")
  @Immutable
  static final class InternalFamilyMemberHistoryValue
      implements ResourceList.InternalFamilyMemberHistoryValue {
    private final FamilyMemberHistory familyMemberHistory;

    private InternalFamilyMemberHistoryValue(FamilyMemberHistory familyMemberHistory) {
      this.familyMemberHistory = familyMemberHistory;
    }

    /**
     * @return The value of the {@code familyMemberHistory} attribute
     */
    @JsonProperty("familyMemberHistory")
    @JsonValue
    @Override
    public FamilyMemberHistory familyMemberHistory() {
      return familyMemberHistory;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalFamilyMemberHistoryValue#familyMemberHistory() familyMemberHistory} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for familyMemberHistory
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalFamilyMemberHistoryValue withFamilyMemberHistory(FamilyMemberHistory value) {
      if (this.familyMemberHistory == value) return this;
      FamilyMemberHistory newValue = Objects.requireNonNull(value, "familyMemberHistory");
      return new ImmutableResourceList.InternalFamilyMemberHistoryValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalFamilyMemberHistoryValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalFamilyMemberHistoryValue
          && equalTo((ImmutableResourceList.InternalFamilyMemberHistoryValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalFamilyMemberHistoryValue another) {
      return familyMemberHistory.equals(another.familyMemberHistory);
    }

    /**
     * Computes a hash code from attributes: {@code familyMemberHistory}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + familyMemberHistory.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalFamilyMemberHistoryValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalFamilyMemberHistoryValue{"
          + "familyMemberHistory=" + familyMemberHistory
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalFamilyMemberHistoryValue fromJson(FamilyMemberHistory jsonValue) {
      ImmutableResourceList.InternalFamilyMemberHistoryValue.Builder builder = ImmutableResourceList.InternalFamilyMemberHistoryValue.builder();
      builder.familyMemberHistory(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalFamilyMemberHistoryValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalFamilyMemberHistoryValue instance
     */
    public static ImmutableResourceList.InternalFamilyMemberHistoryValue copyOf(ResourceList.InternalFamilyMemberHistoryValue instance) {
      if (instance instanceof ImmutableResourceList.InternalFamilyMemberHistoryValue) {
        return (ImmutableResourceList.InternalFamilyMemberHistoryValue) instance;
      }
      return ImmutableResourceList.InternalFamilyMemberHistoryValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalFamilyMemberHistoryValue InternalFamilyMemberHistoryValue}.
     * <pre>
     * ImmutableResourceList.InternalFamilyMemberHistoryValue.builder()
     *    .familyMemberHistory(com.fhir.types.fhir.FamilyMemberHistory) // required {@link ResourceList.InternalFamilyMemberHistoryValue#familyMemberHistory() familyMemberHistory}
     *    .build();
     * </pre>
     * @return A new InternalFamilyMemberHistoryValue builder
     */
    public static ImmutableResourceList.InternalFamilyMemberHistoryValue.Builder builder() {
      return new ImmutableResourceList.InternalFamilyMemberHistoryValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalFamilyMemberHistoryValue InternalFamilyMemberHistoryValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalFamilyMemberHistoryValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_FAMILY_MEMBER_HISTORY = 0x1L;
      private long initBits = 0x1L;

      private @Nullable FamilyMemberHistory familyMemberHistory;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalFamilyMemberHistoryValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalFamilyMemberHistoryValue instance) {
        Objects.requireNonNull(instance, "instance");
        familyMemberHistory(instance.familyMemberHistory());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalFamilyMemberHistoryValue#familyMemberHistory() familyMemberHistory} attribute.
       * @param familyMemberHistory The value for familyMemberHistory 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("familyMemberHistory")
      public final Builder familyMemberHistory(FamilyMemberHistory familyMemberHistory) {
        this.familyMemberHistory = Objects.requireNonNull(familyMemberHistory, "familyMemberHistory");
        initBits &= ~INIT_BIT_FAMILY_MEMBER_HISTORY;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalFamilyMemberHistoryValue InternalFamilyMemberHistoryValue}.
       * @return An immutable instance of InternalFamilyMemberHistoryValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalFamilyMemberHistoryValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalFamilyMemberHistoryValue(familyMemberHistory);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_FAMILY_MEMBER_HISTORY) != 0) attributes.add("familyMemberHistory");
        return "Cannot build InternalFamilyMemberHistoryValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalProcedureValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalProcedureValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalProcedureValue", generator = "Immutables")
  @Immutable
  static final class InternalProcedureValue implements ResourceList.InternalProcedureValue {
    private final Procedure procedure;

    private InternalProcedureValue(Procedure procedure) {
      this.procedure = procedure;
    }

    /**
     * @return The value of the {@code procedure} attribute
     */
    @JsonProperty("procedure")
    @JsonValue
    @Override
    public Procedure procedure() {
      return procedure;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalProcedureValue#procedure() procedure} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for procedure
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalProcedureValue withProcedure(Procedure value) {
      if (this.procedure == value) return this;
      Procedure newValue = Objects.requireNonNull(value, "procedure");
      return new ImmutableResourceList.InternalProcedureValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalProcedureValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalProcedureValue
          && equalTo((ImmutableResourceList.InternalProcedureValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalProcedureValue another) {
      return procedure.equals(another.procedure);
    }

    /**
     * Computes a hash code from attributes: {@code procedure}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + procedure.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalProcedureValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalProcedureValue{"
          + "procedure=" + procedure
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalProcedureValue fromJson(Procedure jsonValue) {
      ImmutableResourceList.InternalProcedureValue.Builder builder = ImmutableResourceList.InternalProcedureValue.builder();
      builder.procedure(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalProcedureValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalProcedureValue instance
     */
    public static ImmutableResourceList.InternalProcedureValue copyOf(ResourceList.InternalProcedureValue instance) {
      if (instance instanceof ImmutableResourceList.InternalProcedureValue) {
        return (ImmutableResourceList.InternalProcedureValue) instance;
      }
      return ImmutableResourceList.InternalProcedureValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalProcedureValue InternalProcedureValue}.
     * <pre>
     * ImmutableResourceList.InternalProcedureValue.builder()
     *    .procedure(com.fhir.types.fhir.Procedure) // required {@link ResourceList.InternalProcedureValue#procedure() procedure}
     *    .build();
     * </pre>
     * @return A new InternalProcedureValue builder
     */
    public static ImmutableResourceList.InternalProcedureValue.Builder builder() {
      return new ImmutableResourceList.InternalProcedureValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalProcedureValue InternalProcedureValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalProcedureValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PROCEDURE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Procedure procedure;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalProcedureValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalProcedureValue instance) {
        Objects.requireNonNull(instance, "instance");
        procedure(instance.procedure());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalProcedureValue#procedure() procedure} attribute.
       * @param procedure The value for procedure 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("procedure")
      public final Builder procedure(Procedure procedure) {
        this.procedure = Objects.requireNonNull(procedure, "procedure");
        initBits &= ~INIT_BIT_PROCEDURE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalProcedureValue InternalProcedureValue}.
       * @return An immutable instance of InternalProcedureValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalProcedureValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalProcedureValue(procedure);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PROCEDURE) != 0) attributes.add("procedure");
        return "Cannot build InternalProcedureValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalDocumentManifestValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalDocumentManifestValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalDocumentManifestValue", generator = "Immutables")
  @Immutable
  static final class InternalDocumentManifestValue
      implements ResourceList.InternalDocumentManifestValue {
    private final DocumentManifest documentManifest;

    private InternalDocumentManifestValue(DocumentManifest documentManifest) {
      this.documentManifest = documentManifest;
    }

    /**
     * @return The value of the {@code documentManifest} attribute
     */
    @JsonProperty("documentManifest")
    @JsonValue
    @Override
    public DocumentManifest documentManifest() {
      return documentManifest;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalDocumentManifestValue#documentManifest() documentManifest} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for documentManifest
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalDocumentManifestValue withDocumentManifest(DocumentManifest value) {
      if (this.documentManifest == value) return this;
      DocumentManifest newValue = Objects.requireNonNull(value, "documentManifest");
      return new ImmutableResourceList.InternalDocumentManifestValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalDocumentManifestValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalDocumentManifestValue
          && equalTo((ImmutableResourceList.InternalDocumentManifestValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalDocumentManifestValue another) {
      return documentManifest.equals(another.documentManifest);
    }

    /**
     * Computes a hash code from attributes: {@code documentManifest}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + documentManifest.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalDocumentManifestValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalDocumentManifestValue{"
          + "documentManifest=" + documentManifest
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalDocumentManifestValue fromJson(DocumentManifest jsonValue) {
      ImmutableResourceList.InternalDocumentManifestValue.Builder builder = ImmutableResourceList.InternalDocumentManifestValue.builder();
      builder.documentManifest(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalDocumentManifestValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalDocumentManifestValue instance
     */
    public static ImmutableResourceList.InternalDocumentManifestValue copyOf(ResourceList.InternalDocumentManifestValue instance) {
      if (instance instanceof ImmutableResourceList.InternalDocumentManifestValue) {
        return (ImmutableResourceList.InternalDocumentManifestValue) instance;
      }
      return ImmutableResourceList.InternalDocumentManifestValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalDocumentManifestValue InternalDocumentManifestValue}.
     * <pre>
     * ImmutableResourceList.InternalDocumentManifestValue.builder()
     *    .documentManifest(com.fhir.types.fhir.DocumentManifest) // required {@link ResourceList.InternalDocumentManifestValue#documentManifest() documentManifest}
     *    .build();
     * </pre>
     * @return A new InternalDocumentManifestValue builder
     */
    public static ImmutableResourceList.InternalDocumentManifestValue.Builder builder() {
      return new ImmutableResourceList.InternalDocumentManifestValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalDocumentManifestValue InternalDocumentManifestValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalDocumentManifestValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_DOCUMENT_MANIFEST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable DocumentManifest documentManifest;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalDocumentManifestValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalDocumentManifestValue instance) {
        Objects.requireNonNull(instance, "instance");
        documentManifest(instance.documentManifest());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalDocumentManifestValue#documentManifest() documentManifest} attribute.
       * @param documentManifest The value for documentManifest 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("documentManifest")
      public final Builder documentManifest(DocumentManifest documentManifest) {
        this.documentManifest = Objects.requireNonNull(documentManifest, "documentManifest");
        initBits &= ~INIT_BIT_DOCUMENT_MANIFEST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalDocumentManifestValue InternalDocumentManifestValue}.
       * @return An immutable instance of InternalDocumentManifestValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalDocumentManifestValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalDocumentManifestValue(documentManifest);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_DOCUMENT_MANIFEST) != 0) attributes.add("documentManifest");
        return "Cannot build InternalDocumentManifestValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicationStatementValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicationStatementValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicationStatementValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicationStatementValue
      implements ResourceList.InternalMedicationStatementValue {
    private final MedicationStatement medicationStatement;

    private InternalMedicationStatementValue(MedicationStatement medicationStatement) {
      this.medicationStatement = medicationStatement;
    }

    /**
     * @return The value of the {@code medicationStatement} attribute
     */
    @JsonProperty("medicationStatement")
    @JsonValue
    @Override
    public MedicationStatement medicationStatement() {
      return medicationStatement;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicationStatementValue#medicationStatement() medicationStatement} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicationStatement
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicationStatementValue withMedicationStatement(MedicationStatement value) {
      if (this.medicationStatement == value) return this;
      MedicationStatement newValue = Objects.requireNonNull(value, "medicationStatement");
      return new ImmutableResourceList.InternalMedicationStatementValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicationStatementValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicationStatementValue
          && equalTo((ImmutableResourceList.InternalMedicationStatementValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicationStatementValue another) {
      return medicationStatement.equals(another.medicationStatement);
    }

    /**
     * Computes a hash code from attributes: {@code medicationStatement}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicationStatement.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicationStatementValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicationStatementValue{"
          + "medicationStatement=" + medicationStatement
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicationStatementValue fromJson(MedicationStatement jsonValue) {
      ImmutableResourceList.InternalMedicationStatementValue.Builder builder = ImmutableResourceList.InternalMedicationStatementValue.builder();
      builder.medicationStatement(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicationStatementValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicationStatementValue instance
     */
    public static ImmutableResourceList.InternalMedicationStatementValue copyOf(ResourceList.InternalMedicationStatementValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicationStatementValue) {
        return (ImmutableResourceList.InternalMedicationStatementValue) instance;
      }
      return ImmutableResourceList.InternalMedicationStatementValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicationStatementValue InternalMedicationStatementValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicationStatementValue.builder()
     *    .medicationStatement(com.fhir.types.fhir.MedicationStatement) // required {@link ResourceList.InternalMedicationStatementValue#medicationStatement() medicationStatement}
     *    .build();
     * </pre>
     * @return A new InternalMedicationStatementValue builder
     */
    public static ImmutableResourceList.InternalMedicationStatementValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicationStatementValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicationStatementValue InternalMedicationStatementValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicationStatementValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICATION_STATEMENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicationStatement medicationStatement;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicationStatementValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicationStatementValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicationStatement(instance.medicationStatement());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicationStatementValue#medicationStatement() medicationStatement} attribute.
       * @param medicationStatement The value for medicationStatement 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicationStatement")
      public final Builder medicationStatement(MedicationStatement medicationStatement) {
        this.medicationStatement = Objects.requireNonNull(medicationStatement, "medicationStatement");
        initBits &= ~INIT_BIT_MEDICATION_STATEMENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicationStatementValue InternalMedicationStatementValue}.
       * @return An immutable instance of InternalMedicationStatementValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicationStatementValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicationStatementValue(medicationStatement);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICATION_STATEMENT) != 0) attributes.add("medicationStatement");
        return "Cannot build InternalMedicationStatementValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalTestReportValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalTestReportValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalTestReportValue", generator = "Immutables")
  @Immutable
  static final class InternalTestReportValue
      implements ResourceList.InternalTestReportValue {
    private final TestReport testReport;

    private InternalTestReportValue(TestReport testReport) {
      this.testReport = testReport;
    }

    /**
     * @return The value of the {@code testReport} attribute
     */
    @JsonProperty("testReport")
    @JsonValue
    @Override
    public TestReport testReport() {
      return testReport;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalTestReportValue#testReport() testReport} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for testReport
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalTestReportValue withTestReport(TestReport value) {
      if (this.testReport == value) return this;
      TestReport newValue = Objects.requireNonNull(value, "testReport");
      return new ImmutableResourceList.InternalTestReportValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalTestReportValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalTestReportValue
          && equalTo((ImmutableResourceList.InternalTestReportValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalTestReportValue another) {
      return testReport.equals(another.testReport);
    }

    /**
     * Computes a hash code from attributes: {@code testReport}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + testReport.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalTestReportValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalTestReportValue{"
          + "testReport=" + testReport
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalTestReportValue fromJson(TestReport jsonValue) {
      ImmutableResourceList.InternalTestReportValue.Builder builder = ImmutableResourceList.InternalTestReportValue.builder();
      builder.testReport(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalTestReportValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalTestReportValue instance
     */
    public static ImmutableResourceList.InternalTestReportValue copyOf(ResourceList.InternalTestReportValue instance) {
      if (instance instanceof ImmutableResourceList.InternalTestReportValue) {
        return (ImmutableResourceList.InternalTestReportValue) instance;
      }
      return ImmutableResourceList.InternalTestReportValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalTestReportValue InternalTestReportValue}.
     * <pre>
     * ImmutableResourceList.InternalTestReportValue.builder()
     *    .testReport(com.fhir.types.fhir.TestReport) // required {@link ResourceList.InternalTestReportValue#testReport() testReport}
     *    .build();
     * </pre>
     * @return A new InternalTestReportValue builder
     */
    public static ImmutableResourceList.InternalTestReportValue.Builder builder() {
      return new ImmutableResourceList.InternalTestReportValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalTestReportValue InternalTestReportValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalTestReportValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_TEST_REPORT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable TestReport testReport;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalTestReportValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalTestReportValue instance) {
        Objects.requireNonNull(instance, "instance");
        testReport(instance.testReport());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalTestReportValue#testReport() testReport} attribute.
       * @param testReport The value for testReport 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("testReport")
      public final Builder testReport(TestReport testReport) {
        this.testReport = Objects.requireNonNull(testReport, "testReport");
        initBits &= ~INIT_BIT_TEST_REPORT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalTestReportValue InternalTestReportValue}.
       * @return An immutable instance of InternalTestReportValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalTestReportValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalTestReportValue(testReport);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_TEST_REPORT) != 0) attributes.add("testReport");
        return "Cannot build InternalTestReportValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicationAdministrationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicationAdministrationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicationAdministrationValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicationAdministrationValue
      implements ResourceList.InternalMedicationAdministrationValue {
    private final MedicationAdministration medicationAdministration;

    private InternalMedicationAdministrationValue(MedicationAdministration medicationAdministration) {
      this.medicationAdministration = medicationAdministration;
    }

    /**
     * @return The value of the {@code medicationAdministration} attribute
     */
    @JsonProperty("medicationAdministration")
    @JsonValue
    @Override
    public MedicationAdministration medicationAdministration() {
      return medicationAdministration;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicationAdministrationValue#medicationAdministration() medicationAdministration} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicationAdministration
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicationAdministrationValue withMedicationAdministration(MedicationAdministration value) {
      if (this.medicationAdministration == value) return this;
      MedicationAdministration newValue = Objects.requireNonNull(value, "medicationAdministration");
      return new ImmutableResourceList.InternalMedicationAdministrationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicationAdministrationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicationAdministrationValue
          && equalTo((ImmutableResourceList.InternalMedicationAdministrationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicationAdministrationValue another) {
      return medicationAdministration.equals(another.medicationAdministration);
    }

    /**
     * Computes a hash code from attributes: {@code medicationAdministration}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicationAdministration.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicationAdministrationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicationAdministrationValue{"
          + "medicationAdministration=" + medicationAdministration
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicationAdministrationValue fromJson(MedicationAdministration jsonValue) {
      ImmutableResourceList.InternalMedicationAdministrationValue.Builder builder = ImmutableResourceList.InternalMedicationAdministrationValue.builder();
      builder.medicationAdministration(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicationAdministrationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicationAdministrationValue instance
     */
    public static ImmutableResourceList.InternalMedicationAdministrationValue copyOf(ResourceList.InternalMedicationAdministrationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicationAdministrationValue) {
        return (ImmutableResourceList.InternalMedicationAdministrationValue) instance;
      }
      return ImmutableResourceList.InternalMedicationAdministrationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicationAdministrationValue InternalMedicationAdministrationValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicationAdministrationValue.builder()
     *    .medicationAdministration(com.fhir.types.fhir.MedicationAdministration) // required {@link ResourceList.InternalMedicationAdministrationValue#medicationAdministration() medicationAdministration}
     *    .build();
     * </pre>
     * @return A new InternalMedicationAdministrationValue builder
     */
    public static ImmutableResourceList.InternalMedicationAdministrationValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicationAdministrationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicationAdministrationValue InternalMedicationAdministrationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicationAdministrationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICATION_ADMINISTRATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicationAdministration medicationAdministration;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicationAdministrationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicationAdministrationValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicationAdministration(instance.medicationAdministration());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicationAdministrationValue#medicationAdministration() medicationAdministration} attribute.
       * @param medicationAdministration The value for medicationAdministration 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicationAdministration")
      public final Builder medicationAdministration(MedicationAdministration medicationAdministration) {
        this.medicationAdministration = Objects.requireNonNull(medicationAdministration, "medicationAdministration");
        initBits &= ~INIT_BIT_MEDICATION_ADMINISTRATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicationAdministrationValue InternalMedicationAdministrationValue}.
       * @return An immutable instance of InternalMedicationAdministrationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicationAdministrationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicationAdministrationValue(medicationAdministration);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICATION_ADMINISTRATION) != 0) attributes.add("medicationAdministration");
        return "Cannot build InternalMedicationAdministrationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalPaymentNoticeValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalPaymentNoticeValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalPaymentNoticeValue", generator = "Immutables")
  @Immutable
  static final class InternalPaymentNoticeValue
      implements ResourceList.InternalPaymentNoticeValue {
    private final PaymentNotice paymentNotice;

    private InternalPaymentNoticeValue(PaymentNotice paymentNotice) {
      this.paymentNotice = paymentNotice;
    }

    /**
     * @return The value of the {@code paymentNotice} attribute
     */
    @JsonProperty("paymentNotice")
    @JsonValue
    @Override
    public PaymentNotice paymentNotice() {
      return paymentNotice;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalPaymentNoticeValue#paymentNotice() paymentNotice} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for paymentNotice
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalPaymentNoticeValue withPaymentNotice(PaymentNotice value) {
      if (this.paymentNotice == value) return this;
      PaymentNotice newValue = Objects.requireNonNull(value, "paymentNotice");
      return new ImmutableResourceList.InternalPaymentNoticeValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalPaymentNoticeValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalPaymentNoticeValue
          && equalTo((ImmutableResourceList.InternalPaymentNoticeValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalPaymentNoticeValue another) {
      return paymentNotice.equals(another.paymentNotice);
    }

    /**
     * Computes a hash code from attributes: {@code paymentNotice}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + paymentNotice.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalPaymentNoticeValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalPaymentNoticeValue{"
          + "paymentNotice=" + paymentNotice
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalPaymentNoticeValue fromJson(PaymentNotice jsonValue) {
      ImmutableResourceList.InternalPaymentNoticeValue.Builder builder = ImmutableResourceList.InternalPaymentNoticeValue.builder();
      builder.paymentNotice(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalPaymentNoticeValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalPaymentNoticeValue instance
     */
    public static ImmutableResourceList.InternalPaymentNoticeValue copyOf(ResourceList.InternalPaymentNoticeValue instance) {
      if (instance instanceof ImmutableResourceList.InternalPaymentNoticeValue) {
        return (ImmutableResourceList.InternalPaymentNoticeValue) instance;
      }
      return ImmutableResourceList.InternalPaymentNoticeValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalPaymentNoticeValue InternalPaymentNoticeValue}.
     * <pre>
     * ImmutableResourceList.InternalPaymentNoticeValue.builder()
     *    .paymentNotice(com.fhir.types.fhir.PaymentNotice) // required {@link ResourceList.InternalPaymentNoticeValue#paymentNotice() paymentNotice}
     *    .build();
     * </pre>
     * @return A new InternalPaymentNoticeValue builder
     */
    public static ImmutableResourceList.InternalPaymentNoticeValue.Builder builder() {
      return new ImmutableResourceList.InternalPaymentNoticeValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalPaymentNoticeValue InternalPaymentNoticeValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalPaymentNoticeValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PAYMENT_NOTICE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable PaymentNotice paymentNotice;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalPaymentNoticeValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalPaymentNoticeValue instance) {
        Objects.requireNonNull(instance, "instance");
        paymentNotice(instance.paymentNotice());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalPaymentNoticeValue#paymentNotice() paymentNotice} attribute.
       * @param paymentNotice The value for paymentNotice 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("paymentNotice")
      public final Builder paymentNotice(PaymentNotice paymentNotice) {
        this.paymentNotice = Objects.requireNonNull(paymentNotice, "paymentNotice");
        initBits &= ~INIT_BIT_PAYMENT_NOTICE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalPaymentNoticeValue InternalPaymentNoticeValue}.
       * @return An immutable instance of InternalPaymentNoticeValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalPaymentNoticeValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalPaymentNoticeValue(paymentNotice);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PAYMENT_NOTICE) != 0) attributes.add("paymentNotice");
        return "Cannot build InternalPaymentNoticeValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalActivityDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalActivityDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalActivityDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalActivityDefinitionValue
      implements ResourceList.InternalActivityDefinitionValue {
    private final ActivityDefinition activityDefinition;

    private InternalActivityDefinitionValue(ActivityDefinition activityDefinition) {
      this.activityDefinition = activityDefinition;
    }

    /**
     * @return The value of the {@code activityDefinition} attribute
     */
    @JsonProperty("activityDefinition")
    @JsonValue
    @Override
    public ActivityDefinition activityDefinition() {
      return activityDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalActivityDefinitionValue#activityDefinition() activityDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for activityDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalActivityDefinitionValue withActivityDefinition(ActivityDefinition value) {
      if (this.activityDefinition == value) return this;
      ActivityDefinition newValue = Objects.requireNonNull(value, "activityDefinition");
      return new ImmutableResourceList.InternalActivityDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalActivityDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalActivityDefinitionValue
          && equalTo((ImmutableResourceList.InternalActivityDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalActivityDefinitionValue another) {
      return activityDefinition.equals(another.activityDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code activityDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + activityDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalActivityDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalActivityDefinitionValue{"
          + "activityDefinition=" + activityDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalActivityDefinitionValue fromJson(ActivityDefinition jsonValue) {
      ImmutableResourceList.InternalActivityDefinitionValue.Builder builder = ImmutableResourceList.InternalActivityDefinitionValue.builder();
      builder.activityDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalActivityDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalActivityDefinitionValue instance
     */
    public static ImmutableResourceList.InternalActivityDefinitionValue copyOf(ResourceList.InternalActivityDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalActivityDefinitionValue) {
        return (ImmutableResourceList.InternalActivityDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalActivityDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalActivityDefinitionValue InternalActivityDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalActivityDefinitionValue.builder()
     *    .activityDefinition(com.fhir.types.fhir.ActivityDefinition) // required {@link ResourceList.InternalActivityDefinitionValue#activityDefinition() activityDefinition}
     *    .build();
     * </pre>
     * @return A new InternalActivityDefinitionValue builder
     */
    public static ImmutableResourceList.InternalActivityDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalActivityDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalActivityDefinitionValue InternalActivityDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalActivityDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ACTIVITY_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ActivityDefinition activityDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalActivityDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalActivityDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        activityDefinition(instance.activityDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalActivityDefinitionValue#activityDefinition() activityDefinition} attribute.
       * @param activityDefinition The value for activityDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("activityDefinition")
      public final Builder activityDefinition(ActivityDefinition activityDefinition) {
        this.activityDefinition = Objects.requireNonNull(activityDefinition, "activityDefinition");
        initBits &= ~INIT_BIT_ACTIVITY_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalActivityDefinitionValue InternalActivityDefinitionValue}.
       * @return An immutable instance of InternalActivityDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalActivityDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalActivityDefinitionValue(activityDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ACTIVITY_DEFINITION) != 0) attributes.add("activityDefinition");
        return "Cannot build InternalActivityDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalDiagnosticReportValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalDiagnosticReportValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalDiagnosticReportValue", generator = "Immutables")
  @Immutable
  static final class InternalDiagnosticReportValue
      implements ResourceList.InternalDiagnosticReportValue {
    private final DiagnosticReport diagnosticReport;

    private InternalDiagnosticReportValue(DiagnosticReport diagnosticReport) {
      this.diagnosticReport = diagnosticReport;
    }

    /**
     * @return The value of the {@code diagnosticReport} attribute
     */
    @JsonProperty("diagnosticReport")
    @JsonValue
    @Override
    public DiagnosticReport diagnosticReport() {
      return diagnosticReport;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalDiagnosticReportValue#diagnosticReport() diagnosticReport} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for diagnosticReport
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalDiagnosticReportValue withDiagnosticReport(DiagnosticReport value) {
      if (this.diagnosticReport == value) return this;
      DiagnosticReport newValue = Objects.requireNonNull(value, "diagnosticReport");
      return new ImmutableResourceList.InternalDiagnosticReportValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalDiagnosticReportValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalDiagnosticReportValue
          && equalTo((ImmutableResourceList.InternalDiagnosticReportValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalDiagnosticReportValue another) {
      return diagnosticReport.equals(another.diagnosticReport);
    }

    /**
     * Computes a hash code from attributes: {@code diagnosticReport}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + diagnosticReport.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalDiagnosticReportValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalDiagnosticReportValue{"
          + "diagnosticReport=" + diagnosticReport
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalDiagnosticReportValue fromJson(DiagnosticReport jsonValue) {
      ImmutableResourceList.InternalDiagnosticReportValue.Builder builder = ImmutableResourceList.InternalDiagnosticReportValue.builder();
      builder.diagnosticReport(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalDiagnosticReportValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalDiagnosticReportValue instance
     */
    public static ImmutableResourceList.InternalDiagnosticReportValue copyOf(ResourceList.InternalDiagnosticReportValue instance) {
      if (instance instanceof ImmutableResourceList.InternalDiagnosticReportValue) {
        return (ImmutableResourceList.InternalDiagnosticReportValue) instance;
      }
      return ImmutableResourceList.InternalDiagnosticReportValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalDiagnosticReportValue InternalDiagnosticReportValue}.
     * <pre>
     * ImmutableResourceList.InternalDiagnosticReportValue.builder()
     *    .diagnosticReport(com.fhir.types.fhir.DiagnosticReport) // required {@link ResourceList.InternalDiagnosticReportValue#diagnosticReport() diagnosticReport}
     *    .build();
     * </pre>
     * @return A new InternalDiagnosticReportValue builder
     */
    public static ImmutableResourceList.InternalDiagnosticReportValue.Builder builder() {
      return new ImmutableResourceList.InternalDiagnosticReportValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalDiagnosticReportValue InternalDiagnosticReportValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalDiagnosticReportValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_DIAGNOSTIC_REPORT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable DiagnosticReport diagnosticReport;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalDiagnosticReportValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalDiagnosticReportValue instance) {
        Objects.requireNonNull(instance, "instance");
        diagnosticReport(instance.diagnosticReport());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalDiagnosticReportValue#diagnosticReport() diagnosticReport} attribute.
       * @param diagnosticReport The value for diagnosticReport 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("diagnosticReport")
      public final Builder diagnosticReport(DiagnosticReport diagnosticReport) {
        this.diagnosticReport = Objects.requireNonNull(diagnosticReport, "diagnosticReport");
        initBits &= ~INIT_BIT_DIAGNOSTIC_REPORT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalDiagnosticReportValue InternalDiagnosticReportValue}.
       * @return An immutable instance of InternalDiagnosticReportValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalDiagnosticReportValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalDiagnosticReportValue(diagnosticReport);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_DIAGNOSTIC_REPORT) != 0) attributes.add("diagnosticReport");
        return "Cannot build InternalDiagnosticReportValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalNutritionOrderValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalNutritionOrderValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalNutritionOrderValue", generator = "Immutables")
  @Immutable
  static final class InternalNutritionOrderValue
      implements ResourceList.InternalNutritionOrderValue {
    private final NutritionOrder nutritionOrder;

    private InternalNutritionOrderValue(NutritionOrder nutritionOrder) {
      this.nutritionOrder = nutritionOrder;
    }

    /**
     * @return The value of the {@code nutritionOrder} attribute
     */
    @JsonProperty("nutritionOrder")
    @JsonValue
    @Override
    public NutritionOrder nutritionOrder() {
      return nutritionOrder;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalNutritionOrderValue#nutritionOrder() nutritionOrder} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for nutritionOrder
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalNutritionOrderValue withNutritionOrder(NutritionOrder value) {
      if (this.nutritionOrder == value) return this;
      NutritionOrder newValue = Objects.requireNonNull(value, "nutritionOrder");
      return new ImmutableResourceList.InternalNutritionOrderValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalNutritionOrderValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalNutritionOrderValue
          && equalTo((ImmutableResourceList.InternalNutritionOrderValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalNutritionOrderValue another) {
      return nutritionOrder.equals(another.nutritionOrder);
    }

    /**
     * Computes a hash code from attributes: {@code nutritionOrder}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + nutritionOrder.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalNutritionOrderValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalNutritionOrderValue{"
          + "nutritionOrder=" + nutritionOrder
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalNutritionOrderValue fromJson(NutritionOrder jsonValue) {
      ImmutableResourceList.InternalNutritionOrderValue.Builder builder = ImmutableResourceList.InternalNutritionOrderValue.builder();
      builder.nutritionOrder(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalNutritionOrderValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalNutritionOrderValue instance
     */
    public static ImmutableResourceList.InternalNutritionOrderValue copyOf(ResourceList.InternalNutritionOrderValue instance) {
      if (instance instanceof ImmutableResourceList.InternalNutritionOrderValue) {
        return (ImmutableResourceList.InternalNutritionOrderValue) instance;
      }
      return ImmutableResourceList.InternalNutritionOrderValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalNutritionOrderValue InternalNutritionOrderValue}.
     * <pre>
     * ImmutableResourceList.InternalNutritionOrderValue.builder()
     *    .nutritionOrder(com.fhir.types.fhir.NutritionOrder) // required {@link ResourceList.InternalNutritionOrderValue#nutritionOrder() nutritionOrder}
     *    .build();
     * </pre>
     * @return A new InternalNutritionOrderValue builder
     */
    public static ImmutableResourceList.InternalNutritionOrderValue.Builder builder() {
      return new ImmutableResourceList.InternalNutritionOrderValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalNutritionOrderValue InternalNutritionOrderValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalNutritionOrderValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_NUTRITION_ORDER = 0x1L;
      private long initBits = 0x1L;

      private @Nullable NutritionOrder nutritionOrder;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalNutritionOrderValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalNutritionOrderValue instance) {
        Objects.requireNonNull(instance, "instance");
        nutritionOrder(instance.nutritionOrder());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalNutritionOrderValue#nutritionOrder() nutritionOrder} attribute.
       * @param nutritionOrder The value for nutritionOrder 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("nutritionOrder")
      public final Builder nutritionOrder(NutritionOrder nutritionOrder) {
        this.nutritionOrder = Objects.requireNonNull(nutritionOrder, "nutritionOrder");
        initBits &= ~INIT_BIT_NUTRITION_ORDER;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalNutritionOrderValue InternalNutritionOrderValue}.
       * @return An immutable instance of InternalNutritionOrderValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalNutritionOrderValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalNutritionOrderValue(nutritionOrder);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_NUTRITION_ORDER) != 0) attributes.add("nutritionOrder");
        return "Cannot build InternalNutritionOrderValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSpecimenDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSpecimenDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSpecimenDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalSpecimenDefinitionValue
      implements ResourceList.InternalSpecimenDefinitionValue {
    private final SpecimenDefinition specimenDefinition;

    private InternalSpecimenDefinitionValue(SpecimenDefinition specimenDefinition) {
      this.specimenDefinition = specimenDefinition;
    }

    /**
     * @return The value of the {@code specimenDefinition} attribute
     */
    @JsonProperty("specimenDefinition")
    @JsonValue
    @Override
    public SpecimenDefinition specimenDefinition() {
      return specimenDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSpecimenDefinitionValue#specimenDefinition() specimenDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for specimenDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSpecimenDefinitionValue withSpecimenDefinition(SpecimenDefinition value) {
      if (this.specimenDefinition == value) return this;
      SpecimenDefinition newValue = Objects.requireNonNull(value, "specimenDefinition");
      return new ImmutableResourceList.InternalSpecimenDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSpecimenDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSpecimenDefinitionValue
          && equalTo((ImmutableResourceList.InternalSpecimenDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSpecimenDefinitionValue another) {
      return specimenDefinition.equals(another.specimenDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code specimenDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + specimenDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSpecimenDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSpecimenDefinitionValue{"
          + "specimenDefinition=" + specimenDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSpecimenDefinitionValue fromJson(SpecimenDefinition jsonValue) {
      ImmutableResourceList.InternalSpecimenDefinitionValue.Builder builder = ImmutableResourceList.InternalSpecimenDefinitionValue.builder();
      builder.specimenDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSpecimenDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSpecimenDefinitionValue instance
     */
    public static ImmutableResourceList.InternalSpecimenDefinitionValue copyOf(ResourceList.InternalSpecimenDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSpecimenDefinitionValue) {
        return (ImmutableResourceList.InternalSpecimenDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalSpecimenDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSpecimenDefinitionValue InternalSpecimenDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalSpecimenDefinitionValue.builder()
     *    .specimenDefinition(com.fhir.types.fhir.SpecimenDefinition) // required {@link ResourceList.InternalSpecimenDefinitionValue#specimenDefinition() specimenDefinition}
     *    .build();
     * </pre>
     * @return A new InternalSpecimenDefinitionValue builder
     */
    public static ImmutableResourceList.InternalSpecimenDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalSpecimenDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSpecimenDefinitionValue InternalSpecimenDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSpecimenDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SPECIMEN_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SpecimenDefinition specimenDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSpecimenDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSpecimenDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        specimenDefinition(instance.specimenDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSpecimenDefinitionValue#specimenDefinition() specimenDefinition} attribute.
       * @param specimenDefinition The value for specimenDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("specimenDefinition")
      public final Builder specimenDefinition(SpecimenDefinition specimenDefinition) {
        this.specimenDefinition = Objects.requireNonNull(specimenDefinition, "specimenDefinition");
        initBits &= ~INIT_BIT_SPECIMEN_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSpecimenDefinitionValue InternalSpecimenDefinitionValue}.
       * @return An immutable instance of InternalSpecimenDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSpecimenDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSpecimenDefinitionValue(specimenDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SPECIMEN_DEFINITION) != 0) attributes.add("specimenDefinition");
        return "Cannot build InternalSpecimenDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicationRequestValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicationRequestValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicationRequestValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicationRequestValue
      implements ResourceList.InternalMedicationRequestValue {
    private final MedicationRequest medicationRequest;

    private InternalMedicationRequestValue(MedicationRequest medicationRequest) {
      this.medicationRequest = medicationRequest;
    }

    /**
     * @return The value of the {@code medicationRequest} attribute
     */
    @JsonProperty("medicationRequest")
    @JsonValue
    @Override
    public MedicationRequest medicationRequest() {
      return medicationRequest;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicationRequestValue#medicationRequest() medicationRequest} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicationRequest
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicationRequestValue withMedicationRequest(MedicationRequest value) {
      if (this.medicationRequest == value) return this;
      MedicationRequest newValue = Objects.requireNonNull(value, "medicationRequest");
      return new ImmutableResourceList.InternalMedicationRequestValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicationRequestValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicationRequestValue
          && equalTo((ImmutableResourceList.InternalMedicationRequestValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicationRequestValue another) {
      return medicationRequest.equals(another.medicationRequest);
    }

    /**
     * Computes a hash code from attributes: {@code medicationRequest}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicationRequest.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicationRequestValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicationRequestValue{"
          + "medicationRequest=" + medicationRequest
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicationRequestValue fromJson(MedicationRequest jsonValue) {
      ImmutableResourceList.InternalMedicationRequestValue.Builder builder = ImmutableResourceList.InternalMedicationRequestValue.builder();
      builder.medicationRequest(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicationRequestValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicationRequestValue instance
     */
    public static ImmutableResourceList.InternalMedicationRequestValue copyOf(ResourceList.InternalMedicationRequestValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicationRequestValue) {
        return (ImmutableResourceList.InternalMedicationRequestValue) instance;
      }
      return ImmutableResourceList.InternalMedicationRequestValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicationRequestValue InternalMedicationRequestValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicationRequestValue.builder()
     *    .medicationRequest(com.fhir.types.fhir.MedicationRequest) // required {@link ResourceList.InternalMedicationRequestValue#medicationRequest() medicationRequest}
     *    .build();
     * </pre>
     * @return A new InternalMedicationRequestValue builder
     */
    public static ImmutableResourceList.InternalMedicationRequestValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicationRequestValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicationRequestValue InternalMedicationRequestValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicationRequestValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICATION_REQUEST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicationRequest medicationRequest;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicationRequestValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicationRequestValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicationRequest(instance.medicationRequest());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicationRequestValue#medicationRequest() medicationRequest} attribute.
       * @param medicationRequest The value for medicationRequest 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicationRequest")
      public final Builder medicationRequest(MedicationRequest medicationRequest) {
        this.medicationRequest = Objects.requireNonNull(medicationRequest, "medicationRequest");
        initBits &= ~INIT_BIT_MEDICATION_REQUEST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicationRequestValue InternalMedicationRequestValue}.
       * @return An immutable instance of InternalMedicationRequestValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicationRequestValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicationRequestValue(medicationRequest);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICATION_REQUEST) != 0) attributes.add("medicationRequest");
        return "Cannot build InternalMedicationRequestValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalClaimResponseValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalClaimResponseValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalClaimResponseValue", generator = "Immutables")
  @Immutable
  static final class InternalClaimResponseValue
      implements ResourceList.InternalClaimResponseValue {
    private final ClaimResponse claimResponse;

    private InternalClaimResponseValue(ClaimResponse claimResponse) {
      this.claimResponse = claimResponse;
    }

    /**
     * @return The value of the {@code claimResponse} attribute
     */
    @JsonProperty("claimResponse")
    @JsonValue
    @Override
    public ClaimResponse claimResponse() {
      return claimResponse;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalClaimResponseValue#claimResponse() claimResponse} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for claimResponse
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalClaimResponseValue withClaimResponse(ClaimResponse value) {
      if (this.claimResponse == value) return this;
      ClaimResponse newValue = Objects.requireNonNull(value, "claimResponse");
      return new ImmutableResourceList.InternalClaimResponseValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalClaimResponseValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalClaimResponseValue
          && equalTo((ImmutableResourceList.InternalClaimResponseValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalClaimResponseValue another) {
      return claimResponse.equals(another.claimResponse);
    }

    /**
     * Computes a hash code from attributes: {@code claimResponse}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + claimResponse.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalClaimResponseValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalClaimResponseValue{"
          + "claimResponse=" + claimResponse
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalClaimResponseValue fromJson(ClaimResponse jsonValue) {
      ImmutableResourceList.InternalClaimResponseValue.Builder builder = ImmutableResourceList.InternalClaimResponseValue.builder();
      builder.claimResponse(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalClaimResponseValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalClaimResponseValue instance
     */
    public static ImmutableResourceList.InternalClaimResponseValue copyOf(ResourceList.InternalClaimResponseValue instance) {
      if (instance instanceof ImmutableResourceList.InternalClaimResponseValue) {
        return (ImmutableResourceList.InternalClaimResponseValue) instance;
      }
      return ImmutableResourceList.InternalClaimResponseValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalClaimResponseValue InternalClaimResponseValue}.
     * <pre>
     * ImmutableResourceList.InternalClaimResponseValue.builder()
     *    .claimResponse(com.fhir.types.fhir.ClaimResponse) // required {@link ResourceList.InternalClaimResponseValue#claimResponse() claimResponse}
     *    .build();
     * </pre>
     * @return A new InternalClaimResponseValue builder
     */
    public static ImmutableResourceList.InternalClaimResponseValue.Builder builder() {
      return new ImmutableResourceList.InternalClaimResponseValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalClaimResponseValue InternalClaimResponseValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalClaimResponseValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CLAIM_RESPONSE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ClaimResponse claimResponse;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalClaimResponseValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalClaimResponseValue instance) {
        Objects.requireNonNull(instance, "instance");
        claimResponse(instance.claimResponse());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalClaimResponseValue#claimResponse() claimResponse} attribute.
       * @param claimResponse The value for claimResponse 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("claimResponse")
      public final Builder claimResponse(ClaimResponse claimResponse) {
        this.claimResponse = Objects.requireNonNull(claimResponse, "claimResponse");
        initBits &= ~INIT_BIT_CLAIM_RESPONSE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalClaimResponseValue InternalClaimResponseValue}.
       * @return An immutable instance of InternalClaimResponseValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalClaimResponseValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalClaimResponseValue(claimResponse);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CLAIM_RESPONSE) != 0) attributes.add("claimResponse");
        return "Cannot build InternalClaimResponseValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalEffectEvidenceSynthesisValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalEffectEvidenceSynthesisValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalEffectEvidenceSynthesisValue", generator = "Immutables")
  @Immutable
  static final class InternalEffectEvidenceSynthesisValue
      implements ResourceList.InternalEffectEvidenceSynthesisValue {
    private final EffectEvidenceSynthesis effectEvidenceSynthesis;

    private InternalEffectEvidenceSynthesisValue(EffectEvidenceSynthesis effectEvidenceSynthesis) {
      this.effectEvidenceSynthesis = effectEvidenceSynthesis;
    }

    /**
     * @return The value of the {@code effectEvidenceSynthesis} attribute
     */
    @JsonProperty("effectEvidenceSynthesis")
    @JsonValue
    @Override
    public EffectEvidenceSynthesis effectEvidenceSynthesis() {
      return effectEvidenceSynthesis;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalEffectEvidenceSynthesisValue#effectEvidenceSynthesis() effectEvidenceSynthesis} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for effectEvidenceSynthesis
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalEffectEvidenceSynthesisValue withEffectEvidenceSynthesis(EffectEvidenceSynthesis value) {
      if (this.effectEvidenceSynthesis == value) return this;
      EffectEvidenceSynthesis newValue = Objects.requireNonNull(value, "effectEvidenceSynthesis");
      return new ImmutableResourceList.InternalEffectEvidenceSynthesisValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalEffectEvidenceSynthesisValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalEffectEvidenceSynthesisValue
          && equalTo((ImmutableResourceList.InternalEffectEvidenceSynthesisValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalEffectEvidenceSynthesisValue another) {
      return effectEvidenceSynthesis.equals(another.effectEvidenceSynthesis);
    }

    /**
     * Computes a hash code from attributes: {@code effectEvidenceSynthesis}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + effectEvidenceSynthesis.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalEffectEvidenceSynthesisValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalEffectEvidenceSynthesisValue{"
          + "effectEvidenceSynthesis=" + effectEvidenceSynthesis
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalEffectEvidenceSynthesisValue fromJson(EffectEvidenceSynthesis jsonValue) {
      ImmutableResourceList.InternalEffectEvidenceSynthesisValue.Builder builder = ImmutableResourceList.InternalEffectEvidenceSynthesisValue.builder();
      builder.effectEvidenceSynthesis(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalEffectEvidenceSynthesisValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalEffectEvidenceSynthesisValue instance
     */
    public static ImmutableResourceList.InternalEffectEvidenceSynthesisValue copyOf(ResourceList.InternalEffectEvidenceSynthesisValue instance) {
      if (instance instanceof ImmutableResourceList.InternalEffectEvidenceSynthesisValue) {
        return (ImmutableResourceList.InternalEffectEvidenceSynthesisValue) instance;
      }
      return ImmutableResourceList.InternalEffectEvidenceSynthesisValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalEffectEvidenceSynthesisValue InternalEffectEvidenceSynthesisValue}.
     * <pre>
     * ImmutableResourceList.InternalEffectEvidenceSynthesisValue.builder()
     *    .effectEvidenceSynthesis(com.fhir.types.fhir.EffectEvidenceSynthesis) // required {@link ResourceList.InternalEffectEvidenceSynthesisValue#effectEvidenceSynthesis() effectEvidenceSynthesis}
     *    .build();
     * </pre>
     * @return A new InternalEffectEvidenceSynthesisValue builder
     */
    public static ImmutableResourceList.InternalEffectEvidenceSynthesisValue.Builder builder() {
      return new ImmutableResourceList.InternalEffectEvidenceSynthesisValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalEffectEvidenceSynthesisValue InternalEffectEvidenceSynthesisValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalEffectEvidenceSynthesisValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_EFFECT_EVIDENCE_SYNTHESIS = 0x1L;
      private long initBits = 0x1L;

      private @Nullable EffectEvidenceSynthesis effectEvidenceSynthesis;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalEffectEvidenceSynthesisValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalEffectEvidenceSynthesisValue instance) {
        Objects.requireNonNull(instance, "instance");
        effectEvidenceSynthesis(instance.effectEvidenceSynthesis());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalEffectEvidenceSynthesisValue#effectEvidenceSynthesis() effectEvidenceSynthesis} attribute.
       * @param effectEvidenceSynthesis The value for effectEvidenceSynthesis 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("effectEvidenceSynthesis")
      public final Builder effectEvidenceSynthesis(EffectEvidenceSynthesis effectEvidenceSynthesis) {
        this.effectEvidenceSynthesis = Objects.requireNonNull(effectEvidenceSynthesis, "effectEvidenceSynthesis");
        initBits &= ~INIT_BIT_EFFECT_EVIDENCE_SYNTHESIS;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalEffectEvidenceSynthesisValue InternalEffectEvidenceSynthesisValue}.
       * @return An immutable instance of InternalEffectEvidenceSynthesisValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalEffectEvidenceSynthesisValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalEffectEvidenceSynthesisValue(effectEvidenceSynthesis);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_EFFECT_EVIDENCE_SYNTHESIS) != 0) attributes.add("effectEvidenceSynthesis");
        return "Cannot build InternalEffectEvidenceSynthesisValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalResearchElementDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalResearchElementDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalResearchElementDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalResearchElementDefinitionValue
      implements ResourceList.InternalResearchElementDefinitionValue {
    private final ResearchElementDefinition researchElementDefinition;

    private InternalResearchElementDefinitionValue(ResearchElementDefinition researchElementDefinition) {
      this.researchElementDefinition = researchElementDefinition;
    }

    /**
     * @return The value of the {@code researchElementDefinition} attribute
     */
    @JsonProperty("researchElementDefinition")
    @JsonValue
    @Override
    public ResearchElementDefinition researchElementDefinition() {
      return researchElementDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalResearchElementDefinitionValue#researchElementDefinition() researchElementDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for researchElementDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalResearchElementDefinitionValue withResearchElementDefinition(ResearchElementDefinition value) {
      if (this.researchElementDefinition == value) return this;
      ResearchElementDefinition newValue = Objects.requireNonNull(value, "researchElementDefinition");
      return new ImmutableResourceList.InternalResearchElementDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalResearchElementDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalResearchElementDefinitionValue
          && equalTo((ImmutableResourceList.InternalResearchElementDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalResearchElementDefinitionValue another) {
      return researchElementDefinition.equals(another.researchElementDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code researchElementDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + researchElementDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalResearchElementDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalResearchElementDefinitionValue{"
          + "researchElementDefinition=" + researchElementDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalResearchElementDefinitionValue fromJson(ResearchElementDefinition jsonValue) {
      ImmutableResourceList.InternalResearchElementDefinitionValue.Builder builder = ImmutableResourceList.InternalResearchElementDefinitionValue.builder();
      builder.researchElementDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalResearchElementDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalResearchElementDefinitionValue instance
     */
    public static ImmutableResourceList.InternalResearchElementDefinitionValue copyOf(ResourceList.InternalResearchElementDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalResearchElementDefinitionValue) {
        return (ImmutableResourceList.InternalResearchElementDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalResearchElementDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalResearchElementDefinitionValue InternalResearchElementDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalResearchElementDefinitionValue.builder()
     *    .researchElementDefinition(com.fhir.types.fhir.ResearchElementDefinition) // required {@link ResourceList.InternalResearchElementDefinitionValue#researchElementDefinition() researchElementDefinition}
     *    .build();
     * </pre>
     * @return A new InternalResearchElementDefinitionValue builder
     */
    public static ImmutableResourceList.InternalResearchElementDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalResearchElementDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalResearchElementDefinitionValue InternalResearchElementDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalResearchElementDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_RESEARCH_ELEMENT_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ResearchElementDefinition researchElementDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalResearchElementDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalResearchElementDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        researchElementDefinition(instance.researchElementDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalResearchElementDefinitionValue#researchElementDefinition() researchElementDefinition} attribute.
       * @param researchElementDefinition The value for researchElementDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("researchElementDefinition")
      public final Builder researchElementDefinition(ResearchElementDefinition researchElementDefinition) {
        this.researchElementDefinition = Objects.requireNonNull(researchElementDefinition, "researchElementDefinition");
        initBits &= ~INIT_BIT_RESEARCH_ELEMENT_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalResearchElementDefinitionValue InternalResearchElementDefinitionValue}.
       * @return An immutable instance of InternalResearchElementDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalResearchElementDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalResearchElementDefinitionValue(researchElementDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_RESEARCH_ELEMENT_DEFINITION) != 0) attributes.add("researchElementDefinition");
        return "Cannot build InternalResearchElementDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalAppointmentResponseValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalAppointmentResponseValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalAppointmentResponseValue", generator = "Immutables")
  @Immutable
  static final class InternalAppointmentResponseValue
      implements ResourceList.InternalAppointmentResponseValue {
    private final AppointmentResponse appointmentResponse;

    private InternalAppointmentResponseValue(AppointmentResponse appointmentResponse) {
      this.appointmentResponse = appointmentResponse;
    }

    /**
     * @return The value of the {@code appointmentResponse} attribute
     */
    @JsonProperty("appointmentResponse")
    @JsonValue
    @Override
    public AppointmentResponse appointmentResponse() {
      return appointmentResponse;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalAppointmentResponseValue#appointmentResponse() appointmentResponse} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for appointmentResponse
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalAppointmentResponseValue withAppointmentResponse(AppointmentResponse value) {
      if (this.appointmentResponse == value) return this;
      AppointmentResponse newValue = Objects.requireNonNull(value, "appointmentResponse");
      return new ImmutableResourceList.InternalAppointmentResponseValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalAppointmentResponseValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalAppointmentResponseValue
          && equalTo((ImmutableResourceList.InternalAppointmentResponseValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalAppointmentResponseValue another) {
      return appointmentResponse.equals(another.appointmentResponse);
    }

    /**
     * Computes a hash code from attributes: {@code appointmentResponse}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + appointmentResponse.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalAppointmentResponseValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalAppointmentResponseValue{"
          + "appointmentResponse=" + appointmentResponse
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalAppointmentResponseValue fromJson(AppointmentResponse jsonValue) {
      ImmutableResourceList.InternalAppointmentResponseValue.Builder builder = ImmutableResourceList.InternalAppointmentResponseValue.builder();
      builder.appointmentResponse(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalAppointmentResponseValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalAppointmentResponseValue instance
     */
    public static ImmutableResourceList.InternalAppointmentResponseValue copyOf(ResourceList.InternalAppointmentResponseValue instance) {
      if (instance instanceof ImmutableResourceList.InternalAppointmentResponseValue) {
        return (ImmutableResourceList.InternalAppointmentResponseValue) instance;
      }
      return ImmutableResourceList.InternalAppointmentResponseValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalAppointmentResponseValue InternalAppointmentResponseValue}.
     * <pre>
     * ImmutableResourceList.InternalAppointmentResponseValue.builder()
     *    .appointmentResponse(com.fhir.types.fhir.AppointmentResponse) // required {@link ResourceList.InternalAppointmentResponseValue#appointmentResponse() appointmentResponse}
     *    .build();
     * </pre>
     * @return A new InternalAppointmentResponseValue builder
     */
    public static ImmutableResourceList.InternalAppointmentResponseValue.Builder builder() {
      return new ImmutableResourceList.InternalAppointmentResponseValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalAppointmentResponseValue InternalAppointmentResponseValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalAppointmentResponseValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_APPOINTMENT_RESPONSE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable AppointmentResponse appointmentResponse;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalAppointmentResponseValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalAppointmentResponseValue instance) {
        Objects.requireNonNull(instance, "instance");
        appointmentResponse(instance.appointmentResponse());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalAppointmentResponseValue#appointmentResponse() appointmentResponse} attribute.
       * @param appointmentResponse The value for appointmentResponse 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("appointmentResponse")
      public final Builder appointmentResponse(AppointmentResponse appointmentResponse) {
        this.appointmentResponse = Objects.requireNonNull(appointmentResponse, "appointmentResponse");
        initBits &= ~INIT_BIT_APPOINTMENT_RESPONSE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalAppointmentResponseValue InternalAppointmentResponseValue}.
       * @return An immutable instance of InternalAppointmentResponseValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalAppointmentResponseValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalAppointmentResponseValue(appointmentResponse);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_APPOINTMENT_RESPONSE) != 0) attributes.add("appointmentResponse");
        return "Cannot build InternalAppointmentResponseValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalGraphDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalGraphDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalGraphDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalGraphDefinitionValue
      implements ResourceList.InternalGraphDefinitionValue {
    private final GraphDefinition graphDefinition;

    private InternalGraphDefinitionValue(GraphDefinition graphDefinition) {
      this.graphDefinition = graphDefinition;
    }

    /**
     * @return The value of the {@code graphDefinition} attribute
     */
    @JsonProperty("graphDefinition")
    @JsonValue
    @Override
    public GraphDefinition graphDefinition() {
      return graphDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalGraphDefinitionValue#graphDefinition() graphDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for graphDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalGraphDefinitionValue withGraphDefinition(GraphDefinition value) {
      if (this.graphDefinition == value) return this;
      GraphDefinition newValue = Objects.requireNonNull(value, "graphDefinition");
      return new ImmutableResourceList.InternalGraphDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalGraphDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalGraphDefinitionValue
          && equalTo((ImmutableResourceList.InternalGraphDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalGraphDefinitionValue another) {
      return graphDefinition.equals(another.graphDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code graphDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + graphDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalGraphDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalGraphDefinitionValue{"
          + "graphDefinition=" + graphDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalGraphDefinitionValue fromJson(GraphDefinition jsonValue) {
      ImmutableResourceList.InternalGraphDefinitionValue.Builder builder = ImmutableResourceList.InternalGraphDefinitionValue.builder();
      builder.graphDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalGraphDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalGraphDefinitionValue instance
     */
    public static ImmutableResourceList.InternalGraphDefinitionValue copyOf(ResourceList.InternalGraphDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalGraphDefinitionValue) {
        return (ImmutableResourceList.InternalGraphDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalGraphDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalGraphDefinitionValue InternalGraphDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalGraphDefinitionValue.builder()
     *    .graphDefinition(com.fhir.types.fhir.GraphDefinition) // required {@link ResourceList.InternalGraphDefinitionValue#graphDefinition() graphDefinition}
     *    .build();
     * </pre>
     * @return A new InternalGraphDefinitionValue builder
     */
    public static ImmutableResourceList.InternalGraphDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalGraphDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalGraphDefinitionValue InternalGraphDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalGraphDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_GRAPH_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable GraphDefinition graphDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalGraphDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalGraphDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        graphDefinition(instance.graphDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalGraphDefinitionValue#graphDefinition() graphDefinition} attribute.
       * @param graphDefinition The value for graphDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("graphDefinition")
      public final Builder graphDefinition(GraphDefinition graphDefinition) {
        this.graphDefinition = Objects.requireNonNull(graphDefinition, "graphDefinition");
        initBits &= ~INIT_BIT_GRAPH_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalGraphDefinitionValue InternalGraphDefinitionValue}.
       * @return An immutable instance of InternalGraphDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalGraphDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalGraphDefinitionValue(graphDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_GRAPH_DEFINITION) != 0) attributes.add("graphDefinition");
        return "Cannot build InternalGraphDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalClinicalImpressionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalClinicalImpressionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalClinicalImpressionValue", generator = "Immutables")
  @Immutable
  static final class InternalClinicalImpressionValue
      implements ResourceList.InternalClinicalImpressionValue {
    private final ClinicalImpression clinicalImpression;

    private InternalClinicalImpressionValue(ClinicalImpression clinicalImpression) {
      this.clinicalImpression = clinicalImpression;
    }

    /**
     * @return The value of the {@code clinicalImpression} attribute
     */
    @JsonProperty("clinicalImpression")
    @JsonValue
    @Override
    public ClinicalImpression clinicalImpression() {
      return clinicalImpression;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalClinicalImpressionValue#clinicalImpression() clinicalImpression} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for clinicalImpression
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalClinicalImpressionValue withClinicalImpression(ClinicalImpression value) {
      if (this.clinicalImpression == value) return this;
      ClinicalImpression newValue = Objects.requireNonNull(value, "clinicalImpression");
      return new ImmutableResourceList.InternalClinicalImpressionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalClinicalImpressionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalClinicalImpressionValue
          && equalTo((ImmutableResourceList.InternalClinicalImpressionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalClinicalImpressionValue another) {
      return clinicalImpression.equals(another.clinicalImpression);
    }

    /**
     * Computes a hash code from attributes: {@code clinicalImpression}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + clinicalImpression.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalClinicalImpressionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalClinicalImpressionValue{"
          + "clinicalImpression=" + clinicalImpression
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalClinicalImpressionValue fromJson(ClinicalImpression jsonValue) {
      ImmutableResourceList.InternalClinicalImpressionValue.Builder builder = ImmutableResourceList.InternalClinicalImpressionValue.builder();
      builder.clinicalImpression(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalClinicalImpressionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalClinicalImpressionValue instance
     */
    public static ImmutableResourceList.InternalClinicalImpressionValue copyOf(ResourceList.InternalClinicalImpressionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalClinicalImpressionValue) {
        return (ImmutableResourceList.InternalClinicalImpressionValue) instance;
      }
      return ImmutableResourceList.InternalClinicalImpressionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalClinicalImpressionValue InternalClinicalImpressionValue}.
     * <pre>
     * ImmutableResourceList.InternalClinicalImpressionValue.builder()
     *    .clinicalImpression(com.fhir.types.fhir.ClinicalImpression) // required {@link ResourceList.InternalClinicalImpressionValue#clinicalImpression() clinicalImpression}
     *    .build();
     * </pre>
     * @return A new InternalClinicalImpressionValue builder
     */
    public static ImmutableResourceList.InternalClinicalImpressionValue.Builder builder() {
      return new ImmutableResourceList.InternalClinicalImpressionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalClinicalImpressionValue InternalClinicalImpressionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalClinicalImpressionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CLINICAL_IMPRESSION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ClinicalImpression clinicalImpression;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalClinicalImpressionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalClinicalImpressionValue instance) {
        Objects.requireNonNull(instance, "instance");
        clinicalImpression(instance.clinicalImpression());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalClinicalImpressionValue#clinicalImpression() clinicalImpression} attribute.
       * @param clinicalImpression The value for clinicalImpression 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("clinicalImpression")
      public final Builder clinicalImpression(ClinicalImpression clinicalImpression) {
        this.clinicalImpression = Objects.requireNonNull(clinicalImpression, "clinicalImpression");
        initBits &= ~INIT_BIT_CLINICAL_IMPRESSION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalClinicalImpressionValue InternalClinicalImpressionValue}.
       * @return An immutable instance of InternalClinicalImpressionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalClinicalImpressionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalClinicalImpressionValue(clinicalImpression);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CLINICAL_IMPRESSION) != 0) attributes.add("clinicalImpression");
        return "Cannot build InternalClinicalImpressionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalScheduleValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalScheduleValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalScheduleValue", generator = "Immutables")
  @Immutable
  static final class InternalScheduleValue implements ResourceList.InternalScheduleValue {
    private final Schedule schedule;

    private InternalScheduleValue(Schedule schedule) {
      this.schedule = schedule;
    }

    /**
     * @return The value of the {@code schedule} attribute
     */
    @JsonProperty("schedule")
    @JsonValue
    @Override
    public Schedule schedule() {
      return schedule;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalScheduleValue#schedule() schedule} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for schedule
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalScheduleValue withSchedule(Schedule value) {
      if (this.schedule == value) return this;
      Schedule newValue = Objects.requireNonNull(value, "schedule");
      return new ImmutableResourceList.InternalScheduleValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalScheduleValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalScheduleValue
          && equalTo((ImmutableResourceList.InternalScheduleValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalScheduleValue another) {
      return schedule.equals(another.schedule);
    }

    /**
     * Computes a hash code from attributes: {@code schedule}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + schedule.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalScheduleValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalScheduleValue{"
          + "schedule=" + schedule
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalScheduleValue fromJson(Schedule jsonValue) {
      ImmutableResourceList.InternalScheduleValue.Builder builder = ImmutableResourceList.InternalScheduleValue.builder();
      builder.schedule(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalScheduleValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalScheduleValue instance
     */
    public static ImmutableResourceList.InternalScheduleValue copyOf(ResourceList.InternalScheduleValue instance) {
      if (instance instanceof ImmutableResourceList.InternalScheduleValue) {
        return (ImmutableResourceList.InternalScheduleValue) instance;
      }
      return ImmutableResourceList.InternalScheduleValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalScheduleValue InternalScheduleValue}.
     * <pre>
     * ImmutableResourceList.InternalScheduleValue.builder()
     *    .schedule(com.fhir.types.fhir.Schedule) // required {@link ResourceList.InternalScheduleValue#schedule() schedule}
     *    .build();
     * </pre>
     * @return A new InternalScheduleValue builder
     */
    public static ImmutableResourceList.InternalScheduleValue.Builder builder() {
      return new ImmutableResourceList.InternalScheduleValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalScheduleValue InternalScheduleValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalScheduleValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SCHEDULE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Schedule schedule;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalScheduleValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalScheduleValue instance) {
        Objects.requireNonNull(instance, "instance");
        schedule(instance.schedule());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalScheduleValue#schedule() schedule} attribute.
       * @param schedule The value for schedule 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("schedule")
      public final Builder schedule(Schedule schedule) {
        this.schedule = Objects.requireNonNull(schedule, "schedule");
        initBits &= ~INIT_BIT_SCHEDULE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalScheduleValue InternalScheduleValue}.
       * @return An immutable instance of InternalScheduleValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalScheduleValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalScheduleValue(schedule);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SCHEDULE) != 0) attributes.add("schedule");
        return "Cannot build InternalScheduleValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCapabilityStatementValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCapabilityStatementValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCapabilityStatementValue", generator = "Immutables")
  @Immutable
  static final class InternalCapabilityStatementValue
      implements ResourceList.InternalCapabilityStatementValue {
    private final CapabilityStatement capabilityStatement;

    private InternalCapabilityStatementValue(CapabilityStatement capabilityStatement) {
      this.capabilityStatement = capabilityStatement;
    }

    /**
     * @return The value of the {@code capabilityStatement} attribute
     */
    @JsonProperty("capabilityStatement")
    @JsonValue
    @Override
    public CapabilityStatement capabilityStatement() {
      return capabilityStatement;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCapabilityStatementValue#capabilityStatement() capabilityStatement} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for capabilityStatement
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCapabilityStatementValue withCapabilityStatement(CapabilityStatement value) {
      if (this.capabilityStatement == value) return this;
      CapabilityStatement newValue = Objects.requireNonNull(value, "capabilityStatement");
      return new ImmutableResourceList.InternalCapabilityStatementValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCapabilityStatementValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCapabilityStatementValue
          && equalTo((ImmutableResourceList.InternalCapabilityStatementValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCapabilityStatementValue another) {
      return capabilityStatement.equals(another.capabilityStatement);
    }

    /**
     * Computes a hash code from attributes: {@code capabilityStatement}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + capabilityStatement.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCapabilityStatementValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCapabilityStatementValue{"
          + "capabilityStatement=" + capabilityStatement
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCapabilityStatementValue fromJson(CapabilityStatement jsonValue) {
      ImmutableResourceList.InternalCapabilityStatementValue.Builder builder = ImmutableResourceList.InternalCapabilityStatementValue.builder();
      builder.capabilityStatement(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCapabilityStatementValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCapabilityStatementValue instance
     */
    public static ImmutableResourceList.InternalCapabilityStatementValue copyOf(ResourceList.InternalCapabilityStatementValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCapabilityStatementValue) {
        return (ImmutableResourceList.InternalCapabilityStatementValue) instance;
      }
      return ImmutableResourceList.InternalCapabilityStatementValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCapabilityStatementValue InternalCapabilityStatementValue}.
     * <pre>
     * ImmutableResourceList.InternalCapabilityStatementValue.builder()
     *    .capabilityStatement(com.fhir.types.fhir.CapabilityStatement) // required {@link ResourceList.InternalCapabilityStatementValue#capabilityStatement() capabilityStatement}
     *    .build();
     * </pre>
     * @return A new InternalCapabilityStatementValue builder
     */
    public static ImmutableResourceList.InternalCapabilityStatementValue.Builder builder() {
      return new ImmutableResourceList.InternalCapabilityStatementValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCapabilityStatementValue InternalCapabilityStatementValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCapabilityStatementValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CAPABILITY_STATEMENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable CapabilityStatement capabilityStatement;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCapabilityStatementValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCapabilityStatementValue instance) {
        Objects.requireNonNull(instance, "instance");
        capabilityStatement(instance.capabilityStatement());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCapabilityStatementValue#capabilityStatement() capabilityStatement} attribute.
       * @param capabilityStatement The value for capabilityStatement 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("capabilityStatement")
      public final Builder capabilityStatement(CapabilityStatement capabilityStatement) {
        this.capabilityStatement = Objects.requireNonNull(capabilityStatement, "capabilityStatement");
        initBits &= ~INIT_BIT_CAPABILITY_STATEMENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCapabilityStatementValue InternalCapabilityStatementValue}.
       * @return An immutable instance of InternalCapabilityStatementValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCapabilityStatementValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCapabilityStatementValue(capabilityStatement);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CAPABILITY_STATEMENT) != 0) attributes.add("capabilityStatement");
        return "Cannot build InternalCapabilityStatementValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductPackagedValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductPackagedValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductPackagedValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductPackagedValue
      implements ResourceList.InternalMedicinalProductPackagedValue {
    private final MedicinalProductPackaged medicinalProductPackaged;

    private InternalMedicinalProductPackagedValue(MedicinalProductPackaged medicinalProductPackaged) {
      this.medicinalProductPackaged = medicinalProductPackaged;
    }

    /**
     * @return The value of the {@code medicinalProductPackaged} attribute
     */
    @JsonProperty("medicinalProductPackaged")
    @JsonValue
    @Override
    public MedicinalProductPackaged medicinalProductPackaged() {
      return medicinalProductPackaged;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductPackagedValue#medicinalProductPackaged() medicinalProductPackaged} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProductPackaged
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductPackagedValue withMedicinalProductPackaged(MedicinalProductPackaged value) {
      if (this.medicinalProductPackaged == value) return this;
      MedicinalProductPackaged newValue = Objects.requireNonNull(value, "medicinalProductPackaged");
      return new ImmutableResourceList.InternalMedicinalProductPackagedValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductPackagedValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductPackagedValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductPackagedValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductPackagedValue another) {
      return medicinalProductPackaged.equals(another.medicinalProductPackaged);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProductPackaged}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProductPackaged.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductPackagedValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductPackagedValue{"
          + "medicinalProductPackaged=" + medicinalProductPackaged
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductPackagedValue fromJson(MedicinalProductPackaged jsonValue) {
      ImmutableResourceList.InternalMedicinalProductPackagedValue.Builder builder = ImmutableResourceList.InternalMedicinalProductPackagedValue.builder();
      builder.medicinalProductPackaged(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductPackagedValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductPackagedValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductPackagedValue copyOf(ResourceList.InternalMedicinalProductPackagedValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductPackagedValue) {
        return (ImmutableResourceList.InternalMedicinalProductPackagedValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductPackagedValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductPackagedValue InternalMedicinalProductPackagedValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductPackagedValue.builder()
     *    .medicinalProductPackaged(com.fhir.types.fhir.MedicinalProductPackaged) // required {@link ResourceList.InternalMedicinalProductPackagedValue#medicinalProductPackaged() medicinalProductPackaged}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductPackagedValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductPackagedValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductPackagedValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductPackagedValue InternalMedicinalProductPackagedValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductPackagedValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT_PACKAGED = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProductPackaged medicinalProductPackaged;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductPackagedValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductPackagedValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProductPackaged(instance.medicinalProductPackaged());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductPackagedValue#medicinalProductPackaged() medicinalProductPackaged} attribute.
       * @param medicinalProductPackaged The value for medicinalProductPackaged 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProductPackaged")
      public final Builder medicinalProductPackaged(MedicinalProductPackaged medicinalProductPackaged) {
        this.medicinalProductPackaged = Objects.requireNonNull(medicinalProductPackaged, "medicinalProductPackaged");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT_PACKAGED;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductPackagedValue InternalMedicinalProductPackagedValue}.
       * @return An immutable instance of InternalMedicinalProductPackagedValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductPackagedValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductPackagedValue(medicinalProductPackaged);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT_PACKAGED) != 0) attributes.add("medicinalProductPackaged");
        return "Cannot build InternalMedicinalProductPackagedValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductIngredientValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductIngredientValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductIngredientValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductIngredientValue
      implements ResourceList.InternalMedicinalProductIngredientValue {
    private final MedicinalProductIngredient medicinalProductIngredient;

    private InternalMedicinalProductIngredientValue(MedicinalProductIngredient medicinalProductIngredient) {
      this.medicinalProductIngredient = medicinalProductIngredient;
    }

    /**
     * @return The value of the {@code medicinalProductIngredient} attribute
     */
    @JsonProperty("medicinalProductIngredient")
    @JsonValue
    @Override
    public MedicinalProductIngredient medicinalProductIngredient() {
      return medicinalProductIngredient;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductIngredientValue#medicinalProductIngredient() medicinalProductIngredient} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProductIngredient
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductIngredientValue withMedicinalProductIngredient(MedicinalProductIngredient value) {
      if (this.medicinalProductIngredient == value) return this;
      MedicinalProductIngredient newValue = Objects.requireNonNull(value, "medicinalProductIngredient");
      return new ImmutableResourceList.InternalMedicinalProductIngredientValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductIngredientValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductIngredientValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductIngredientValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductIngredientValue another) {
      return medicinalProductIngredient.equals(another.medicinalProductIngredient);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProductIngredient}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProductIngredient.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductIngredientValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductIngredientValue{"
          + "medicinalProductIngredient=" + medicinalProductIngredient
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductIngredientValue fromJson(MedicinalProductIngredient jsonValue) {
      ImmutableResourceList.InternalMedicinalProductIngredientValue.Builder builder = ImmutableResourceList.InternalMedicinalProductIngredientValue.builder();
      builder.medicinalProductIngredient(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductIngredientValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductIngredientValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductIngredientValue copyOf(ResourceList.InternalMedicinalProductIngredientValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductIngredientValue) {
        return (ImmutableResourceList.InternalMedicinalProductIngredientValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductIngredientValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductIngredientValue InternalMedicinalProductIngredientValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductIngredientValue.builder()
     *    .medicinalProductIngredient(com.fhir.types.fhir.MedicinalProductIngredient) // required {@link ResourceList.InternalMedicinalProductIngredientValue#medicinalProductIngredient() medicinalProductIngredient}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductIngredientValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductIngredientValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductIngredientValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductIngredientValue InternalMedicinalProductIngredientValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductIngredientValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT_INGREDIENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProductIngredient medicinalProductIngredient;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductIngredientValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductIngredientValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProductIngredient(instance.medicinalProductIngredient());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductIngredientValue#medicinalProductIngredient() medicinalProductIngredient} attribute.
       * @param medicinalProductIngredient The value for medicinalProductIngredient 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProductIngredient")
      public final Builder medicinalProductIngredient(MedicinalProductIngredient medicinalProductIngredient) {
        this.medicinalProductIngredient = Objects.requireNonNull(medicinalProductIngredient, "medicinalProductIngredient");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT_INGREDIENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductIngredientValue InternalMedicinalProductIngredientValue}.
       * @return An immutable instance of InternalMedicinalProductIngredientValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductIngredientValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductIngredientValue(medicinalProductIngredient);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT_INGREDIENT) != 0) attributes.add("medicinalProductIngredient");
        return "Cannot build InternalMedicinalProductIngredientValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalGroupValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalGroupValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalGroupValue", generator = "Immutables")
  @Immutable
  static final class InternalGroupValue implements ResourceList.InternalGroupValue {
    private final Group group;

    private InternalGroupValue(Group group) {
      this.group = group;
    }

    /**
     * @return The value of the {@code group} attribute
     */
    @JsonProperty("group")
    @JsonValue
    @Override
    public Group group() {
      return group;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalGroupValue#group() group} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for group
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalGroupValue withGroup(Group value) {
      if (this.group == value) return this;
      Group newValue = Objects.requireNonNull(value, "group");
      return new ImmutableResourceList.InternalGroupValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalGroupValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalGroupValue
          && equalTo((ImmutableResourceList.InternalGroupValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalGroupValue another) {
      return group.equals(another.group);
    }

    /**
     * Computes a hash code from attributes: {@code group}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + group.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalGroupValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalGroupValue{"
          + "group=" + group
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalGroupValue fromJson(Group jsonValue) {
      ImmutableResourceList.InternalGroupValue.Builder builder = ImmutableResourceList.InternalGroupValue.builder();
      builder.group(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalGroupValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalGroupValue instance
     */
    public static ImmutableResourceList.InternalGroupValue copyOf(ResourceList.InternalGroupValue instance) {
      if (instance instanceof ImmutableResourceList.InternalGroupValue) {
        return (ImmutableResourceList.InternalGroupValue) instance;
      }
      return ImmutableResourceList.InternalGroupValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalGroupValue InternalGroupValue}.
     * <pre>
     * ImmutableResourceList.InternalGroupValue.builder()
     *    .group(com.fhir.types.fhir.Group) // required {@link ResourceList.InternalGroupValue#group() group}
     *    .build();
     * </pre>
     * @return A new InternalGroupValue builder
     */
    public static ImmutableResourceList.InternalGroupValue.Builder builder() {
      return new ImmutableResourceList.InternalGroupValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalGroupValue InternalGroupValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalGroupValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_GROUP = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Group group;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalGroupValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalGroupValue instance) {
        Objects.requireNonNull(instance, "instance");
        group(instance.group());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalGroupValue#group() group} attribute.
       * @param group The value for group 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("group")
      public final Builder group(Group group) {
        this.group = Objects.requireNonNull(group, "group");
        initBits &= ~INIT_BIT_GROUP;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalGroupValue InternalGroupValue}.
       * @return An immutable instance of InternalGroupValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalGroupValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalGroupValue(group);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_GROUP) != 0) attributes.add("group");
        return "Cannot build InternalGroupValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMediaValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMediaValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMediaValue", generator = "Immutables")
  @Immutable
  static final class InternalMediaValue implements ResourceList.InternalMediaValue {
    private final Media media;

    private InternalMediaValue(Media media) {
      this.media = media;
    }

    /**
     * @return The value of the {@code media} attribute
     */
    @JsonProperty("media")
    @JsonValue
    @Override
    public Media media() {
      return media;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMediaValue#media() media} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for media
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMediaValue withMedia(Media value) {
      if (this.media == value) return this;
      Media newValue = Objects.requireNonNull(value, "media");
      return new ImmutableResourceList.InternalMediaValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMediaValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMediaValue
          && equalTo((ImmutableResourceList.InternalMediaValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMediaValue another) {
      return media.equals(another.media);
    }

    /**
     * Computes a hash code from attributes: {@code media}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + media.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMediaValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMediaValue{"
          + "media=" + media
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMediaValue fromJson(Media jsonValue) {
      ImmutableResourceList.InternalMediaValue.Builder builder = ImmutableResourceList.InternalMediaValue.builder();
      builder.media(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMediaValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMediaValue instance
     */
    public static ImmutableResourceList.InternalMediaValue copyOf(ResourceList.InternalMediaValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMediaValue) {
        return (ImmutableResourceList.InternalMediaValue) instance;
      }
      return ImmutableResourceList.InternalMediaValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMediaValue InternalMediaValue}.
     * <pre>
     * ImmutableResourceList.InternalMediaValue.builder()
     *    .media(com.fhir.types.fhir.Media) // required {@link ResourceList.InternalMediaValue#media() media}
     *    .build();
     * </pre>
     * @return A new InternalMediaValue builder
     */
    public static ImmutableResourceList.InternalMediaValue.Builder builder() {
      return new ImmutableResourceList.InternalMediaValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMediaValue InternalMediaValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMediaValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDIA = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Media media;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMediaValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMediaValue instance) {
        Objects.requireNonNull(instance, "instance");
        media(instance.media());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMediaValue#media() media} attribute.
       * @param media The value for media 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("media")
      public final Builder media(Media media) {
        this.media = Objects.requireNonNull(media, "media");
        initBits &= ~INIT_BIT_MEDIA;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMediaValue InternalMediaValue}.
       * @return An immutable instance of InternalMediaValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMediaValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMediaValue(media);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDIA) != 0) attributes.add("media");
        return "Cannot build InternalMediaValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalPaymentReconciliationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalPaymentReconciliationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalPaymentReconciliationValue", generator = "Immutables")
  @Immutable
  static final class InternalPaymentReconciliationValue
      implements ResourceList.InternalPaymentReconciliationValue {
    private final PaymentReconciliation paymentReconciliation;

    private InternalPaymentReconciliationValue(PaymentReconciliation paymentReconciliation) {
      this.paymentReconciliation = paymentReconciliation;
    }

    /**
     * @return The value of the {@code paymentReconciliation} attribute
     */
    @JsonProperty("paymentReconciliation")
    @JsonValue
    @Override
    public PaymentReconciliation paymentReconciliation() {
      return paymentReconciliation;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalPaymentReconciliationValue#paymentReconciliation() paymentReconciliation} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for paymentReconciliation
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalPaymentReconciliationValue withPaymentReconciliation(PaymentReconciliation value) {
      if (this.paymentReconciliation == value) return this;
      PaymentReconciliation newValue = Objects.requireNonNull(value, "paymentReconciliation");
      return new ImmutableResourceList.InternalPaymentReconciliationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalPaymentReconciliationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalPaymentReconciliationValue
          && equalTo((ImmutableResourceList.InternalPaymentReconciliationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalPaymentReconciliationValue another) {
      return paymentReconciliation.equals(another.paymentReconciliation);
    }

    /**
     * Computes a hash code from attributes: {@code paymentReconciliation}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + paymentReconciliation.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalPaymentReconciliationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalPaymentReconciliationValue{"
          + "paymentReconciliation=" + paymentReconciliation
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalPaymentReconciliationValue fromJson(PaymentReconciliation jsonValue) {
      ImmutableResourceList.InternalPaymentReconciliationValue.Builder builder = ImmutableResourceList.InternalPaymentReconciliationValue.builder();
      builder.paymentReconciliation(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalPaymentReconciliationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalPaymentReconciliationValue instance
     */
    public static ImmutableResourceList.InternalPaymentReconciliationValue copyOf(ResourceList.InternalPaymentReconciliationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalPaymentReconciliationValue) {
        return (ImmutableResourceList.InternalPaymentReconciliationValue) instance;
      }
      return ImmutableResourceList.InternalPaymentReconciliationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalPaymentReconciliationValue InternalPaymentReconciliationValue}.
     * <pre>
     * ImmutableResourceList.InternalPaymentReconciliationValue.builder()
     *    .paymentReconciliation(com.fhir.types.fhir.PaymentReconciliation) // required {@link ResourceList.InternalPaymentReconciliationValue#paymentReconciliation() paymentReconciliation}
     *    .build();
     * </pre>
     * @return A new InternalPaymentReconciliationValue builder
     */
    public static ImmutableResourceList.InternalPaymentReconciliationValue.Builder builder() {
      return new ImmutableResourceList.InternalPaymentReconciliationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalPaymentReconciliationValue InternalPaymentReconciliationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalPaymentReconciliationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PAYMENT_RECONCILIATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable PaymentReconciliation paymentReconciliation;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalPaymentReconciliationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalPaymentReconciliationValue instance) {
        Objects.requireNonNull(instance, "instance");
        paymentReconciliation(instance.paymentReconciliation());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalPaymentReconciliationValue#paymentReconciliation() paymentReconciliation} attribute.
       * @param paymentReconciliation The value for paymentReconciliation 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("paymentReconciliation")
      public final Builder paymentReconciliation(PaymentReconciliation paymentReconciliation) {
        this.paymentReconciliation = Objects.requireNonNull(paymentReconciliation, "paymentReconciliation");
        initBits &= ~INIT_BIT_PAYMENT_RECONCILIATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalPaymentReconciliationValue InternalPaymentReconciliationValue}.
       * @return An immutable instance of InternalPaymentReconciliationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalPaymentReconciliationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalPaymentReconciliationValue(paymentReconciliation);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PAYMENT_RECONCILIATION) != 0) attributes.add("paymentReconciliation");
        return "Cannot build InternalPaymentReconciliationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalEnrollmentRequestValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalEnrollmentRequestValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalEnrollmentRequestValue", generator = "Immutables")
  @Immutable
  static final class InternalEnrollmentRequestValue
      implements ResourceList.InternalEnrollmentRequestValue {
    private final EnrollmentRequest enrollmentRequest;

    private InternalEnrollmentRequestValue(EnrollmentRequest enrollmentRequest) {
      this.enrollmentRequest = enrollmentRequest;
    }

    /**
     * @return The value of the {@code enrollmentRequest} attribute
     */
    @JsonProperty("enrollmentRequest")
    @JsonValue
    @Override
    public EnrollmentRequest enrollmentRequest() {
      return enrollmentRequest;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalEnrollmentRequestValue#enrollmentRequest() enrollmentRequest} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for enrollmentRequest
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalEnrollmentRequestValue withEnrollmentRequest(EnrollmentRequest value) {
      if (this.enrollmentRequest == value) return this;
      EnrollmentRequest newValue = Objects.requireNonNull(value, "enrollmentRequest");
      return new ImmutableResourceList.InternalEnrollmentRequestValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalEnrollmentRequestValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalEnrollmentRequestValue
          && equalTo((ImmutableResourceList.InternalEnrollmentRequestValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalEnrollmentRequestValue another) {
      return enrollmentRequest.equals(another.enrollmentRequest);
    }

    /**
     * Computes a hash code from attributes: {@code enrollmentRequest}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + enrollmentRequest.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalEnrollmentRequestValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalEnrollmentRequestValue{"
          + "enrollmentRequest=" + enrollmentRequest
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalEnrollmentRequestValue fromJson(EnrollmentRequest jsonValue) {
      ImmutableResourceList.InternalEnrollmentRequestValue.Builder builder = ImmutableResourceList.InternalEnrollmentRequestValue.builder();
      builder.enrollmentRequest(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalEnrollmentRequestValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalEnrollmentRequestValue instance
     */
    public static ImmutableResourceList.InternalEnrollmentRequestValue copyOf(ResourceList.InternalEnrollmentRequestValue instance) {
      if (instance instanceof ImmutableResourceList.InternalEnrollmentRequestValue) {
        return (ImmutableResourceList.InternalEnrollmentRequestValue) instance;
      }
      return ImmutableResourceList.InternalEnrollmentRequestValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalEnrollmentRequestValue InternalEnrollmentRequestValue}.
     * <pre>
     * ImmutableResourceList.InternalEnrollmentRequestValue.builder()
     *    .enrollmentRequest(com.fhir.types.fhir.EnrollmentRequest) // required {@link ResourceList.InternalEnrollmentRequestValue#enrollmentRequest() enrollmentRequest}
     *    .build();
     * </pre>
     * @return A new InternalEnrollmentRequestValue builder
     */
    public static ImmutableResourceList.InternalEnrollmentRequestValue.Builder builder() {
      return new ImmutableResourceList.InternalEnrollmentRequestValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalEnrollmentRequestValue InternalEnrollmentRequestValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalEnrollmentRequestValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ENROLLMENT_REQUEST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable EnrollmentRequest enrollmentRequest;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalEnrollmentRequestValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalEnrollmentRequestValue instance) {
        Objects.requireNonNull(instance, "instance");
        enrollmentRequest(instance.enrollmentRequest());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalEnrollmentRequestValue#enrollmentRequest() enrollmentRequest} attribute.
       * @param enrollmentRequest The value for enrollmentRequest 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("enrollmentRequest")
      public final Builder enrollmentRequest(EnrollmentRequest enrollmentRequest) {
        this.enrollmentRequest = Objects.requireNonNull(enrollmentRequest, "enrollmentRequest");
        initBits &= ~INIT_BIT_ENROLLMENT_REQUEST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalEnrollmentRequestValue InternalEnrollmentRequestValue}.
       * @return An immutable instance of InternalEnrollmentRequestValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalEnrollmentRequestValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalEnrollmentRequestValue(enrollmentRequest);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ENROLLMENT_REQUEST) != 0) attributes.add("enrollmentRequest");
        return "Cannot build InternalEnrollmentRequestValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCareTeamValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCareTeamValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCareTeamValue", generator = "Immutables")
  @Immutable
  static final class InternalCareTeamValue implements ResourceList.InternalCareTeamValue {
    private final CareTeam careTeam;

    private InternalCareTeamValue(CareTeam careTeam) {
      this.careTeam = careTeam;
    }

    /**
     * @return The value of the {@code careTeam} attribute
     */
    @JsonProperty("careTeam")
    @JsonValue
    @Override
    public CareTeam careTeam() {
      return careTeam;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCareTeamValue#careTeam() careTeam} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for careTeam
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCareTeamValue withCareTeam(CareTeam value) {
      if (this.careTeam == value) return this;
      CareTeam newValue = Objects.requireNonNull(value, "careTeam");
      return new ImmutableResourceList.InternalCareTeamValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCareTeamValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCareTeamValue
          && equalTo((ImmutableResourceList.InternalCareTeamValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCareTeamValue another) {
      return careTeam.equals(another.careTeam);
    }

    /**
     * Computes a hash code from attributes: {@code careTeam}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + careTeam.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCareTeamValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCareTeamValue{"
          + "careTeam=" + careTeam
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCareTeamValue fromJson(CareTeam jsonValue) {
      ImmutableResourceList.InternalCareTeamValue.Builder builder = ImmutableResourceList.InternalCareTeamValue.builder();
      builder.careTeam(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCareTeamValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCareTeamValue instance
     */
    public static ImmutableResourceList.InternalCareTeamValue copyOf(ResourceList.InternalCareTeamValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCareTeamValue) {
        return (ImmutableResourceList.InternalCareTeamValue) instance;
      }
      return ImmutableResourceList.InternalCareTeamValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCareTeamValue InternalCareTeamValue}.
     * <pre>
     * ImmutableResourceList.InternalCareTeamValue.builder()
     *    .careTeam(com.fhir.types.fhir.CareTeam) // required {@link ResourceList.InternalCareTeamValue#careTeam() careTeam}
     *    .build();
     * </pre>
     * @return A new InternalCareTeamValue builder
     */
    public static ImmutableResourceList.InternalCareTeamValue.Builder builder() {
      return new ImmutableResourceList.InternalCareTeamValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCareTeamValue InternalCareTeamValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCareTeamValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CARE_TEAM = 0x1L;
      private long initBits = 0x1L;

      private @Nullable CareTeam careTeam;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCareTeamValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCareTeamValue instance) {
        Objects.requireNonNull(instance, "instance");
        careTeam(instance.careTeam());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCareTeamValue#careTeam() careTeam} attribute.
       * @param careTeam The value for careTeam 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("careTeam")
      public final Builder careTeam(CareTeam careTeam) {
        this.careTeam = Objects.requireNonNull(careTeam, "careTeam");
        initBits &= ~INIT_BIT_CARE_TEAM;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCareTeamValue InternalCareTeamValue}.
       * @return An immutable instance of InternalCareTeamValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCareTeamValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCareTeamValue(careTeam);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CARE_TEAM) != 0) attributes.add("careTeam");
        return "Cannot build InternalCareTeamValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalInvoiceValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalInvoiceValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalInvoiceValue", generator = "Immutables")
  @Immutable
  static final class InternalInvoiceValue implements ResourceList.InternalInvoiceValue {
    private final Invoice invoice;

    private InternalInvoiceValue(Invoice invoice) {
      this.invoice = invoice;
    }

    /**
     * @return The value of the {@code invoice} attribute
     */
    @JsonProperty("invoice")
    @JsonValue
    @Override
    public Invoice invoice() {
      return invoice;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalInvoiceValue#invoice() invoice} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for invoice
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalInvoiceValue withInvoice(Invoice value) {
      if (this.invoice == value) return this;
      Invoice newValue = Objects.requireNonNull(value, "invoice");
      return new ImmutableResourceList.InternalInvoiceValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalInvoiceValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalInvoiceValue
          && equalTo((ImmutableResourceList.InternalInvoiceValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalInvoiceValue another) {
      return invoice.equals(another.invoice);
    }

    /**
     * Computes a hash code from attributes: {@code invoice}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + invoice.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalInvoiceValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalInvoiceValue{"
          + "invoice=" + invoice
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalInvoiceValue fromJson(Invoice jsonValue) {
      ImmutableResourceList.InternalInvoiceValue.Builder builder = ImmutableResourceList.InternalInvoiceValue.builder();
      builder.invoice(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalInvoiceValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalInvoiceValue instance
     */
    public static ImmutableResourceList.InternalInvoiceValue copyOf(ResourceList.InternalInvoiceValue instance) {
      if (instance instanceof ImmutableResourceList.InternalInvoiceValue) {
        return (ImmutableResourceList.InternalInvoiceValue) instance;
      }
      return ImmutableResourceList.InternalInvoiceValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalInvoiceValue InternalInvoiceValue}.
     * <pre>
     * ImmutableResourceList.InternalInvoiceValue.builder()
     *    .invoice(com.fhir.types.fhir.Invoice) // required {@link ResourceList.InternalInvoiceValue#invoice() invoice}
     *    .build();
     * </pre>
     * @return A new InternalInvoiceValue builder
     */
    public static ImmutableResourceList.InternalInvoiceValue.Builder builder() {
      return new ImmutableResourceList.InternalInvoiceValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalInvoiceValue InternalInvoiceValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalInvoiceValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_INVOICE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Invoice invoice;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalInvoiceValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalInvoiceValue instance) {
        Objects.requireNonNull(instance, "instance");
        invoice(instance.invoice());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalInvoiceValue#invoice() invoice} attribute.
       * @param invoice The value for invoice 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("invoice")
      public final Builder invoice(Invoice invoice) {
        this.invoice = Objects.requireNonNull(invoice, "invoice");
        initBits &= ~INIT_BIT_INVOICE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalInvoiceValue InternalInvoiceValue}.
       * @return An immutable instance of InternalInvoiceValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalInvoiceValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalInvoiceValue(invoice);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_INVOICE) != 0) attributes.add("invoice");
        return "Cannot build InternalInvoiceValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalTestScriptValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalTestScriptValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalTestScriptValue", generator = "Immutables")
  @Immutable
  static final class InternalTestScriptValue
      implements ResourceList.InternalTestScriptValue {
    private final TestScript testScript;

    private InternalTestScriptValue(TestScript testScript) {
      this.testScript = testScript;
    }

    /**
     * @return The value of the {@code testScript} attribute
     */
    @JsonProperty("testScript")
    @JsonValue
    @Override
    public TestScript testScript() {
      return testScript;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalTestScriptValue#testScript() testScript} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for testScript
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalTestScriptValue withTestScript(TestScript value) {
      if (this.testScript == value) return this;
      TestScript newValue = Objects.requireNonNull(value, "testScript");
      return new ImmutableResourceList.InternalTestScriptValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalTestScriptValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalTestScriptValue
          && equalTo((ImmutableResourceList.InternalTestScriptValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalTestScriptValue another) {
      return testScript.equals(another.testScript);
    }

    /**
     * Computes a hash code from attributes: {@code testScript}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + testScript.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalTestScriptValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalTestScriptValue{"
          + "testScript=" + testScript
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalTestScriptValue fromJson(TestScript jsonValue) {
      ImmutableResourceList.InternalTestScriptValue.Builder builder = ImmutableResourceList.InternalTestScriptValue.builder();
      builder.testScript(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalTestScriptValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalTestScriptValue instance
     */
    public static ImmutableResourceList.InternalTestScriptValue copyOf(ResourceList.InternalTestScriptValue instance) {
      if (instance instanceof ImmutableResourceList.InternalTestScriptValue) {
        return (ImmutableResourceList.InternalTestScriptValue) instance;
      }
      return ImmutableResourceList.InternalTestScriptValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalTestScriptValue InternalTestScriptValue}.
     * <pre>
     * ImmutableResourceList.InternalTestScriptValue.builder()
     *    .testScript(com.fhir.types.fhir.TestScript) // required {@link ResourceList.InternalTestScriptValue#testScript() testScript}
     *    .build();
     * </pre>
     * @return A new InternalTestScriptValue builder
     */
    public static ImmutableResourceList.InternalTestScriptValue.Builder builder() {
      return new ImmutableResourceList.InternalTestScriptValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalTestScriptValue InternalTestScriptValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalTestScriptValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_TEST_SCRIPT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable TestScript testScript;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalTestScriptValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalTestScriptValue instance) {
        Objects.requireNonNull(instance, "instance");
        testScript(instance.testScript());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalTestScriptValue#testScript() testScript} attribute.
       * @param testScript The value for testScript 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("testScript")
      public final Builder testScript(TestScript testScript) {
        this.testScript = Objects.requireNonNull(testScript, "testScript");
        initBits &= ~INIT_BIT_TEST_SCRIPT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalTestScriptValue InternalTestScriptValue}.
       * @return An immutable instance of InternalTestScriptValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalTestScriptValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalTestScriptValue(testScript);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_TEST_SCRIPT) != 0) attributes.add("testScript");
        return "Cannot build InternalTestScriptValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalEncounterValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalEncounterValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalEncounterValue", generator = "Immutables")
  @Immutable
  static final class InternalEncounterValue implements ResourceList.InternalEncounterValue {
    private final Encounter encounter;

    private InternalEncounterValue(Encounter encounter) {
      this.encounter = encounter;
    }

    /**
     * @return The value of the {@code encounter} attribute
     */
    @JsonProperty("encounter")
    @JsonValue
    @Override
    public Encounter encounter() {
      return encounter;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalEncounterValue#encounter() encounter} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for encounter
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalEncounterValue withEncounter(Encounter value) {
      if (this.encounter == value) return this;
      Encounter newValue = Objects.requireNonNull(value, "encounter");
      return new ImmutableResourceList.InternalEncounterValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalEncounterValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalEncounterValue
          && equalTo((ImmutableResourceList.InternalEncounterValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalEncounterValue another) {
      return encounter.equals(another.encounter);
    }

    /**
     * Computes a hash code from attributes: {@code encounter}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + encounter.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalEncounterValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalEncounterValue{"
          + "encounter=" + encounter
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalEncounterValue fromJson(Encounter jsonValue) {
      ImmutableResourceList.InternalEncounterValue.Builder builder = ImmutableResourceList.InternalEncounterValue.builder();
      builder.encounter(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalEncounterValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalEncounterValue instance
     */
    public static ImmutableResourceList.InternalEncounterValue copyOf(ResourceList.InternalEncounterValue instance) {
      if (instance instanceof ImmutableResourceList.InternalEncounterValue) {
        return (ImmutableResourceList.InternalEncounterValue) instance;
      }
      return ImmutableResourceList.InternalEncounterValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalEncounterValue InternalEncounterValue}.
     * <pre>
     * ImmutableResourceList.InternalEncounterValue.builder()
     *    .encounter(com.fhir.types.fhir.Encounter) // required {@link ResourceList.InternalEncounterValue#encounter() encounter}
     *    .build();
     * </pre>
     * @return A new InternalEncounterValue builder
     */
    public static ImmutableResourceList.InternalEncounterValue.Builder builder() {
      return new ImmutableResourceList.InternalEncounterValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalEncounterValue InternalEncounterValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalEncounterValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ENCOUNTER = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Encounter encounter;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalEncounterValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalEncounterValue instance) {
        Objects.requireNonNull(instance, "instance");
        encounter(instance.encounter());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalEncounterValue#encounter() encounter} attribute.
       * @param encounter The value for encounter 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("encounter")
      public final Builder encounter(Encounter encounter) {
        this.encounter = Objects.requireNonNull(encounter, "encounter");
        initBits &= ~INIT_BIT_ENCOUNTER;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalEncounterValue InternalEncounterValue}.
       * @return An immutable instance of InternalEncounterValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalEncounterValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalEncounterValue(encounter);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ENCOUNTER) != 0) attributes.add("encounter");
        return "Cannot build InternalEncounterValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalAllergyIntoleranceValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalAllergyIntoleranceValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalAllergyIntoleranceValue", generator = "Immutables")
  @Immutable
  static final class InternalAllergyIntoleranceValue
      implements ResourceList.InternalAllergyIntoleranceValue {
    private final AllergyIntolerance allergyIntolerance;

    private InternalAllergyIntoleranceValue(AllergyIntolerance allergyIntolerance) {
      this.allergyIntolerance = allergyIntolerance;
    }

    /**
     * @return The value of the {@code allergyIntolerance} attribute
     */
    @JsonProperty("allergyIntolerance")
    @JsonValue
    @Override
    public AllergyIntolerance allergyIntolerance() {
      return allergyIntolerance;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalAllergyIntoleranceValue#allergyIntolerance() allergyIntolerance} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for allergyIntolerance
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalAllergyIntoleranceValue withAllergyIntolerance(AllergyIntolerance value) {
      if (this.allergyIntolerance == value) return this;
      AllergyIntolerance newValue = Objects.requireNonNull(value, "allergyIntolerance");
      return new ImmutableResourceList.InternalAllergyIntoleranceValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalAllergyIntoleranceValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalAllergyIntoleranceValue
          && equalTo((ImmutableResourceList.InternalAllergyIntoleranceValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalAllergyIntoleranceValue another) {
      return allergyIntolerance.equals(another.allergyIntolerance);
    }

    /**
     * Computes a hash code from attributes: {@code allergyIntolerance}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + allergyIntolerance.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalAllergyIntoleranceValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalAllergyIntoleranceValue{"
          + "allergyIntolerance=" + allergyIntolerance
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalAllergyIntoleranceValue fromJson(AllergyIntolerance jsonValue) {
      ImmutableResourceList.InternalAllergyIntoleranceValue.Builder builder = ImmutableResourceList.InternalAllergyIntoleranceValue.builder();
      builder.allergyIntolerance(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalAllergyIntoleranceValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalAllergyIntoleranceValue instance
     */
    public static ImmutableResourceList.InternalAllergyIntoleranceValue copyOf(ResourceList.InternalAllergyIntoleranceValue instance) {
      if (instance instanceof ImmutableResourceList.InternalAllergyIntoleranceValue) {
        return (ImmutableResourceList.InternalAllergyIntoleranceValue) instance;
      }
      return ImmutableResourceList.InternalAllergyIntoleranceValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalAllergyIntoleranceValue InternalAllergyIntoleranceValue}.
     * <pre>
     * ImmutableResourceList.InternalAllergyIntoleranceValue.builder()
     *    .allergyIntolerance(com.fhir.types.fhir.AllergyIntolerance) // required {@link ResourceList.InternalAllergyIntoleranceValue#allergyIntolerance() allergyIntolerance}
     *    .build();
     * </pre>
     * @return A new InternalAllergyIntoleranceValue builder
     */
    public static ImmutableResourceList.InternalAllergyIntoleranceValue.Builder builder() {
      return new ImmutableResourceList.InternalAllergyIntoleranceValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalAllergyIntoleranceValue InternalAllergyIntoleranceValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalAllergyIntoleranceValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ALLERGY_INTOLERANCE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable AllergyIntolerance allergyIntolerance;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalAllergyIntoleranceValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalAllergyIntoleranceValue instance) {
        Objects.requireNonNull(instance, "instance");
        allergyIntolerance(instance.allergyIntolerance());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalAllergyIntoleranceValue#allergyIntolerance() allergyIntolerance} attribute.
       * @param allergyIntolerance The value for allergyIntolerance 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("allergyIntolerance")
      public final Builder allergyIntolerance(AllergyIntolerance allergyIntolerance) {
        this.allergyIntolerance = Objects.requireNonNull(allergyIntolerance, "allergyIntolerance");
        initBits &= ~INIT_BIT_ALLERGY_INTOLERANCE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalAllergyIntoleranceValue InternalAllergyIntoleranceValue}.
       * @return An immutable instance of InternalAllergyIntoleranceValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalAllergyIntoleranceValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalAllergyIntoleranceValue(allergyIntolerance);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ALLERGY_INTOLERANCE) != 0) attributes.add("allergyIntolerance");
        return "Cannot build InternalAllergyIntoleranceValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalEnrollmentResponseValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalEnrollmentResponseValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalEnrollmentResponseValue", generator = "Immutables")
  @Immutable
  static final class InternalEnrollmentResponseValue
      implements ResourceList.InternalEnrollmentResponseValue {
    private final EnrollmentResponse enrollmentResponse;

    private InternalEnrollmentResponseValue(EnrollmentResponse enrollmentResponse) {
      this.enrollmentResponse = enrollmentResponse;
    }

    /**
     * @return The value of the {@code enrollmentResponse} attribute
     */
    @JsonProperty("enrollmentResponse")
    @JsonValue
    @Override
    public EnrollmentResponse enrollmentResponse() {
      return enrollmentResponse;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalEnrollmentResponseValue#enrollmentResponse() enrollmentResponse} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for enrollmentResponse
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalEnrollmentResponseValue withEnrollmentResponse(EnrollmentResponse value) {
      if (this.enrollmentResponse == value) return this;
      EnrollmentResponse newValue = Objects.requireNonNull(value, "enrollmentResponse");
      return new ImmutableResourceList.InternalEnrollmentResponseValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalEnrollmentResponseValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalEnrollmentResponseValue
          && equalTo((ImmutableResourceList.InternalEnrollmentResponseValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalEnrollmentResponseValue another) {
      return enrollmentResponse.equals(another.enrollmentResponse);
    }

    /**
     * Computes a hash code from attributes: {@code enrollmentResponse}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + enrollmentResponse.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalEnrollmentResponseValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalEnrollmentResponseValue{"
          + "enrollmentResponse=" + enrollmentResponse
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalEnrollmentResponseValue fromJson(EnrollmentResponse jsonValue) {
      ImmutableResourceList.InternalEnrollmentResponseValue.Builder builder = ImmutableResourceList.InternalEnrollmentResponseValue.builder();
      builder.enrollmentResponse(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalEnrollmentResponseValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalEnrollmentResponseValue instance
     */
    public static ImmutableResourceList.InternalEnrollmentResponseValue copyOf(ResourceList.InternalEnrollmentResponseValue instance) {
      if (instance instanceof ImmutableResourceList.InternalEnrollmentResponseValue) {
        return (ImmutableResourceList.InternalEnrollmentResponseValue) instance;
      }
      return ImmutableResourceList.InternalEnrollmentResponseValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalEnrollmentResponseValue InternalEnrollmentResponseValue}.
     * <pre>
     * ImmutableResourceList.InternalEnrollmentResponseValue.builder()
     *    .enrollmentResponse(com.fhir.types.fhir.EnrollmentResponse) // required {@link ResourceList.InternalEnrollmentResponseValue#enrollmentResponse() enrollmentResponse}
     *    .build();
     * </pre>
     * @return A new InternalEnrollmentResponseValue builder
     */
    public static ImmutableResourceList.InternalEnrollmentResponseValue.Builder builder() {
      return new ImmutableResourceList.InternalEnrollmentResponseValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalEnrollmentResponseValue InternalEnrollmentResponseValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalEnrollmentResponseValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ENROLLMENT_RESPONSE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable EnrollmentResponse enrollmentResponse;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalEnrollmentResponseValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalEnrollmentResponseValue instance) {
        Objects.requireNonNull(instance, "instance");
        enrollmentResponse(instance.enrollmentResponse());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalEnrollmentResponseValue#enrollmentResponse() enrollmentResponse} attribute.
       * @param enrollmentResponse The value for enrollmentResponse 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("enrollmentResponse")
      public final Builder enrollmentResponse(EnrollmentResponse enrollmentResponse) {
        this.enrollmentResponse = Objects.requireNonNull(enrollmentResponse, "enrollmentResponse");
        initBits &= ~INIT_BIT_ENROLLMENT_RESPONSE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalEnrollmentResponseValue InternalEnrollmentResponseValue}.
       * @return An immutable instance of InternalEnrollmentResponseValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalEnrollmentResponseValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalEnrollmentResponseValue(enrollmentResponse);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ENROLLMENT_RESPONSE) != 0) attributes.add("enrollmentResponse");
        return "Cannot build InternalEnrollmentResponseValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalHealthcareServiceValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalHealthcareServiceValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalHealthcareServiceValue", generator = "Immutables")
  @Immutable
  static final class InternalHealthcareServiceValue
      implements ResourceList.InternalHealthcareServiceValue {
    private final HealthcareService healthcareService;

    private InternalHealthcareServiceValue(HealthcareService healthcareService) {
      this.healthcareService = healthcareService;
    }

    /**
     * @return The value of the {@code healthcareService} attribute
     */
    @JsonProperty("healthcareService")
    @JsonValue
    @Override
    public HealthcareService healthcareService() {
      return healthcareService;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalHealthcareServiceValue#healthcareService() healthcareService} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for healthcareService
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalHealthcareServiceValue withHealthcareService(HealthcareService value) {
      if (this.healthcareService == value) return this;
      HealthcareService newValue = Objects.requireNonNull(value, "healthcareService");
      return new ImmutableResourceList.InternalHealthcareServiceValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalHealthcareServiceValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalHealthcareServiceValue
          && equalTo((ImmutableResourceList.InternalHealthcareServiceValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalHealthcareServiceValue another) {
      return healthcareService.equals(another.healthcareService);
    }

    /**
     * Computes a hash code from attributes: {@code healthcareService}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + healthcareService.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalHealthcareServiceValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalHealthcareServiceValue{"
          + "healthcareService=" + healthcareService
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalHealthcareServiceValue fromJson(HealthcareService jsonValue) {
      ImmutableResourceList.InternalHealthcareServiceValue.Builder builder = ImmutableResourceList.InternalHealthcareServiceValue.builder();
      builder.healthcareService(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalHealthcareServiceValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalHealthcareServiceValue instance
     */
    public static ImmutableResourceList.InternalHealthcareServiceValue copyOf(ResourceList.InternalHealthcareServiceValue instance) {
      if (instance instanceof ImmutableResourceList.InternalHealthcareServiceValue) {
        return (ImmutableResourceList.InternalHealthcareServiceValue) instance;
      }
      return ImmutableResourceList.InternalHealthcareServiceValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalHealthcareServiceValue InternalHealthcareServiceValue}.
     * <pre>
     * ImmutableResourceList.InternalHealthcareServiceValue.builder()
     *    .healthcareService(com.fhir.types.fhir.HealthcareService) // required {@link ResourceList.InternalHealthcareServiceValue#healthcareService() healthcareService}
     *    .build();
     * </pre>
     * @return A new InternalHealthcareServiceValue builder
     */
    public static ImmutableResourceList.InternalHealthcareServiceValue.Builder builder() {
      return new ImmutableResourceList.InternalHealthcareServiceValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalHealthcareServiceValue InternalHealthcareServiceValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalHealthcareServiceValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_HEALTHCARE_SERVICE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable HealthcareService healthcareService;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalHealthcareServiceValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalHealthcareServiceValue instance) {
        Objects.requireNonNull(instance, "instance");
        healthcareService(instance.healthcareService());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalHealthcareServiceValue#healthcareService() healthcareService} attribute.
       * @param healthcareService The value for healthcareService 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("healthcareService")
      public final Builder healthcareService(HealthcareService healthcareService) {
        this.healthcareService = Objects.requireNonNull(healthcareService, "healthcareService");
        initBits &= ~INIT_BIT_HEALTHCARE_SERVICE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalHealthcareServiceValue InternalHealthcareServiceValue}.
       * @return An immutable instance of InternalHealthcareServiceValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalHealthcareServiceValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalHealthcareServiceValue(healthcareService);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_HEALTHCARE_SERVICE) != 0) attributes.add("healthcareService");
        return "Cannot build InternalHealthcareServiceValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSubstanceValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSubstanceValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSubstanceValue", generator = "Immutables")
  @Immutable
  static final class InternalSubstanceValue implements ResourceList.InternalSubstanceValue {
    private final Substance substance;

    private InternalSubstanceValue(Substance substance) {
      this.substance = substance;
    }

    /**
     * @return The value of the {@code substance} attribute
     */
    @JsonProperty("substance")
    @JsonValue
    @Override
    public Substance substance() {
      return substance;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSubstanceValue#substance() substance} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for substance
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSubstanceValue withSubstance(Substance value) {
      if (this.substance == value) return this;
      Substance newValue = Objects.requireNonNull(value, "substance");
      return new ImmutableResourceList.InternalSubstanceValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSubstanceValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSubstanceValue
          && equalTo((ImmutableResourceList.InternalSubstanceValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSubstanceValue another) {
      return substance.equals(another.substance);
    }

    /**
     * Computes a hash code from attributes: {@code substance}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + substance.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSubstanceValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSubstanceValue{"
          + "substance=" + substance
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSubstanceValue fromJson(Substance jsonValue) {
      ImmutableResourceList.InternalSubstanceValue.Builder builder = ImmutableResourceList.InternalSubstanceValue.builder();
      builder.substance(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSubstanceValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSubstanceValue instance
     */
    public static ImmutableResourceList.InternalSubstanceValue copyOf(ResourceList.InternalSubstanceValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSubstanceValue) {
        return (ImmutableResourceList.InternalSubstanceValue) instance;
      }
      return ImmutableResourceList.InternalSubstanceValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSubstanceValue InternalSubstanceValue}.
     * <pre>
     * ImmutableResourceList.InternalSubstanceValue.builder()
     *    .substance(com.fhir.types.fhir.Substance) // required {@link ResourceList.InternalSubstanceValue#substance() substance}
     *    .build();
     * </pre>
     * @return A new InternalSubstanceValue builder
     */
    public static ImmutableResourceList.InternalSubstanceValue.Builder builder() {
      return new ImmutableResourceList.InternalSubstanceValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSubstanceValue InternalSubstanceValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSubstanceValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUBSTANCE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Substance substance;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSubstanceValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSubstanceValue instance) {
        Objects.requireNonNull(instance, "instance");
        substance(instance.substance());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSubstanceValue#substance() substance} attribute.
       * @param substance The value for substance 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("substance")
      public final Builder substance(Substance substance) {
        this.substance = Objects.requireNonNull(substance, "substance");
        initBits &= ~INIT_BIT_SUBSTANCE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSubstanceValue InternalSubstanceValue}.
       * @return An immutable instance of InternalSubstanceValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSubstanceValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSubstanceValue(substance);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUBSTANCE) != 0) attributes.add("substance");
        return "Cannot build InternalSubstanceValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalPlanDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalPlanDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalPlanDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalPlanDefinitionValue
      implements ResourceList.InternalPlanDefinitionValue {
    private final PlanDefinition planDefinition;

    private InternalPlanDefinitionValue(PlanDefinition planDefinition) {
      this.planDefinition = planDefinition;
    }

    /**
     * @return The value of the {@code planDefinition} attribute
     */
    @JsonProperty("planDefinition")
    @JsonValue
    @Override
    public PlanDefinition planDefinition() {
      return planDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalPlanDefinitionValue#planDefinition() planDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for planDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalPlanDefinitionValue withPlanDefinition(PlanDefinition value) {
      if (this.planDefinition == value) return this;
      PlanDefinition newValue = Objects.requireNonNull(value, "planDefinition");
      return new ImmutableResourceList.InternalPlanDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalPlanDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalPlanDefinitionValue
          && equalTo((ImmutableResourceList.InternalPlanDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalPlanDefinitionValue another) {
      return planDefinition.equals(another.planDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code planDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + planDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalPlanDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalPlanDefinitionValue{"
          + "planDefinition=" + planDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalPlanDefinitionValue fromJson(PlanDefinition jsonValue) {
      ImmutableResourceList.InternalPlanDefinitionValue.Builder builder = ImmutableResourceList.InternalPlanDefinitionValue.builder();
      builder.planDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalPlanDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalPlanDefinitionValue instance
     */
    public static ImmutableResourceList.InternalPlanDefinitionValue copyOf(ResourceList.InternalPlanDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalPlanDefinitionValue) {
        return (ImmutableResourceList.InternalPlanDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalPlanDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalPlanDefinitionValue InternalPlanDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalPlanDefinitionValue.builder()
     *    .planDefinition(com.fhir.types.fhir.PlanDefinition) // required {@link ResourceList.InternalPlanDefinitionValue#planDefinition() planDefinition}
     *    .build();
     * </pre>
     * @return A new InternalPlanDefinitionValue builder
     */
    public static ImmutableResourceList.InternalPlanDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalPlanDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalPlanDefinitionValue InternalPlanDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalPlanDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PLAN_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable PlanDefinition planDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalPlanDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalPlanDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        planDefinition(instance.planDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalPlanDefinitionValue#planDefinition() planDefinition} attribute.
       * @param planDefinition The value for planDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("planDefinition")
      public final Builder planDefinition(PlanDefinition planDefinition) {
        this.planDefinition = Objects.requireNonNull(planDefinition, "planDefinition");
        initBits &= ~INIT_BIT_PLAN_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalPlanDefinitionValue InternalPlanDefinitionValue}.
       * @return An immutable instance of InternalPlanDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalPlanDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalPlanDefinitionValue(planDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PLAN_DEFINITION) != 0) attributes.add("planDefinition");
        return "Cannot build InternalPlanDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalFlagValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalFlagValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalFlagValue", generator = "Immutables")
  @Immutable
  static final class InternalFlagValue implements ResourceList.InternalFlagValue {
    private final Flag flag;

    private InternalFlagValue(Flag flag) {
      this.flag = flag;
    }

    /**
     * @return The value of the {@code flag} attribute
     */
    @JsonProperty("flag")
    @JsonValue
    @Override
    public Flag flag() {
      return flag;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalFlagValue#flag() flag} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for flag
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalFlagValue withFlag(Flag value) {
      if (this.flag == value) return this;
      Flag newValue = Objects.requireNonNull(value, "flag");
      return new ImmutableResourceList.InternalFlagValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalFlagValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalFlagValue
          && equalTo((ImmutableResourceList.InternalFlagValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalFlagValue another) {
      return flag.equals(another.flag);
    }

    /**
     * Computes a hash code from attributes: {@code flag}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + flag.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalFlagValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalFlagValue{"
          + "flag=" + flag
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalFlagValue fromJson(Flag jsonValue) {
      ImmutableResourceList.InternalFlagValue.Builder builder = ImmutableResourceList.InternalFlagValue.builder();
      builder.flag(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalFlagValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalFlagValue instance
     */
    public static ImmutableResourceList.InternalFlagValue copyOf(ResourceList.InternalFlagValue instance) {
      if (instance instanceof ImmutableResourceList.InternalFlagValue) {
        return (ImmutableResourceList.InternalFlagValue) instance;
      }
      return ImmutableResourceList.InternalFlagValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalFlagValue InternalFlagValue}.
     * <pre>
     * ImmutableResourceList.InternalFlagValue.builder()
     *    .flag(com.fhir.types.fhir.Flag) // required {@link ResourceList.InternalFlagValue#flag() flag}
     *    .build();
     * </pre>
     * @return A new InternalFlagValue builder
     */
    public static ImmutableResourceList.InternalFlagValue.Builder builder() {
      return new ImmutableResourceList.InternalFlagValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalFlagValue InternalFlagValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalFlagValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_FLAG = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Flag flag;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalFlagValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalFlagValue instance) {
        Objects.requireNonNull(instance, "instance");
        flag(instance.flag());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalFlagValue#flag() flag} attribute.
       * @param flag The value for flag 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("flag")
      public final Builder flag(Flag flag) {
        this.flag = Objects.requireNonNull(flag, "flag");
        initBits &= ~INIT_BIT_FLAG;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalFlagValue InternalFlagValue}.
       * @return An immutable instance of InternalFlagValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalFlagValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalFlagValue(flag);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_FLAG) != 0) attributes.add("flag");
        return "Cannot build InternalFlagValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalUserValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalUserValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalUserValue", generator = "Immutables")
  @Immutable
  static final class InternalUserValue implements ResourceList.InternalUserValue {
    private final User user;

    private InternalUserValue(User user) {
      this.user = user;
    }

    /**
     * @return The value of the {@code user} attribute
     */
    @JsonProperty("user")
    @JsonValue
    @Override
    public User user() {
      return user;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalUserValue#user() user} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for user
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalUserValue withUser(User value) {
      if (this.user == value) return this;
      User newValue = Objects.requireNonNull(value, "user");
      return new ImmutableResourceList.InternalUserValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalUserValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalUserValue
          && equalTo((ImmutableResourceList.InternalUserValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalUserValue another) {
      return user.equals(another.user);
    }

    /**
     * Computes a hash code from attributes: {@code user}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + user.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalUserValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalUserValue{"
          + "user=" + user
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalUserValue fromJson(User jsonValue) {
      ImmutableResourceList.InternalUserValue.Builder builder = ImmutableResourceList.InternalUserValue.builder();
      builder.user(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalUserValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalUserValue instance
     */
    public static ImmutableResourceList.InternalUserValue copyOf(ResourceList.InternalUserValue instance) {
      if (instance instanceof ImmutableResourceList.InternalUserValue) {
        return (ImmutableResourceList.InternalUserValue) instance;
      }
      return ImmutableResourceList.InternalUserValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalUserValue InternalUserValue}.
     * <pre>
     * ImmutableResourceList.InternalUserValue.builder()
     *    .user(com.fhir.types.fhir.User) // required {@link ResourceList.InternalUserValue#user() user}
     *    .build();
     * </pre>
     * @return A new InternalUserValue builder
     */
    public static ImmutableResourceList.InternalUserValue.Builder builder() {
      return new ImmutableResourceList.InternalUserValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalUserValue InternalUserValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalUserValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_USER = 0x1L;
      private long initBits = 0x1L;

      private @Nullable User user;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalUserValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalUserValue instance) {
        Objects.requireNonNull(instance, "instance");
        user(instance.user());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalUserValue#user() user} attribute.
       * @param user The value for user 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("user")
      public final Builder user(User user) {
        this.user = Objects.requireNonNull(user, "user");
        initBits &= ~INIT_BIT_USER;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalUserValue InternalUserValue}.
       * @return An immutable instance of InternalUserValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalUserValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalUserValue(user);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_USER) != 0) attributes.add("user");
        return "Cannot build InternalUserValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSpecimenValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSpecimenValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSpecimenValue", generator = "Immutables")
  @Immutable
  static final class InternalSpecimenValue implements ResourceList.InternalSpecimenValue {
    private final Specimen specimen;

    private InternalSpecimenValue(Specimen specimen) {
      this.specimen = specimen;
    }

    /**
     * @return The value of the {@code specimen} attribute
     */
    @JsonProperty("specimen")
    @JsonValue
    @Override
    public Specimen specimen() {
      return specimen;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSpecimenValue#specimen() specimen} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for specimen
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSpecimenValue withSpecimen(Specimen value) {
      if (this.specimen == value) return this;
      Specimen newValue = Objects.requireNonNull(value, "specimen");
      return new ImmutableResourceList.InternalSpecimenValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSpecimenValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSpecimenValue
          && equalTo((ImmutableResourceList.InternalSpecimenValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSpecimenValue another) {
      return specimen.equals(another.specimen);
    }

    /**
     * Computes a hash code from attributes: {@code specimen}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + specimen.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSpecimenValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSpecimenValue{"
          + "specimen=" + specimen
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSpecimenValue fromJson(Specimen jsonValue) {
      ImmutableResourceList.InternalSpecimenValue.Builder builder = ImmutableResourceList.InternalSpecimenValue.builder();
      builder.specimen(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSpecimenValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSpecimenValue instance
     */
    public static ImmutableResourceList.InternalSpecimenValue copyOf(ResourceList.InternalSpecimenValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSpecimenValue) {
        return (ImmutableResourceList.InternalSpecimenValue) instance;
      }
      return ImmutableResourceList.InternalSpecimenValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSpecimenValue InternalSpecimenValue}.
     * <pre>
     * ImmutableResourceList.InternalSpecimenValue.builder()
     *    .specimen(com.fhir.types.fhir.Specimen) // required {@link ResourceList.InternalSpecimenValue#specimen() specimen}
     *    .build();
     * </pre>
     * @return A new InternalSpecimenValue builder
     */
    public static ImmutableResourceList.InternalSpecimenValue.Builder builder() {
      return new ImmutableResourceList.InternalSpecimenValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSpecimenValue InternalSpecimenValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSpecimenValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SPECIMEN = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Specimen specimen;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSpecimenValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSpecimenValue instance) {
        Objects.requireNonNull(instance, "instance");
        specimen(instance.specimen());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSpecimenValue#specimen() specimen} attribute.
       * @param specimen The value for specimen 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("specimen")
      public final Builder specimen(Specimen specimen) {
        this.specimen = Objects.requireNonNull(specimen, "specimen");
        initBits &= ~INIT_BIT_SPECIMEN;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSpecimenValue InternalSpecimenValue}.
       * @return An immutable instance of InternalSpecimenValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSpecimenValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSpecimenValue(specimen);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SPECIMEN) != 0) attributes.add("specimen");
        return "Cannot build InternalSpecimenValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductContraindicationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductContraindicationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductContraindicationValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductContraindicationValue
      implements ResourceList.InternalMedicinalProductContraindicationValue {
    private final MedicinalProductContraindication medicinalProductContraindication;

    private InternalMedicinalProductContraindicationValue(MedicinalProductContraindication medicinalProductContraindication) {
      this.medicinalProductContraindication = medicinalProductContraindication;
    }

    /**
     * @return The value of the {@code medicinalProductContraindication} attribute
     */
    @JsonProperty("medicinalProductContraindication")
    @JsonValue
    @Override
    public MedicinalProductContraindication medicinalProductContraindication() {
      return medicinalProductContraindication;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductContraindicationValue#medicinalProductContraindication() medicinalProductContraindication} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProductContraindication
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductContraindicationValue withMedicinalProductContraindication(MedicinalProductContraindication value) {
      if (this.medicinalProductContraindication == value) return this;
      MedicinalProductContraindication newValue = Objects.requireNonNull(value, "medicinalProductContraindication");
      return new ImmutableResourceList.InternalMedicinalProductContraindicationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductContraindicationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductContraindicationValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductContraindicationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductContraindicationValue another) {
      return medicinalProductContraindication.equals(another.medicinalProductContraindication);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProductContraindication}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProductContraindication.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductContraindicationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductContraindicationValue{"
          + "medicinalProductContraindication=" + medicinalProductContraindication
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductContraindicationValue fromJson(MedicinalProductContraindication jsonValue) {
      ImmutableResourceList.InternalMedicinalProductContraindicationValue.Builder builder = ImmutableResourceList.InternalMedicinalProductContraindicationValue.builder();
      builder.medicinalProductContraindication(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductContraindicationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductContraindicationValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductContraindicationValue copyOf(ResourceList.InternalMedicinalProductContraindicationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductContraindicationValue) {
        return (ImmutableResourceList.InternalMedicinalProductContraindicationValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductContraindicationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductContraindicationValue InternalMedicinalProductContraindicationValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductContraindicationValue.builder()
     *    .medicinalProductContraindication(com.fhir.types.fhir.MedicinalProductContraindication) // required {@link ResourceList.InternalMedicinalProductContraindicationValue#medicinalProductContraindication() medicinalProductContraindication}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductContraindicationValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductContraindicationValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductContraindicationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductContraindicationValue InternalMedicinalProductContraindicationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductContraindicationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT_CONTRAINDICATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProductContraindication medicinalProductContraindication;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductContraindicationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductContraindicationValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProductContraindication(instance.medicinalProductContraindication());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductContraindicationValue#medicinalProductContraindication() medicinalProductContraindication} attribute.
       * @param medicinalProductContraindication The value for medicinalProductContraindication 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProductContraindication")
      public final Builder medicinalProductContraindication(MedicinalProductContraindication medicinalProductContraindication) {
        this.medicinalProductContraindication = Objects.requireNonNull(medicinalProductContraindication, "medicinalProductContraindication");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT_CONTRAINDICATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductContraindicationValue InternalMedicinalProductContraindicationValue}.
       * @return An immutable instance of InternalMedicinalProductContraindicationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductContraindicationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductContraindicationValue(medicinalProductContraindication);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT_CONTRAINDICATION) != 0) attributes.add("medicinalProductContraindication");
        return "Cannot build InternalMedicinalProductContraindicationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalDeviceValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalDeviceValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalDeviceValue", generator = "Immutables")
  @Immutable
  static final class InternalDeviceValue implements ResourceList.InternalDeviceValue {
    private final Device device;

    private InternalDeviceValue(Device device) {
      this.device = device;
    }

    /**
     * @return The value of the {@code device} attribute
     */
    @JsonProperty("device")
    @JsonValue
    @Override
    public Device device() {
      return device;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalDeviceValue#device() device} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for device
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalDeviceValue withDevice(Device value) {
      if (this.device == value) return this;
      Device newValue = Objects.requireNonNull(value, "device");
      return new ImmutableResourceList.InternalDeviceValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalDeviceValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalDeviceValue
          && equalTo((ImmutableResourceList.InternalDeviceValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalDeviceValue another) {
      return device.equals(another.device);
    }

    /**
     * Computes a hash code from attributes: {@code device}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + device.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalDeviceValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalDeviceValue{"
          + "device=" + device
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalDeviceValue fromJson(Device jsonValue) {
      ImmutableResourceList.InternalDeviceValue.Builder builder = ImmutableResourceList.InternalDeviceValue.builder();
      builder.device(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalDeviceValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalDeviceValue instance
     */
    public static ImmutableResourceList.InternalDeviceValue copyOf(ResourceList.InternalDeviceValue instance) {
      if (instance instanceof ImmutableResourceList.InternalDeviceValue) {
        return (ImmutableResourceList.InternalDeviceValue) instance;
      }
      return ImmutableResourceList.InternalDeviceValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalDeviceValue InternalDeviceValue}.
     * <pre>
     * ImmutableResourceList.InternalDeviceValue.builder()
     *    .device(com.fhir.types.fhir.Device) // required {@link ResourceList.InternalDeviceValue#device() device}
     *    .build();
     * </pre>
     * @return A new InternalDeviceValue builder
     */
    public static ImmutableResourceList.InternalDeviceValue.Builder builder() {
      return new ImmutableResourceList.InternalDeviceValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalDeviceValue InternalDeviceValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalDeviceValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_DEVICE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Device device;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalDeviceValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalDeviceValue instance) {
        Objects.requireNonNull(instance, "instance");
        device(instance.device());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalDeviceValue#device() device} attribute.
       * @param device The value for device 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("device")
      public final Builder device(Device device) {
        this.device = Objects.requireNonNull(device, "device");
        initBits &= ~INIT_BIT_DEVICE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalDeviceValue InternalDeviceValue}.
       * @return An immutable instance of InternalDeviceValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalDeviceValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalDeviceValue(device);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_DEVICE) != 0) attributes.add("device");
        return "Cannot build InternalDeviceValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSubstanceSourceMaterialValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSubstanceSourceMaterialValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSubstanceSourceMaterialValue", generator = "Immutables")
  @Immutable
  static final class InternalSubstanceSourceMaterialValue
      implements ResourceList.InternalSubstanceSourceMaterialValue {
    private final SubstanceSourceMaterial substanceSourceMaterial;

    private InternalSubstanceSourceMaterialValue(SubstanceSourceMaterial substanceSourceMaterial) {
      this.substanceSourceMaterial = substanceSourceMaterial;
    }

    /**
     * @return The value of the {@code substanceSourceMaterial} attribute
     */
    @JsonProperty("substanceSourceMaterial")
    @JsonValue
    @Override
    public SubstanceSourceMaterial substanceSourceMaterial() {
      return substanceSourceMaterial;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSubstanceSourceMaterialValue#substanceSourceMaterial() substanceSourceMaterial} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for substanceSourceMaterial
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSubstanceSourceMaterialValue withSubstanceSourceMaterial(SubstanceSourceMaterial value) {
      if (this.substanceSourceMaterial == value) return this;
      SubstanceSourceMaterial newValue = Objects.requireNonNull(value, "substanceSourceMaterial");
      return new ImmutableResourceList.InternalSubstanceSourceMaterialValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSubstanceSourceMaterialValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSubstanceSourceMaterialValue
          && equalTo((ImmutableResourceList.InternalSubstanceSourceMaterialValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSubstanceSourceMaterialValue another) {
      return substanceSourceMaterial.equals(another.substanceSourceMaterial);
    }

    /**
     * Computes a hash code from attributes: {@code substanceSourceMaterial}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + substanceSourceMaterial.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSubstanceSourceMaterialValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSubstanceSourceMaterialValue{"
          + "substanceSourceMaterial=" + substanceSourceMaterial
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSubstanceSourceMaterialValue fromJson(SubstanceSourceMaterial jsonValue) {
      ImmutableResourceList.InternalSubstanceSourceMaterialValue.Builder builder = ImmutableResourceList.InternalSubstanceSourceMaterialValue.builder();
      builder.substanceSourceMaterial(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSubstanceSourceMaterialValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSubstanceSourceMaterialValue instance
     */
    public static ImmutableResourceList.InternalSubstanceSourceMaterialValue copyOf(ResourceList.InternalSubstanceSourceMaterialValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSubstanceSourceMaterialValue) {
        return (ImmutableResourceList.InternalSubstanceSourceMaterialValue) instance;
      }
      return ImmutableResourceList.InternalSubstanceSourceMaterialValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSubstanceSourceMaterialValue InternalSubstanceSourceMaterialValue}.
     * <pre>
     * ImmutableResourceList.InternalSubstanceSourceMaterialValue.builder()
     *    .substanceSourceMaterial(com.fhir.types.fhir.SubstanceSourceMaterial) // required {@link ResourceList.InternalSubstanceSourceMaterialValue#substanceSourceMaterial() substanceSourceMaterial}
     *    .build();
     * </pre>
     * @return A new InternalSubstanceSourceMaterialValue builder
     */
    public static ImmutableResourceList.InternalSubstanceSourceMaterialValue.Builder builder() {
      return new ImmutableResourceList.InternalSubstanceSourceMaterialValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSubstanceSourceMaterialValue InternalSubstanceSourceMaterialValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSubstanceSourceMaterialValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUBSTANCE_SOURCE_MATERIAL = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SubstanceSourceMaterial substanceSourceMaterial;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSubstanceSourceMaterialValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSubstanceSourceMaterialValue instance) {
        Objects.requireNonNull(instance, "instance");
        substanceSourceMaterial(instance.substanceSourceMaterial());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSubstanceSourceMaterialValue#substanceSourceMaterial() substanceSourceMaterial} attribute.
       * @param substanceSourceMaterial The value for substanceSourceMaterial 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("substanceSourceMaterial")
      public final Builder substanceSourceMaterial(SubstanceSourceMaterial substanceSourceMaterial) {
        this.substanceSourceMaterial = Objects.requireNonNull(substanceSourceMaterial, "substanceSourceMaterial");
        initBits &= ~INIT_BIT_SUBSTANCE_SOURCE_MATERIAL;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSubstanceSourceMaterialValue InternalSubstanceSourceMaterialValue}.
       * @return An immutable instance of InternalSubstanceSourceMaterialValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSubstanceSourceMaterialValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSubstanceSourceMaterialValue(substanceSourceMaterial);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUBSTANCE_SOURCE_MATERIAL) != 0) attributes.add("substanceSourceMaterial");
        return "Cannot build InternalSubstanceSourceMaterialValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalRequestGroupValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalRequestGroupValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalRequestGroupValue", generator = "Immutables")
  @Immutable
  static final class InternalRequestGroupValue
      implements ResourceList.InternalRequestGroupValue {
    private final RequestGroup requestGroup;

    private InternalRequestGroupValue(RequestGroup requestGroup) {
      this.requestGroup = requestGroup;
    }

    /**
     * @return The value of the {@code requestGroup} attribute
     */
    @JsonProperty("requestGroup")
    @JsonValue
    @Override
    public RequestGroup requestGroup() {
      return requestGroup;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalRequestGroupValue#requestGroup() requestGroup} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for requestGroup
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalRequestGroupValue withRequestGroup(RequestGroup value) {
      if (this.requestGroup == value) return this;
      RequestGroup newValue = Objects.requireNonNull(value, "requestGroup");
      return new ImmutableResourceList.InternalRequestGroupValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalRequestGroupValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalRequestGroupValue
          && equalTo((ImmutableResourceList.InternalRequestGroupValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalRequestGroupValue another) {
      return requestGroup.equals(another.requestGroup);
    }

    /**
     * Computes a hash code from attributes: {@code requestGroup}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + requestGroup.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalRequestGroupValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalRequestGroupValue{"
          + "requestGroup=" + requestGroup
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalRequestGroupValue fromJson(RequestGroup jsonValue) {
      ImmutableResourceList.InternalRequestGroupValue.Builder builder = ImmutableResourceList.InternalRequestGroupValue.builder();
      builder.requestGroup(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalRequestGroupValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalRequestGroupValue instance
     */
    public static ImmutableResourceList.InternalRequestGroupValue copyOf(ResourceList.InternalRequestGroupValue instance) {
      if (instance instanceof ImmutableResourceList.InternalRequestGroupValue) {
        return (ImmutableResourceList.InternalRequestGroupValue) instance;
      }
      return ImmutableResourceList.InternalRequestGroupValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalRequestGroupValue InternalRequestGroupValue}.
     * <pre>
     * ImmutableResourceList.InternalRequestGroupValue.builder()
     *    .requestGroup(com.fhir.types.fhir.RequestGroup) // required {@link ResourceList.InternalRequestGroupValue#requestGroup() requestGroup}
     *    .build();
     * </pre>
     * @return A new InternalRequestGroupValue builder
     */
    public static ImmutableResourceList.InternalRequestGroupValue.Builder builder() {
      return new ImmutableResourceList.InternalRequestGroupValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalRequestGroupValue InternalRequestGroupValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalRequestGroupValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_REQUEST_GROUP = 0x1L;
      private long initBits = 0x1L;

      private @Nullable RequestGroup requestGroup;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalRequestGroupValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalRequestGroupValue instance) {
        Objects.requireNonNull(instance, "instance");
        requestGroup(instance.requestGroup());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalRequestGroupValue#requestGroup() requestGroup} attribute.
       * @param requestGroup The value for requestGroup 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("requestGroup")
      public final Builder requestGroup(RequestGroup requestGroup) {
        this.requestGroup = Objects.requireNonNull(requestGroup, "requestGroup");
        initBits &= ~INIT_BIT_REQUEST_GROUP;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalRequestGroupValue InternalRequestGroupValue}.
       * @return An immutable instance of InternalRequestGroupValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalRequestGroupValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalRequestGroupValue(requestGroup);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_REQUEST_GROUP) != 0) attributes.add("requestGroup");
        return "Cannot build InternalRequestGroupValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalStructureDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalStructureDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalStructureDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalStructureDefinitionValue
      implements ResourceList.InternalStructureDefinitionValue {
    private final StructureDefinition structureDefinition;

    private InternalStructureDefinitionValue(StructureDefinition structureDefinition) {
      this.structureDefinition = structureDefinition;
    }

    /**
     * @return The value of the {@code structureDefinition} attribute
     */
    @JsonProperty("structureDefinition")
    @JsonValue
    @Override
    public StructureDefinition structureDefinition() {
      return structureDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalStructureDefinitionValue#structureDefinition() structureDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for structureDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalStructureDefinitionValue withStructureDefinition(StructureDefinition value) {
      if (this.structureDefinition == value) return this;
      StructureDefinition newValue = Objects.requireNonNull(value, "structureDefinition");
      return new ImmutableResourceList.InternalStructureDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalStructureDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalStructureDefinitionValue
          && equalTo((ImmutableResourceList.InternalStructureDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalStructureDefinitionValue another) {
      return structureDefinition.equals(another.structureDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code structureDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + structureDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalStructureDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalStructureDefinitionValue{"
          + "structureDefinition=" + structureDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalStructureDefinitionValue fromJson(StructureDefinition jsonValue) {
      ImmutableResourceList.InternalStructureDefinitionValue.Builder builder = ImmutableResourceList.InternalStructureDefinitionValue.builder();
      builder.structureDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalStructureDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalStructureDefinitionValue instance
     */
    public static ImmutableResourceList.InternalStructureDefinitionValue copyOf(ResourceList.InternalStructureDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalStructureDefinitionValue) {
        return (ImmutableResourceList.InternalStructureDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalStructureDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalStructureDefinitionValue InternalStructureDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalStructureDefinitionValue.builder()
     *    .structureDefinition(com.fhir.types.fhir.StructureDefinition) // required {@link ResourceList.InternalStructureDefinitionValue#structureDefinition() structureDefinition}
     *    .build();
     * </pre>
     * @return A new InternalStructureDefinitionValue builder
     */
    public static ImmutableResourceList.InternalStructureDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalStructureDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalStructureDefinitionValue InternalStructureDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalStructureDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_STRUCTURE_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable StructureDefinition structureDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalStructureDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalStructureDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        structureDefinition(instance.structureDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalStructureDefinitionValue#structureDefinition() structureDefinition} attribute.
       * @param structureDefinition The value for structureDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("structureDefinition")
      public final Builder structureDefinition(StructureDefinition structureDefinition) {
        this.structureDefinition = Objects.requireNonNull(structureDefinition, "structureDefinition");
        initBits &= ~INIT_BIT_STRUCTURE_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalStructureDefinitionValue InternalStructureDefinitionValue}.
       * @return An immutable instance of InternalStructureDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalStructureDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalStructureDefinitionValue(structureDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_STRUCTURE_DEFINITION) != 0) attributes.add("structureDefinition");
        return "Cannot build InternalStructureDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalAccessPolicyValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalAccessPolicyValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalAccessPolicyValue", generator = "Immutables")
  @Immutable
  static final class InternalAccessPolicyValue
      implements ResourceList.InternalAccessPolicyValue {
    private final AccessPolicy accessPolicy;

    private InternalAccessPolicyValue(AccessPolicy accessPolicy) {
      this.accessPolicy = accessPolicy;
    }

    /**
     * @return The value of the {@code accessPolicy} attribute
     */
    @JsonProperty("accessPolicy")
    @JsonValue
    @Override
    public AccessPolicy accessPolicy() {
      return accessPolicy;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalAccessPolicyValue#accessPolicy() accessPolicy} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for accessPolicy
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalAccessPolicyValue withAccessPolicy(AccessPolicy value) {
      if (this.accessPolicy == value) return this;
      AccessPolicy newValue = Objects.requireNonNull(value, "accessPolicy");
      return new ImmutableResourceList.InternalAccessPolicyValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalAccessPolicyValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalAccessPolicyValue
          && equalTo((ImmutableResourceList.InternalAccessPolicyValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalAccessPolicyValue another) {
      return accessPolicy.equals(another.accessPolicy);
    }

    /**
     * Computes a hash code from attributes: {@code accessPolicy}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + accessPolicy.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalAccessPolicyValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalAccessPolicyValue{"
          + "accessPolicy=" + accessPolicy
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalAccessPolicyValue fromJson(AccessPolicy jsonValue) {
      ImmutableResourceList.InternalAccessPolicyValue.Builder builder = ImmutableResourceList.InternalAccessPolicyValue.builder();
      builder.accessPolicy(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalAccessPolicyValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalAccessPolicyValue instance
     */
    public static ImmutableResourceList.InternalAccessPolicyValue copyOf(ResourceList.InternalAccessPolicyValue instance) {
      if (instance instanceof ImmutableResourceList.InternalAccessPolicyValue) {
        return (ImmutableResourceList.InternalAccessPolicyValue) instance;
      }
      return ImmutableResourceList.InternalAccessPolicyValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalAccessPolicyValue InternalAccessPolicyValue}.
     * <pre>
     * ImmutableResourceList.InternalAccessPolicyValue.builder()
     *    .accessPolicy(com.fhir.types.fhir.AccessPolicy) // required {@link ResourceList.InternalAccessPolicyValue#accessPolicy() accessPolicy}
     *    .build();
     * </pre>
     * @return A new InternalAccessPolicyValue builder
     */
    public static ImmutableResourceList.InternalAccessPolicyValue.Builder builder() {
      return new ImmutableResourceList.InternalAccessPolicyValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalAccessPolicyValue InternalAccessPolicyValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalAccessPolicyValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ACCESS_POLICY = 0x1L;
      private long initBits = 0x1L;

      private @Nullable AccessPolicy accessPolicy;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalAccessPolicyValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalAccessPolicyValue instance) {
        Objects.requireNonNull(instance, "instance");
        accessPolicy(instance.accessPolicy());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalAccessPolicyValue#accessPolicy() accessPolicy} attribute.
       * @param accessPolicy The value for accessPolicy 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("accessPolicy")
      public final Builder accessPolicy(AccessPolicy accessPolicy) {
        this.accessPolicy = Objects.requireNonNull(accessPolicy, "accessPolicy");
        initBits &= ~INIT_BIT_ACCESS_POLICY;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalAccessPolicyValue InternalAccessPolicyValue}.
       * @return An immutable instance of InternalAccessPolicyValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalAccessPolicyValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalAccessPolicyValue(accessPolicy);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ACCESS_POLICY) != 0) attributes.add("accessPolicy");
        return "Cannot build InternalAccessPolicyValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMeasureValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMeasureValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMeasureValue", generator = "Immutables")
  @Immutable
  static final class InternalMeasureValue implements ResourceList.InternalMeasureValue {
    private final Measure measure;

    private InternalMeasureValue(Measure measure) {
      this.measure = measure;
    }

    /**
     * @return The value of the {@code measure} attribute
     */
    @JsonProperty("measure")
    @JsonValue
    @Override
    public Measure measure() {
      return measure;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMeasureValue#measure() measure} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for measure
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMeasureValue withMeasure(Measure value) {
      if (this.measure == value) return this;
      Measure newValue = Objects.requireNonNull(value, "measure");
      return new ImmutableResourceList.InternalMeasureValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMeasureValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMeasureValue
          && equalTo((ImmutableResourceList.InternalMeasureValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMeasureValue another) {
      return measure.equals(another.measure);
    }

    /**
     * Computes a hash code from attributes: {@code measure}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + measure.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMeasureValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMeasureValue{"
          + "measure=" + measure
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMeasureValue fromJson(Measure jsonValue) {
      ImmutableResourceList.InternalMeasureValue.Builder builder = ImmutableResourceList.InternalMeasureValue.builder();
      builder.measure(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMeasureValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMeasureValue instance
     */
    public static ImmutableResourceList.InternalMeasureValue copyOf(ResourceList.InternalMeasureValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMeasureValue) {
        return (ImmutableResourceList.InternalMeasureValue) instance;
      }
      return ImmutableResourceList.InternalMeasureValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMeasureValue InternalMeasureValue}.
     * <pre>
     * ImmutableResourceList.InternalMeasureValue.builder()
     *    .measure(com.fhir.types.fhir.Measure) // required {@link ResourceList.InternalMeasureValue#measure() measure}
     *    .build();
     * </pre>
     * @return A new InternalMeasureValue builder
     */
    public static ImmutableResourceList.InternalMeasureValue.Builder builder() {
      return new ImmutableResourceList.InternalMeasureValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMeasureValue InternalMeasureValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMeasureValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEASURE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Measure measure;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMeasureValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMeasureValue instance) {
        Objects.requireNonNull(instance, "instance");
        measure(instance.measure());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMeasureValue#measure() measure} attribute.
       * @param measure The value for measure 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("measure")
      public final Builder measure(Measure measure) {
        this.measure = Objects.requireNonNull(measure, "measure");
        initBits &= ~INIT_BIT_MEASURE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMeasureValue InternalMeasureValue}.
       * @return An immutable instance of InternalMeasureValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMeasureValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMeasureValue(measure);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEASURE) != 0) attributes.add("measure");
        return "Cannot build InternalMeasureValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductValue
      implements ResourceList.InternalMedicinalProductValue {
    private final MedicinalProduct medicinalProduct;

    private InternalMedicinalProductValue(MedicinalProduct medicinalProduct) {
      this.medicinalProduct = medicinalProduct;
    }

    /**
     * @return The value of the {@code medicinalProduct} attribute
     */
    @JsonProperty("medicinalProduct")
    @JsonValue
    @Override
    public MedicinalProduct medicinalProduct() {
      return medicinalProduct;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductValue#medicinalProduct() medicinalProduct} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProduct
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductValue withMedicinalProduct(MedicinalProduct value) {
      if (this.medicinalProduct == value) return this;
      MedicinalProduct newValue = Objects.requireNonNull(value, "medicinalProduct");
      return new ImmutableResourceList.InternalMedicinalProductValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductValue another) {
      return medicinalProduct.equals(another.medicinalProduct);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProduct}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProduct.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductValue{"
          + "medicinalProduct=" + medicinalProduct
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductValue fromJson(MedicinalProduct jsonValue) {
      ImmutableResourceList.InternalMedicinalProductValue.Builder builder = ImmutableResourceList.InternalMedicinalProductValue.builder();
      builder.medicinalProduct(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductValue copyOf(ResourceList.InternalMedicinalProductValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductValue) {
        return (ImmutableResourceList.InternalMedicinalProductValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductValue InternalMedicinalProductValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductValue.builder()
     *    .medicinalProduct(com.fhir.types.fhir.MedicinalProduct) // required {@link ResourceList.InternalMedicinalProductValue#medicinalProduct() medicinalProduct}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductValue InternalMedicinalProductValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProduct medicinalProduct;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProduct(instance.medicinalProduct());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductValue#medicinalProduct() medicinalProduct} attribute.
       * @param medicinalProduct The value for medicinalProduct 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProduct")
      public final Builder medicinalProduct(MedicinalProduct medicinalProduct) {
        this.medicinalProduct = Objects.requireNonNull(medicinalProduct, "medicinalProduct");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductValue InternalMedicinalProductValue}.
       * @return An immutable instance of InternalMedicinalProductValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductValue(medicinalProduct);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT) != 0) attributes.add("medicinalProduct");
        return "Cannot build InternalMedicinalProductValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalLoginValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalLoginValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalLoginValue", generator = "Immutables")
  @Immutable
  static final class InternalLoginValue implements ResourceList.InternalLoginValue {
    private final Login login;

    private InternalLoginValue(Login login) {
      this.login = login;
    }

    /**
     * @return The value of the {@code login} attribute
     */
    @JsonProperty("login")
    @JsonValue
    @Override
    public Login login() {
      return login;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalLoginValue#login() login} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for login
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalLoginValue withLogin(Login value) {
      if (this.login == value) return this;
      Login newValue = Objects.requireNonNull(value, "login");
      return new ImmutableResourceList.InternalLoginValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalLoginValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalLoginValue
          && equalTo((ImmutableResourceList.InternalLoginValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalLoginValue another) {
      return login.equals(another.login);
    }

    /**
     * Computes a hash code from attributes: {@code login}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + login.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalLoginValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalLoginValue{"
          + "login=" + login
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalLoginValue fromJson(Login jsonValue) {
      ImmutableResourceList.InternalLoginValue.Builder builder = ImmutableResourceList.InternalLoginValue.builder();
      builder.login(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalLoginValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalLoginValue instance
     */
    public static ImmutableResourceList.InternalLoginValue copyOf(ResourceList.InternalLoginValue instance) {
      if (instance instanceof ImmutableResourceList.InternalLoginValue) {
        return (ImmutableResourceList.InternalLoginValue) instance;
      }
      return ImmutableResourceList.InternalLoginValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalLoginValue InternalLoginValue}.
     * <pre>
     * ImmutableResourceList.InternalLoginValue.builder()
     *    .login(com.fhir.types.fhir.Login) // required {@link ResourceList.InternalLoginValue#login() login}
     *    .build();
     * </pre>
     * @return A new InternalLoginValue builder
     */
    public static ImmutableResourceList.InternalLoginValue.Builder builder() {
      return new ImmutableResourceList.InternalLoginValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalLoginValue InternalLoginValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalLoginValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_LOGIN = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Login login;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalLoginValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalLoginValue instance) {
        Objects.requireNonNull(instance, "instance");
        login(instance.login());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalLoginValue#login() login} attribute.
       * @param login The value for login 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("login")
      public final Builder login(Login login) {
        this.login = Objects.requireNonNull(login, "login");
        initBits &= ~INIT_BIT_LOGIN;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalLoginValue InternalLoginValue}.
       * @return An immutable instance of InternalLoginValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalLoginValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalLoginValue(login);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_LOGIN) != 0) attributes.add("login");
        return "Cannot build InternalLoginValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalAuditEventValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalAuditEventValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalAuditEventValue", generator = "Immutables")
  @Immutable
  static final class InternalAuditEventValue
      implements ResourceList.InternalAuditEventValue {
    private final AuditEvent auditEvent;

    private InternalAuditEventValue(AuditEvent auditEvent) {
      this.auditEvent = auditEvent;
    }

    /**
     * @return The value of the {@code auditEvent} attribute
     */
    @JsonProperty("auditEvent")
    @JsonValue
    @Override
    public AuditEvent auditEvent() {
      return auditEvent;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalAuditEventValue#auditEvent() auditEvent} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for auditEvent
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalAuditEventValue withAuditEvent(AuditEvent value) {
      if (this.auditEvent == value) return this;
      AuditEvent newValue = Objects.requireNonNull(value, "auditEvent");
      return new ImmutableResourceList.InternalAuditEventValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalAuditEventValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalAuditEventValue
          && equalTo((ImmutableResourceList.InternalAuditEventValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalAuditEventValue another) {
      return auditEvent.equals(another.auditEvent);
    }

    /**
     * Computes a hash code from attributes: {@code auditEvent}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + auditEvent.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalAuditEventValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalAuditEventValue{"
          + "auditEvent=" + auditEvent
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalAuditEventValue fromJson(AuditEvent jsonValue) {
      ImmutableResourceList.InternalAuditEventValue.Builder builder = ImmutableResourceList.InternalAuditEventValue.builder();
      builder.auditEvent(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalAuditEventValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalAuditEventValue instance
     */
    public static ImmutableResourceList.InternalAuditEventValue copyOf(ResourceList.InternalAuditEventValue instance) {
      if (instance instanceof ImmutableResourceList.InternalAuditEventValue) {
        return (ImmutableResourceList.InternalAuditEventValue) instance;
      }
      return ImmutableResourceList.InternalAuditEventValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalAuditEventValue InternalAuditEventValue}.
     * <pre>
     * ImmutableResourceList.InternalAuditEventValue.builder()
     *    .auditEvent(com.fhir.types.fhir.AuditEvent) // required {@link ResourceList.InternalAuditEventValue#auditEvent() auditEvent}
     *    .build();
     * </pre>
     * @return A new InternalAuditEventValue builder
     */
    public static ImmutableResourceList.InternalAuditEventValue.Builder builder() {
      return new ImmutableResourceList.InternalAuditEventValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalAuditEventValue InternalAuditEventValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalAuditEventValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_AUDIT_EVENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable AuditEvent auditEvent;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalAuditEventValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalAuditEventValue instance) {
        Objects.requireNonNull(instance, "instance");
        auditEvent(instance.auditEvent());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalAuditEventValue#auditEvent() auditEvent} attribute.
       * @param auditEvent The value for auditEvent 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("auditEvent")
      public final Builder auditEvent(AuditEvent auditEvent) {
        this.auditEvent = Objects.requireNonNull(auditEvent, "auditEvent");
        initBits &= ~INIT_BIT_AUDIT_EVENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalAuditEventValue InternalAuditEventValue}.
       * @return An immutable instance of InternalAuditEventValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalAuditEventValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalAuditEventValue(auditEvent);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_AUDIT_EVENT) != 0) attributes.add("auditEvent");
        return "Cannot build InternalAuditEventValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMeasureReportValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMeasureReportValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMeasureReportValue", generator = "Immutables")
  @Immutable
  static final class InternalMeasureReportValue
      implements ResourceList.InternalMeasureReportValue {
    private final MeasureReport measureReport;

    private InternalMeasureReportValue(MeasureReport measureReport) {
      this.measureReport = measureReport;
    }

    /**
     * @return The value of the {@code measureReport} attribute
     */
    @JsonProperty("measureReport")
    @JsonValue
    @Override
    public MeasureReport measureReport() {
      return measureReport;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMeasureReportValue#measureReport() measureReport} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for measureReport
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMeasureReportValue withMeasureReport(MeasureReport value) {
      if (this.measureReport == value) return this;
      MeasureReport newValue = Objects.requireNonNull(value, "measureReport");
      return new ImmutableResourceList.InternalMeasureReportValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMeasureReportValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMeasureReportValue
          && equalTo((ImmutableResourceList.InternalMeasureReportValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMeasureReportValue another) {
      return measureReport.equals(another.measureReport);
    }

    /**
     * Computes a hash code from attributes: {@code measureReport}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + measureReport.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMeasureReportValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMeasureReportValue{"
          + "measureReport=" + measureReport
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMeasureReportValue fromJson(MeasureReport jsonValue) {
      ImmutableResourceList.InternalMeasureReportValue.Builder builder = ImmutableResourceList.InternalMeasureReportValue.builder();
      builder.measureReport(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMeasureReportValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMeasureReportValue instance
     */
    public static ImmutableResourceList.InternalMeasureReportValue copyOf(ResourceList.InternalMeasureReportValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMeasureReportValue) {
        return (ImmutableResourceList.InternalMeasureReportValue) instance;
      }
      return ImmutableResourceList.InternalMeasureReportValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMeasureReportValue InternalMeasureReportValue}.
     * <pre>
     * ImmutableResourceList.InternalMeasureReportValue.builder()
     *    .measureReport(com.fhir.types.fhir.MeasureReport) // required {@link ResourceList.InternalMeasureReportValue#measureReport() measureReport}
     *    .build();
     * </pre>
     * @return A new InternalMeasureReportValue builder
     */
    public static ImmutableResourceList.InternalMeasureReportValue.Builder builder() {
      return new ImmutableResourceList.InternalMeasureReportValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMeasureReportValue InternalMeasureReportValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMeasureReportValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEASURE_REPORT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MeasureReport measureReport;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMeasureReportValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMeasureReportValue instance) {
        Objects.requireNonNull(instance, "instance");
        measureReport(instance.measureReport());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMeasureReportValue#measureReport() measureReport} attribute.
       * @param measureReport The value for measureReport 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("measureReport")
      public final Builder measureReport(MeasureReport measureReport) {
        this.measureReport = Objects.requireNonNull(measureReport, "measureReport");
        initBits &= ~INIT_BIT_MEASURE_REPORT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMeasureReportValue InternalMeasureReportValue}.
       * @return An immutable instance of InternalMeasureReportValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMeasureReportValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMeasureReportValue(measureReport);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEASURE_REPORT) != 0) attributes.add("measureReport");
        return "Cannot build InternalMeasureReportValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductIndicationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductIndicationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductIndicationValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductIndicationValue
      implements ResourceList.InternalMedicinalProductIndicationValue {
    private final MedicinalProductIndication medicinalProductIndication;

    private InternalMedicinalProductIndicationValue(MedicinalProductIndication medicinalProductIndication) {
      this.medicinalProductIndication = medicinalProductIndication;
    }

    /**
     * @return The value of the {@code medicinalProductIndication} attribute
     */
    @JsonProperty("medicinalProductIndication")
    @JsonValue
    @Override
    public MedicinalProductIndication medicinalProductIndication() {
      return medicinalProductIndication;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductIndicationValue#medicinalProductIndication() medicinalProductIndication} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProductIndication
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductIndicationValue withMedicinalProductIndication(MedicinalProductIndication value) {
      if (this.medicinalProductIndication == value) return this;
      MedicinalProductIndication newValue = Objects.requireNonNull(value, "medicinalProductIndication");
      return new ImmutableResourceList.InternalMedicinalProductIndicationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductIndicationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductIndicationValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductIndicationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductIndicationValue another) {
      return medicinalProductIndication.equals(another.medicinalProductIndication);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProductIndication}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProductIndication.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductIndicationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductIndicationValue{"
          + "medicinalProductIndication=" + medicinalProductIndication
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductIndicationValue fromJson(MedicinalProductIndication jsonValue) {
      ImmutableResourceList.InternalMedicinalProductIndicationValue.Builder builder = ImmutableResourceList.InternalMedicinalProductIndicationValue.builder();
      builder.medicinalProductIndication(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductIndicationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductIndicationValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductIndicationValue copyOf(ResourceList.InternalMedicinalProductIndicationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductIndicationValue) {
        return (ImmutableResourceList.InternalMedicinalProductIndicationValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductIndicationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductIndicationValue InternalMedicinalProductIndicationValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductIndicationValue.builder()
     *    .medicinalProductIndication(com.fhir.types.fhir.MedicinalProductIndication) // required {@link ResourceList.InternalMedicinalProductIndicationValue#medicinalProductIndication() medicinalProductIndication}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductIndicationValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductIndicationValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductIndicationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductIndicationValue InternalMedicinalProductIndicationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductIndicationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT_INDICATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProductIndication medicinalProductIndication;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductIndicationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductIndicationValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProductIndication(instance.medicinalProductIndication());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductIndicationValue#medicinalProductIndication() medicinalProductIndication} attribute.
       * @param medicinalProductIndication The value for medicinalProductIndication 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProductIndication")
      public final Builder medicinalProductIndication(MedicinalProductIndication medicinalProductIndication) {
        this.medicinalProductIndication = Objects.requireNonNull(medicinalProductIndication, "medicinalProductIndication");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT_INDICATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductIndicationValue InternalMedicinalProductIndicationValue}.
       * @return An immutable instance of InternalMedicinalProductIndicationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductIndicationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductIndicationValue(medicinalProductIndication);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT_INDICATION) != 0) attributes.add("medicinalProductIndication");
        return "Cannot build InternalMedicinalProductIndicationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalPractitionerValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalPractitionerValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalPractitionerValue", generator = "Immutables")
  @Immutable
  static final class InternalPractitionerValue
      implements ResourceList.InternalPractitionerValue {
    private final Practitioner practitioner;

    private InternalPractitionerValue(Practitioner practitioner) {
      this.practitioner = practitioner;
    }

    /**
     * @return The value of the {@code practitioner} attribute
     */
    @JsonProperty("practitioner")
    @JsonValue
    @Override
    public Practitioner practitioner() {
      return practitioner;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalPractitionerValue#practitioner() practitioner} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for practitioner
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalPractitionerValue withPractitioner(Practitioner value) {
      if (this.practitioner == value) return this;
      Practitioner newValue = Objects.requireNonNull(value, "practitioner");
      return new ImmutableResourceList.InternalPractitionerValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalPractitionerValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalPractitionerValue
          && equalTo((ImmutableResourceList.InternalPractitionerValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalPractitionerValue another) {
      return practitioner.equals(another.practitioner);
    }

    /**
     * Computes a hash code from attributes: {@code practitioner}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + practitioner.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalPractitionerValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalPractitionerValue{"
          + "practitioner=" + practitioner
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalPractitionerValue fromJson(Practitioner jsonValue) {
      ImmutableResourceList.InternalPractitionerValue.Builder builder = ImmutableResourceList.InternalPractitionerValue.builder();
      builder.practitioner(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalPractitionerValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalPractitionerValue instance
     */
    public static ImmutableResourceList.InternalPractitionerValue copyOf(ResourceList.InternalPractitionerValue instance) {
      if (instance instanceof ImmutableResourceList.InternalPractitionerValue) {
        return (ImmutableResourceList.InternalPractitionerValue) instance;
      }
      return ImmutableResourceList.InternalPractitionerValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalPractitionerValue InternalPractitionerValue}.
     * <pre>
     * ImmutableResourceList.InternalPractitionerValue.builder()
     *    .practitioner(com.fhir.types.fhir.Practitioner) // required {@link ResourceList.InternalPractitionerValue#practitioner() practitioner}
     *    .build();
     * </pre>
     * @return A new InternalPractitionerValue builder
     */
    public static ImmutableResourceList.InternalPractitionerValue.Builder builder() {
      return new ImmutableResourceList.InternalPractitionerValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalPractitionerValue InternalPractitionerValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalPractitionerValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PRACTITIONER = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Practitioner practitioner;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalPractitionerValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalPractitionerValue instance) {
        Objects.requireNonNull(instance, "instance");
        practitioner(instance.practitioner());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalPractitionerValue#practitioner() practitioner} attribute.
       * @param practitioner The value for practitioner 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("practitioner")
      public final Builder practitioner(Practitioner practitioner) {
        this.practitioner = Objects.requireNonNull(practitioner, "practitioner");
        initBits &= ~INIT_BIT_PRACTITIONER;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalPractitionerValue InternalPractitionerValue}.
       * @return An immutable instance of InternalPractitionerValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalPractitionerValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalPractitionerValue(practitioner);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PRACTITIONER) != 0) attributes.add("practitioner");
        return "Cannot build InternalPractitionerValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCoverageValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCoverageValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCoverageValue", generator = "Immutables")
  @Immutable
  static final class InternalCoverageValue implements ResourceList.InternalCoverageValue {
    private final Coverage coverage;

    private InternalCoverageValue(Coverage coverage) {
      this.coverage = coverage;
    }

    /**
     * @return The value of the {@code coverage} attribute
     */
    @JsonProperty("coverage")
    @JsonValue
    @Override
    public Coverage coverage() {
      return coverage;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCoverageValue#coverage() coverage} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for coverage
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCoverageValue withCoverage(Coverage value) {
      if (this.coverage == value) return this;
      Coverage newValue = Objects.requireNonNull(value, "coverage");
      return new ImmutableResourceList.InternalCoverageValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCoverageValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCoverageValue
          && equalTo((ImmutableResourceList.InternalCoverageValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCoverageValue another) {
      return coverage.equals(another.coverage);
    }

    /**
     * Computes a hash code from attributes: {@code coverage}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + coverage.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCoverageValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCoverageValue{"
          + "coverage=" + coverage
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCoverageValue fromJson(Coverage jsonValue) {
      ImmutableResourceList.InternalCoverageValue.Builder builder = ImmutableResourceList.InternalCoverageValue.builder();
      builder.coverage(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCoverageValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCoverageValue instance
     */
    public static ImmutableResourceList.InternalCoverageValue copyOf(ResourceList.InternalCoverageValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCoverageValue) {
        return (ImmutableResourceList.InternalCoverageValue) instance;
      }
      return ImmutableResourceList.InternalCoverageValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCoverageValue InternalCoverageValue}.
     * <pre>
     * ImmutableResourceList.InternalCoverageValue.builder()
     *    .coverage(com.fhir.types.fhir.Coverage) // required {@link ResourceList.InternalCoverageValue#coverage() coverage}
     *    .build();
     * </pre>
     * @return A new InternalCoverageValue builder
     */
    public static ImmutableResourceList.InternalCoverageValue.Builder builder() {
      return new ImmutableResourceList.InternalCoverageValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCoverageValue InternalCoverageValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCoverageValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_COVERAGE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Coverage coverage;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCoverageValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCoverageValue instance) {
        Objects.requireNonNull(instance, "instance");
        coverage(instance.coverage());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCoverageValue#coverage() coverage} attribute.
       * @param coverage The value for coverage 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("coverage")
      public final Builder coverage(Coverage coverage) {
        this.coverage = Objects.requireNonNull(coverage, "coverage");
        initBits &= ~INIT_BIT_COVERAGE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCoverageValue InternalCoverageValue}.
       * @return An immutable instance of InternalCoverageValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCoverageValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCoverageValue(coverage);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_COVERAGE) != 0) attributes.add("coverage");
        return "Cannot build InternalCoverageValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalResearchDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalResearchDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalResearchDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalResearchDefinitionValue
      implements ResourceList.InternalResearchDefinitionValue {
    private final ResearchDefinition researchDefinition;

    private InternalResearchDefinitionValue(ResearchDefinition researchDefinition) {
      this.researchDefinition = researchDefinition;
    }

    /**
     * @return The value of the {@code researchDefinition} attribute
     */
    @JsonProperty("researchDefinition")
    @JsonValue
    @Override
    public ResearchDefinition researchDefinition() {
      return researchDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalResearchDefinitionValue#researchDefinition() researchDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for researchDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalResearchDefinitionValue withResearchDefinition(ResearchDefinition value) {
      if (this.researchDefinition == value) return this;
      ResearchDefinition newValue = Objects.requireNonNull(value, "researchDefinition");
      return new ImmutableResourceList.InternalResearchDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalResearchDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalResearchDefinitionValue
          && equalTo((ImmutableResourceList.InternalResearchDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalResearchDefinitionValue another) {
      return researchDefinition.equals(another.researchDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code researchDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + researchDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalResearchDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalResearchDefinitionValue{"
          + "researchDefinition=" + researchDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalResearchDefinitionValue fromJson(ResearchDefinition jsonValue) {
      ImmutableResourceList.InternalResearchDefinitionValue.Builder builder = ImmutableResourceList.InternalResearchDefinitionValue.builder();
      builder.researchDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalResearchDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalResearchDefinitionValue instance
     */
    public static ImmutableResourceList.InternalResearchDefinitionValue copyOf(ResourceList.InternalResearchDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalResearchDefinitionValue) {
        return (ImmutableResourceList.InternalResearchDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalResearchDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalResearchDefinitionValue InternalResearchDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalResearchDefinitionValue.builder()
     *    .researchDefinition(com.fhir.types.fhir.ResearchDefinition) // required {@link ResourceList.InternalResearchDefinitionValue#researchDefinition() researchDefinition}
     *    .build();
     * </pre>
     * @return A new InternalResearchDefinitionValue builder
     */
    public static ImmutableResourceList.InternalResearchDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalResearchDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalResearchDefinitionValue InternalResearchDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalResearchDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_RESEARCH_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ResearchDefinition researchDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalResearchDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalResearchDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        researchDefinition(instance.researchDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalResearchDefinitionValue#researchDefinition() researchDefinition} attribute.
       * @param researchDefinition The value for researchDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("researchDefinition")
      public final Builder researchDefinition(ResearchDefinition researchDefinition) {
        this.researchDefinition = Objects.requireNonNull(researchDefinition, "researchDefinition");
        initBits &= ~INIT_BIT_RESEARCH_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalResearchDefinitionValue InternalResearchDefinitionValue}.
       * @return An immutable instance of InternalResearchDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalResearchDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalResearchDefinitionValue(researchDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_RESEARCH_DEFINITION) != 0) attributes.add("researchDefinition");
        return "Cannot build InternalResearchDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalResearchStudyValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalResearchStudyValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalResearchStudyValue", generator = "Immutables")
  @Immutable
  static final class InternalResearchStudyValue
      implements ResourceList.InternalResearchStudyValue {
    private final ResearchStudy researchStudy;

    private InternalResearchStudyValue(ResearchStudy researchStudy) {
      this.researchStudy = researchStudy;
    }

    /**
     * @return The value of the {@code researchStudy} attribute
     */
    @JsonProperty("researchStudy")
    @JsonValue
    @Override
    public ResearchStudy researchStudy() {
      return researchStudy;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalResearchStudyValue#researchStudy() researchStudy} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for researchStudy
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalResearchStudyValue withResearchStudy(ResearchStudy value) {
      if (this.researchStudy == value) return this;
      ResearchStudy newValue = Objects.requireNonNull(value, "researchStudy");
      return new ImmutableResourceList.InternalResearchStudyValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalResearchStudyValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalResearchStudyValue
          && equalTo((ImmutableResourceList.InternalResearchStudyValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalResearchStudyValue another) {
      return researchStudy.equals(another.researchStudy);
    }

    /**
     * Computes a hash code from attributes: {@code researchStudy}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + researchStudy.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalResearchStudyValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalResearchStudyValue{"
          + "researchStudy=" + researchStudy
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalResearchStudyValue fromJson(ResearchStudy jsonValue) {
      ImmutableResourceList.InternalResearchStudyValue.Builder builder = ImmutableResourceList.InternalResearchStudyValue.builder();
      builder.researchStudy(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalResearchStudyValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalResearchStudyValue instance
     */
    public static ImmutableResourceList.InternalResearchStudyValue copyOf(ResourceList.InternalResearchStudyValue instance) {
      if (instance instanceof ImmutableResourceList.InternalResearchStudyValue) {
        return (ImmutableResourceList.InternalResearchStudyValue) instance;
      }
      return ImmutableResourceList.InternalResearchStudyValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalResearchStudyValue InternalResearchStudyValue}.
     * <pre>
     * ImmutableResourceList.InternalResearchStudyValue.builder()
     *    .researchStudy(com.fhir.types.fhir.ResearchStudy) // required {@link ResourceList.InternalResearchStudyValue#researchStudy() researchStudy}
     *    .build();
     * </pre>
     * @return A new InternalResearchStudyValue builder
     */
    public static ImmutableResourceList.InternalResearchStudyValue.Builder builder() {
      return new ImmutableResourceList.InternalResearchStudyValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalResearchStudyValue InternalResearchStudyValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalResearchStudyValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_RESEARCH_STUDY = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ResearchStudy researchStudy;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalResearchStudyValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalResearchStudyValue instance) {
        Objects.requireNonNull(instance, "instance");
        researchStudy(instance.researchStudy());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalResearchStudyValue#researchStudy() researchStudy} attribute.
       * @param researchStudy The value for researchStudy 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("researchStudy")
      public final Builder researchStudy(ResearchStudy researchStudy) {
        this.researchStudy = Objects.requireNonNull(researchStudy, "researchStudy");
        initBits &= ~INIT_BIT_RESEARCH_STUDY;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalResearchStudyValue InternalResearchStudyValue}.
       * @return An immutable instance of InternalResearchStudyValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalResearchStudyValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalResearchStudyValue(researchStudy);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_RESEARCH_STUDY) != 0) attributes.add("researchStudy");
        return "Cannot build InternalResearchStudyValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalEvidenceValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalEvidenceValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalEvidenceValue", generator = "Immutables")
  @Immutable
  static final class InternalEvidenceValue implements ResourceList.InternalEvidenceValue {
    private final Evidence evidence;

    private InternalEvidenceValue(Evidence evidence) {
      this.evidence = evidence;
    }

    /**
     * @return The value of the {@code evidence} attribute
     */
    @JsonProperty("evidence")
    @JsonValue
    @Override
    public Evidence evidence() {
      return evidence;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalEvidenceValue#evidence() evidence} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for evidence
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalEvidenceValue withEvidence(Evidence value) {
      if (this.evidence == value) return this;
      Evidence newValue = Objects.requireNonNull(value, "evidence");
      return new ImmutableResourceList.InternalEvidenceValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalEvidenceValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalEvidenceValue
          && equalTo((ImmutableResourceList.InternalEvidenceValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalEvidenceValue another) {
      return evidence.equals(another.evidence);
    }

    /**
     * Computes a hash code from attributes: {@code evidence}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + evidence.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalEvidenceValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalEvidenceValue{"
          + "evidence=" + evidence
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalEvidenceValue fromJson(Evidence jsonValue) {
      ImmutableResourceList.InternalEvidenceValue.Builder builder = ImmutableResourceList.InternalEvidenceValue.builder();
      builder.evidence(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalEvidenceValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalEvidenceValue instance
     */
    public static ImmutableResourceList.InternalEvidenceValue copyOf(ResourceList.InternalEvidenceValue instance) {
      if (instance instanceof ImmutableResourceList.InternalEvidenceValue) {
        return (ImmutableResourceList.InternalEvidenceValue) instance;
      }
      return ImmutableResourceList.InternalEvidenceValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalEvidenceValue InternalEvidenceValue}.
     * <pre>
     * ImmutableResourceList.InternalEvidenceValue.builder()
     *    .evidence(com.fhir.types.fhir.Evidence) // required {@link ResourceList.InternalEvidenceValue#evidence() evidence}
     *    .build();
     * </pre>
     * @return A new InternalEvidenceValue builder
     */
    public static ImmutableResourceList.InternalEvidenceValue.Builder builder() {
      return new ImmutableResourceList.InternalEvidenceValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalEvidenceValue InternalEvidenceValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalEvidenceValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_EVIDENCE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Evidence evidence;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalEvidenceValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalEvidenceValue instance) {
        Objects.requireNonNull(instance, "instance");
        evidence(instance.evidence());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalEvidenceValue#evidence() evidence} attribute.
       * @param evidence The value for evidence 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("evidence")
      public final Builder evidence(Evidence evidence) {
        this.evidence = Objects.requireNonNull(evidence, "evidence");
        initBits &= ~INIT_BIT_EVIDENCE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalEvidenceValue InternalEvidenceValue}.
       * @return An immutable instance of InternalEvidenceValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalEvidenceValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalEvidenceValue(evidence);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_EVIDENCE) != 0) attributes.add("evidence");
        return "Cannot build InternalEvidenceValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalResearchSubjectValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalResearchSubjectValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalResearchSubjectValue", generator = "Immutables")
  @Immutable
  static final class InternalResearchSubjectValue
      implements ResourceList.InternalResearchSubjectValue {
    private final ResearchSubject researchSubject;

    private InternalResearchSubjectValue(ResearchSubject researchSubject) {
      this.researchSubject = researchSubject;
    }

    /**
     * @return The value of the {@code researchSubject} attribute
     */
    @JsonProperty("researchSubject")
    @JsonValue
    @Override
    public ResearchSubject researchSubject() {
      return researchSubject;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalResearchSubjectValue#researchSubject() researchSubject} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for researchSubject
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalResearchSubjectValue withResearchSubject(ResearchSubject value) {
      if (this.researchSubject == value) return this;
      ResearchSubject newValue = Objects.requireNonNull(value, "researchSubject");
      return new ImmutableResourceList.InternalResearchSubjectValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalResearchSubjectValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalResearchSubjectValue
          && equalTo((ImmutableResourceList.InternalResearchSubjectValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalResearchSubjectValue another) {
      return researchSubject.equals(another.researchSubject);
    }

    /**
     * Computes a hash code from attributes: {@code researchSubject}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + researchSubject.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalResearchSubjectValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalResearchSubjectValue{"
          + "researchSubject=" + researchSubject
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalResearchSubjectValue fromJson(ResearchSubject jsonValue) {
      ImmutableResourceList.InternalResearchSubjectValue.Builder builder = ImmutableResourceList.InternalResearchSubjectValue.builder();
      builder.researchSubject(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalResearchSubjectValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalResearchSubjectValue instance
     */
    public static ImmutableResourceList.InternalResearchSubjectValue copyOf(ResourceList.InternalResearchSubjectValue instance) {
      if (instance instanceof ImmutableResourceList.InternalResearchSubjectValue) {
        return (ImmutableResourceList.InternalResearchSubjectValue) instance;
      }
      return ImmutableResourceList.InternalResearchSubjectValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalResearchSubjectValue InternalResearchSubjectValue}.
     * <pre>
     * ImmutableResourceList.InternalResearchSubjectValue.builder()
     *    .researchSubject(com.fhir.types.fhir.ResearchSubject) // required {@link ResourceList.InternalResearchSubjectValue#researchSubject() researchSubject}
     *    .build();
     * </pre>
     * @return A new InternalResearchSubjectValue builder
     */
    public static ImmutableResourceList.InternalResearchSubjectValue.Builder builder() {
      return new ImmutableResourceList.InternalResearchSubjectValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalResearchSubjectValue InternalResearchSubjectValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalResearchSubjectValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_RESEARCH_SUBJECT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ResearchSubject researchSubject;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalResearchSubjectValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalResearchSubjectValue instance) {
        Objects.requireNonNull(instance, "instance");
        researchSubject(instance.researchSubject());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalResearchSubjectValue#researchSubject() researchSubject} attribute.
       * @param researchSubject The value for researchSubject 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("researchSubject")
      public final Builder researchSubject(ResearchSubject researchSubject) {
        this.researchSubject = Objects.requireNonNull(researchSubject, "researchSubject");
        initBits &= ~INIT_BIT_RESEARCH_SUBJECT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalResearchSubjectValue InternalResearchSubjectValue}.
       * @return An immutable instance of InternalResearchSubjectValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalResearchSubjectValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalResearchSubjectValue(researchSubject);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_RESEARCH_SUBJECT) != 0) attributes.add("researchSubject");
        return "Cannot build InternalResearchSubjectValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalVisionPrescriptionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalVisionPrescriptionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalVisionPrescriptionValue", generator = "Immutables")
  @Immutable
  static final class InternalVisionPrescriptionValue
      implements ResourceList.InternalVisionPrescriptionValue {
    private final VisionPrescription visionPrescription;

    private InternalVisionPrescriptionValue(VisionPrescription visionPrescription) {
      this.visionPrescription = visionPrescription;
    }

    /**
     * @return The value of the {@code visionPrescription} attribute
     */
    @JsonProperty("visionPrescription")
    @JsonValue
    @Override
    public VisionPrescription visionPrescription() {
      return visionPrescription;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalVisionPrescriptionValue#visionPrescription() visionPrescription} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for visionPrescription
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalVisionPrescriptionValue withVisionPrescription(VisionPrescription value) {
      if (this.visionPrescription == value) return this;
      VisionPrescription newValue = Objects.requireNonNull(value, "visionPrescription");
      return new ImmutableResourceList.InternalVisionPrescriptionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalVisionPrescriptionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalVisionPrescriptionValue
          && equalTo((ImmutableResourceList.InternalVisionPrescriptionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalVisionPrescriptionValue another) {
      return visionPrescription.equals(another.visionPrescription);
    }

    /**
     * Computes a hash code from attributes: {@code visionPrescription}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + visionPrescription.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalVisionPrescriptionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalVisionPrescriptionValue{"
          + "visionPrescription=" + visionPrescription
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalVisionPrescriptionValue fromJson(VisionPrescription jsonValue) {
      ImmutableResourceList.InternalVisionPrescriptionValue.Builder builder = ImmutableResourceList.InternalVisionPrescriptionValue.builder();
      builder.visionPrescription(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalVisionPrescriptionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalVisionPrescriptionValue instance
     */
    public static ImmutableResourceList.InternalVisionPrescriptionValue copyOf(ResourceList.InternalVisionPrescriptionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalVisionPrescriptionValue) {
        return (ImmutableResourceList.InternalVisionPrescriptionValue) instance;
      }
      return ImmutableResourceList.InternalVisionPrescriptionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalVisionPrescriptionValue InternalVisionPrescriptionValue}.
     * <pre>
     * ImmutableResourceList.InternalVisionPrescriptionValue.builder()
     *    .visionPrescription(com.fhir.types.fhir.VisionPrescription) // required {@link ResourceList.InternalVisionPrescriptionValue#visionPrescription() visionPrescription}
     *    .build();
     * </pre>
     * @return A new InternalVisionPrescriptionValue builder
     */
    public static ImmutableResourceList.InternalVisionPrescriptionValue.Builder builder() {
      return new ImmutableResourceList.InternalVisionPrescriptionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalVisionPrescriptionValue InternalVisionPrescriptionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalVisionPrescriptionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_VISION_PRESCRIPTION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable VisionPrescription visionPrescription;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalVisionPrescriptionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalVisionPrescriptionValue instance) {
        Objects.requireNonNull(instance, "instance");
        visionPrescription(instance.visionPrescription());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalVisionPrescriptionValue#visionPrescription() visionPrescription} attribute.
       * @param visionPrescription The value for visionPrescription 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("visionPrescription")
      public final Builder visionPrescription(VisionPrescription visionPrescription) {
        this.visionPrescription = Objects.requireNonNull(visionPrescription, "visionPrescription");
        initBits &= ~INIT_BIT_VISION_PRESCRIPTION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalVisionPrescriptionValue InternalVisionPrescriptionValue}.
       * @return An immutable instance of InternalVisionPrescriptionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalVisionPrescriptionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalVisionPrescriptionValue(visionPrescription);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_VISION_PRESCRIPTION) != 0) attributes.add("visionPrescription");
        return "Cannot build InternalVisionPrescriptionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalChargeItemDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalChargeItemDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalChargeItemDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalChargeItemDefinitionValue
      implements ResourceList.InternalChargeItemDefinitionValue {
    private final ChargeItemDefinition chargeItemDefinition;

    private InternalChargeItemDefinitionValue(ChargeItemDefinition chargeItemDefinition) {
      this.chargeItemDefinition = chargeItemDefinition;
    }

    /**
     * @return The value of the {@code chargeItemDefinition} attribute
     */
    @JsonProperty("chargeItemDefinition")
    @JsonValue
    @Override
    public ChargeItemDefinition chargeItemDefinition() {
      return chargeItemDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalChargeItemDefinitionValue#chargeItemDefinition() chargeItemDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for chargeItemDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalChargeItemDefinitionValue withChargeItemDefinition(ChargeItemDefinition value) {
      if (this.chargeItemDefinition == value) return this;
      ChargeItemDefinition newValue = Objects.requireNonNull(value, "chargeItemDefinition");
      return new ImmutableResourceList.InternalChargeItemDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalChargeItemDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalChargeItemDefinitionValue
          && equalTo((ImmutableResourceList.InternalChargeItemDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalChargeItemDefinitionValue another) {
      return chargeItemDefinition.equals(another.chargeItemDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code chargeItemDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + chargeItemDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalChargeItemDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalChargeItemDefinitionValue{"
          + "chargeItemDefinition=" + chargeItemDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalChargeItemDefinitionValue fromJson(ChargeItemDefinition jsonValue) {
      ImmutableResourceList.InternalChargeItemDefinitionValue.Builder builder = ImmutableResourceList.InternalChargeItemDefinitionValue.builder();
      builder.chargeItemDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalChargeItemDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalChargeItemDefinitionValue instance
     */
    public static ImmutableResourceList.InternalChargeItemDefinitionValue copyOf(ResourceList.InternalChargeItemDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalChargeItemDefinitionValue) {
        return (ImmutableResourceList.InternalChargeItemDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalChargeItemDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalChargeItemDefinitionValue InternalChargeItemDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalChargeItemDefinitionValue.builder()
     *    .chargeItemDefinition(com.fhir.types.fhir.ChargeItemDefinition) // required {@link ResourceList.InternalChargeItemDefinitionValue#chargeItemDefinition() chargeItemDefinition}
     *    .build();
     * </pre>
     * @return A new InternalChargeItemDefinitionValue builder
     */
    public static ImmutableResourceList.InternalChargeItemDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalChargeItemDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalChargeItemDefinitionValue InternalChargeItemDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalChargeItemDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CHARGE_ITEM_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ChargeItemDefinition chargeItemDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalChargeItemDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalChargeItemDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        chargeItemDefinition(instance.chargeItemDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalChargeItemDefinitionValue#chargeItemDefinition() chargeItemDefinition} attribute.
       * @param chargeItemDefinition The value for chargeItemDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("chargeItemDefinition")
      public final Builder chargeItemDefinition(ChargeItemDefinition chargeItemDefinition) {
        this.chargeItemDefinition = Objects.requireNonNull(chargeItemDefinition, "chargeItemDefinition");
        initBits &= ~INIT_BIT_CHARGE_ITEM_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalChargeItemDefinitionValue InternalChargeItemDefinitionValue}.
       * @return An immutable instance of InternalChargeItemDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalChargeItemDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalChargeItemDefinitionValue(chargeItemDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CHARGE_ITEM_DEFINITION) != 0) attributes.add("chargeItemDefinition");
        return "Cannot build InternalChargeItemDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalConditionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalConditionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalConditionValue", generator = "Immutables")
  @Immutable
  static final class InternalConditionValue implements ResourceList.InternalConditionValue {
    private final Condition condition;

    private InternalConditionValue(Condition condition) {
      this.condition = condition;
    }

    /**
     * @return The value of the {@code condition} attribute
     */
    @JsonProperty("condition")
    @JsonValue
    @Override
    public Condition condition() {
      return condition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalConditionValue#condition() condition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for condition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalConditionValue withCondition(Condition value) {
      if (this.condition == value) return this;
      Condition newValue = Objects.requireNonNull(value, "condition");
      return new ImmutableResourceList.InternalConditionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalConditionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalConditionValue
          && equalTo((ImmutableResourceList.InternalConditionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalConditionValue another) {
      return condition.equals(another.condition);
    }

    /**
     * Computes a hash code from attributes: {@code condition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + condition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalConditionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalConditionValue{"
          + "condition=" + condition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalConditionValue fromJson(Condition jsonValue) {
      ImmutableResourceList.InternalConditionValue.Builder builder = ImmutableResourceList.InternalConditionValue.builder();
      builder.condition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalConditionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalConditionValue instance
     */
    public static ImmutableResourceList.InternalConditionValue copyOf(ResourceList.InternalConditionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalConditionValue) {
        return (ImmutableResourceList.InternalConditionValue) instance;
      }
      return ImmutableResourceList.InternalConditionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalConditionValue InternalConditionValue}.
     * <pre>
     * ImmutableResourceList.InternalConditionValue.builder()
     *    .condition(com.fhir.types.fhir.Condition) // required {@link ResourceList.InternalConditionValue#condition() condition}
     *    .build();
     * </pre>
     * @return A new InternalConditionValue builder
     */
    public static ImmutableResourceList.InternalConditionValue.Builder builder() {
      return new ImmutableResourceList.InternalConditionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalConditionValue InternalConditionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalConditionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CONDITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Condition condition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalConditionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalConditionValue instance) {
        Objects.requireNonNull(instance, "instance");
        condition(instance.condition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalConditionValue#condition() condition} attribute.
       * @param condition The value for condition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("condition")
      public final Builder condition(Condition condition) {
        this.condition = Objects.requireNonNull(condition, "condition");
        initBits &= ~INIT_BIT_CONDITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalConditionValue InternalConditionValue}.
       * @return An immutable instance of InternalConditionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalConditionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalConditionValue(condition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CONDITION) != 0) attributes.add("condition");
        return "Cannot build InternalConditionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalPersonValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalPersonValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalPersonValue", generator = "Immutables")
  @Immutable
  static final class InternalPersonValue implements ResourceList.InternalPersonValue {
    private final Person person;

    private InternalPersonValue(Person person) {
      this.person = person;
    }

    /**
     * @return The value of the {@code person} attribute
     */
    @JsonProperty("person")
    @JsonValue
    @Override
    public Person person() {
      return person;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalPersonValue#person() person} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for person
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalPersonValue withPerson(Person value) {
      if (this.person == value) return this;
      Person newValue = Objects.requireNonNull(value, "person");
      return new ImmutableResourceList.InternalPersonValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalPersonValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalPersonValue
          && equalTo((ImmutableResourceList.InternalPersonValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalPersonValue another) {
      return person.equals(another.person);
    }

    /**
     * Computes a hash code from attributes: {@code person}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + person.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalPersonValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalPersonValue{"
          + "person=" + person
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalPersonValue fromJson(Person jsonValue) {
      ImmutableResourceList.InternalPersonValue.Builder builder = ImmutableResourceList.InternalPersonValue.builder();
      builder.person(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalPersonValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalPersonValue instance
     */
    public static ImmutableResourceList.InternalPersonValue copyOf(ResourceList.InternalPersonValue instance) {
      if (instance instanceof ImmutableResourceList.InternalPersonValue) {
        return (ImmutableResourceList.InternalPersonValue) instance;
      }
      return ImmutableResourceList.InternalPersonValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalPersonValue InternalPersonValue}.
     * <pre>
     * ImmutableResourceList.InternalPersonValue.builder()
     *    .person(com.fhir.types.fhir.Person) // required {@link ResourceList.InternalPersonValue#person() person}
     *    .build();
     * </pre>
     * @return A new InternalPersonValue builder
     */
    public static ImmutableResourceList.InternalPersonValue.Builder builder() {
      return new ImmutableResourceList.InternalPersonValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalPersonValue InternalPersonValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalPersonValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PERSON = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Person person;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalPersonValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalPersonValue instance) {
        Objects.requireNonNull(instance, "instance");
        person(instance.person());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalPersonValue#person() person} attribute.
       * @param person The value for person 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("person")
      public final Builder person(Person person) {
        this.person = Objects.requireNonNull(person, "person");
        initBits &= ~INIT_BIT_PERSON;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalPersonValue InternalPersonValue}.
       * @return An immutable instance of InternalPersonValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalPersonValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalPersonValue(person);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PERSON) != 0) attributes.add("person");
        return "Cannot build InternalPersonValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalRiskEvidenceSynthesisValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalRiskEvidenceSynthesisValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalRiskEvidenceSynthesisValue", generator = "Immutables")
  @Immutable
  static final class InternalRiskEvidenceSynthesisValue
      implements ResourceList.InternalRiskEvidenceSynthesisValue {
    private final RiskEvidenceSynthesis riskEvidenceSynthesis;

    private InternalRiskEvidenceSynthesisValue(RiskEvidenceSynthesis riskEvidenceSynthesis) {
      this.riskEvidenceSynthesis = riskEvidenceSynthesis;
    }

    /**
     * @return The value of the {@code riskEvidenceSynthesis} attribute
     */
    @JsonProperty("riskEvidenceSynthesis")
    @JsonValue
    @Override
    public RiskEvidenceSynthesis riskEvidenceSynthesis() {
      return riskEvidenceSynthesis;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalRiskEvidenceSynthesisValue#riskEvidenceSynthesis() riskEvidenceSynthesis} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for riskEvidenceSynthesis
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalRiskEvidenceSynthesisValue withRiskEvidenceSynthesis(RiskEvidenceSynthesis value) {
      if (this.riskEvidenceSynthesis == value) return this;
      RiskEvidenceSynthesis newValue = Objects.requireNonNull(value, "riskEvidenceSynthesis");
      return new ImmutableResourceList.InternalRiskEvidenceSynthesisValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalRiskEvidenceSynthesisValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalRiskEvidenceSynthesisValue
          && equalTo((ImmutableResourceList.InternalRiskEvidenceSynthesisValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalRiskEvidenceSynthesisValue another) {
      return riskEvidenceSynthesis.equals(another.riskEvidenceSynthesis);
    }

    /**
     * Computes a hash code from attributes: {@code riskEvidenceSynthesis}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + riskEvidenceSynthesis.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalRiskEvidenceSynthesisValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalRiskEvidenceSynthesisValue{"
          + "riskEvidenceSynthesis=" + riskEvidenceSynthesis
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalRiskEvidenceSynthesisValue fromJson(RiskEvidenceSynthesis jsonValue) {
      ImmutableResourceList.InternalRiskEvidenceSynthesisValue.Builder builder = ImmutableResourceList.InternalRiskEvidenceSynthesisValue.builder();
      builder.riskEvidenceSynthesis(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalRiskEvidenceSynthesisValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalRiskEvidenceSynthesisValue instance
     */
    public static ImmutableResourceList.InternalRiskEvidenceSynthesisValue copyOf(ResourceList.InternalRiskEvidenceSynthesisValue instance) {
      if (instance instanceof ImmutableResourceList.InternalRiskEvidenceSynthesisValue) {
        return (ImmutableResourceList.InternalRiskEvidenceSynthesisValue) instance;
      }
      return ImmutableResourceList.InternalRiskEvidenceSynthesisValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalRiskEvidenceSynthesisValue InternalRiskEvidenceSynthesisValue}.
     * <pre>
     * ImmutableResourceList.InternalRiskEvidenceSynthesisValue.builder()
     *    .riskEvidenceSynthesis(com.fhir.types.fhir.RiskEvidenceSynthesis) // required {@link ResourceList.InternalRiskEvidenceSynthesisValue#riskEvidenceSynthesis() riskEvidenceSynthesis}
     *    .build();
     * </pre>
     * @return A new InternalRiskEvidenceSynthesisValue builder
     */
    public static ImmutableResourceList.InternalRiskEvidenceSynthesisValue.Builder builder() {
      return new ImmutableResourceList.InternalRiskEvidenceSynthesisValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalRiskEvidenceSynthesisValue InternalRiskEvidenceSynthesisValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalRiskEvidenceSynthesisValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_RISK_EVIDENCE_SYNTHESIS = 0x1L;
      private long initBits = 0x1L;

      private @Nullable RiskEvidenceSynthesis riskEvidenceSynthesis;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalRiskEvidenceSynthesisValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalRiskEvidenceSynthesisValue instance) {
        Objects.requireNonNull(instance, "instance");
        riskEvidenceSynthesis(instance.riskEvidenceSynthesis());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalRiskEvidenceSynthesisValue#riskEvidenceSynthesis() riskEvidenceSynthesis} attribute.
       * @param riskEvidenceSynthesis The value for riskEvidenceSynthesis 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("riskEvidenceSynthesis")
      public final Builder riskEvidenceSynthesis(RiskEvidenceSynthesis riskEvidenceSynthesis) {
        this.riskEvidenceSynthesis = Objects.requireNonNull(riskEvidenceSynthesis, "riskEvidenceSynthesis");
        initBits &= ~INIT_BIT_RISK_EVIDENCE_SYNTHESIS;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalRiskEvidenceSynthesisValue InternalRiskEvidenceSynthesisValue}.
       * @return An immutable instance of InternalRiskEvidenceSynthesisValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalRiskEvidenceSynthesisValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalRiskEvidenceSynthesisValue(riskEvidenceSynthesis);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_RISK_EVIDENCE_SYNTHESIS) != 0) attributes.add("riskEvidenceSynthesis");
        return "Cannot build InternalRiskEvidenceSynthesisValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSearchParameterValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSearchParameterValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSearchParameterValue", generator = "Immutables")
  @Immutable
  static final class InternalSearchParameterValue
      implements ResourceList.InternalSearchParameterValue {
    private final SearchParameter searchParameter;

    private InternalSearchParameterValue(SearchParameter searchParameter) {
      this.searchParameter = searchParameter;
    }

    /**
     * @return The value of the {@code searchParameter} attribute
     */
    @JsonProperty("searchParameter")
    @JsonValue
    @Override
    public SearchParameter searchParameter() {
      return searchParameter;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSearchParameterValue#searchParameter() searchParameter} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for searchParameter
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSearchParameterValue withSearchParameter(SearchParameter value) {
      if (this.searchParameter == value) return this;
      SearchParameter newValue = Objects.requireNonNull(value, "searchParameter");
      return new ImmutableResourceList.InternalSearchParameterValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSearchParameterValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSearchParameterValue
          && equalTo((ImmutableResourceList.InternalSearchParameterValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSearchParameterValue another) {
      return searchParameter.equals(another.searchParameter);
    }

    /**
     * Computes a hash code from attributes: {@code searchParameter}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + searchParameter.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSearchParameterValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSearchParameterValue{"
          + "searchParameter=" + searchParameter
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSearchParameterValue fromJson(SearchParameter jsonValue) {
      ImmutableResourceList.InternalSearchParameterValue.Builder builder = ImmutableResourceList.InternalSearchParameterValue.builder();
      builder.searchParameter(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSearchParameterValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSearchParameterValue instance
     */
    public static ImmutableResourceList.InternalSearchParameterValue copyOf(ResourceList.InternalSearchParameterValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSearchParameterValue) {
        return (ImmutableResourceList.InternalSearchParameterValue) instance;
      }
      return ImmutableResourceList.InternalSearchParameterValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSearchParameterValue InternalSearchParameterValue}.
     * <pre>
     * ImmutableResourceList.InternalSearchParameterValue.builder()
     *    .searchParameter(com.fhir.types.fhir.SearchParameter) // required {@link ResourceList.InternalSearchParameterValue#searchParameter() searchParameter}
     *    .build();
     * </pre>
     * @return A new InternalSearchParameterValue builder
     */
    public static ImmutableResourceList.InternalSearchParameterValue.Builder builder() {
      return new ImmutableResourceList.InternalSearchParameterValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSearchParameterValue InternalSearchParameterValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSearchParameterValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SEARCH_PARAMETER = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SearchParameter searchParameter;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSearchParameterValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSearchParameterValue instance) {
        Objects.requireNonNull(instance, "instance");
        searchParameter(instance.searchParameter());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSearchParameterValue#searchParameter() searchParameter} attribute.
       * @param searchParameter The value for searchParameter 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("searchParameter")
      public final Builder searchParameter(SearchParameter searchParameter) {
        this.searchParameter = Objects.requireNonNull(searchParameter, "searchParameter");
        initBits &= ~INIT_BIT_SEARCH_PARAMETER;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSearchParameterValue InternalSearchParameterValue}.
       * @return An immutable instance of InternalSearchParameterValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSearchParameterValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSearchParameterValue(searchParameter);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SEARCH_PARAMETER) != 0) attributes.add("searchParameter");
        return "Cannot build InternalSearchParameterValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalInsurancePlanValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalInsurancePlanValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalInsurancePlanValue", generator = "Immutables")
  @Immutable
  static final class InternalInsurancePlanValue
      implements ResourceList.InternalInsurancePlanValue {
    private final InsurancePlan insurancePlan;

    private InternalInsurancePlanValue(InsurancePlan insurancePlan) {
      this.insurancePlan = insurancePlan;
    }

    /**
     * @return The value of the {@code insurancePlan} attribute
     */
    @JsonProperty("insurancePlan")
    @JsonValue
    @Override
    public InsurancePlan insurancePlan() {
      return insurancePlan;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalInsurancePlanValue#insurancePlan() insurancePlan} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for insurancePlan
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalInsurancePlanValue withInsurancePlan(InsurancePlan value) {
      if (this.insurancePlan == value) return this;
      InsurancePlan newValue = Objects.requireNonNull(value, "insurancePlan");
      return new ImmutableResourceList.InternalInsurancePlanValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalInsurancePlanValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalInsurancePlanValue
          && equalTo((ImmutableResourceList.InternalInsurancePlanValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalInsurancePlanValue another) {
      return insurancePlan.equals(another.insurancePlan);
    }

    /**
     * Computes a hash code from attributes: {@code insurancePlan}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + insurancePlan.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalInsurancePlanValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalInsurancePlanValue{"
          + "insurancePlan=" + insurancePlan
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalInsurancePlanValue fromJson(InsurancePlan jsonValue) {
      ImmutableResourceList.InternalInsurancePlanValue.Builder builder = ImmutableResourceList.InternalInsurancePlanValue.builder();
      builder.insurancePlan(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalInsurancePlanValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalInsurancePlanValue instance
     */
    public static ImmutableResourceList.InternalInsurancePlanValue copyOf(ResourceList.InternalInsurancePlanValue instance) {
      if (instance instanceof ImmutableResourceList.InternalInsurancePlanValue) {
        return (ImmutableResourceList.InternalInsurancePlanValue) instance;
      }
      return ImmutableResourceList.InternalInsurancePlanValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalInsurancePlanValue InternalInsurancePlanValue}.
     * <pre>
     * ImmutableResourceList.InternalInsurancePlanValue.builder()
     *    .insurancePlan(com.fhir.types.fhir.InsurancePlan) // required {@link ResourceList.InternalInsurancePlanValue#insurancePlan() insurancePlan}
     *    .build();
     * </pre>
     * @return A new InternalInsurancePlanValue builder
     */
    public static ImmutableResourceList.InternalInsurancePlanValue.Builder builder() {
      return new ImmutableResourceList.InternalInsurancePlanValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalInsurancePlanValue InternalInsurancePlanValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalInsurancePlanValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_INSURANCE_PLAN = 0x1L;
      private long initBits = 0x1L;

      private @Nullable InsurancePlan insurancePlan;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalInsurancePlanValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalInsurancePlanValue instance) {
        Objects.requireNonNull(instance, "instance");
        insurancePlan(instance.insurancePlan());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalInsurancePlanValue#insurancePlan() insurancePlan} attribute.
       * @param insurancePlan The value for insurancePlan 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("insurancePlan")
      public final Builder insurancePlan(InsurancePlan insurancePlan) {
        this.insurancePlan = Objects.requireNonNull(insurancePlan, "insurancePlan");
        initBits &= ~INIT_BIT_INSURANCE_PLAN;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalInsurancePlanValue InternalInsurancePlanValue}.
       * @return An immutable instance of InternalInsurancePlanValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalInsurancePlanValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalInsurancePlanValue(insurancePlan);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_INSURANCE_PLAN) != 0) attributes.add("insurancePlan");
        return "Cannot build InternalInsurancePlanValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalPasswordChangeRequestValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalPasswordChangeRequestValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalPasswordChangeRequestValue", generator = "Immutables")
  @Immutable
  static final class InternalPasswordChangeRequestValue
      implements ResourceList.InternalPasswordChangeRequestValue {
    private final PasswordChangeRequest passwordChangeRequest;

    private InternalPasswordChangeRequestValue(PasswordChangeRequest passwordChangeRequest) {
      this.passwordChangeRequest = passwordChangeRequest;
    }

    /**
     * @return The value of the {@code passwordChangeRequest} attribute
     */
    @JsonProperty("passwordChangeRequest")
    @JsonValue
    @Override
    public PasswordChangeRequest passwordChangeRequest() {
      return passwordChangeRequest;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalPasswordChangeRequestValue#passwordChangeRequest() passwordChangeRequest} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for passwordChangeRequest
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalPasswordChangeRequestValue withPasswordChangeRequest(PasswordChangeRequest value) {
      if (this.passwordChangeRequest == value) return this;
      PasswordChangeRequest newValue = Objects.requireNonNull(value, "passwordChangeRequest");
      return new ImmutableResourceList.InternalPasswordChangeRequestValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalPasswordChangeRequestValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalPasswordChangeRequestValue
          && equalTo((ImmutableResourceList.InternalPasswordChangeRequestValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalPasswordChangeRequestValue another) {
      return passwordChangeRequest.equals(another.passwordChangeRequest);
    }

    /**
     * Computes a hash code from attributes: {@code passwordChangeRequest}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + passwordChangeRequest.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalPasswordChangeRequestValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalPasswordChangeRequestValue{"
          + "passwordChangeRequest=" + passwordChangeRequest
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalPasswordChangeRequestValue fromJson(PasswordChangeRequest jsonValue) {
      ImmutableResourceList.InternalPasswordChangeRequestValue.Builder builder = ImmutableResourceList.InternalPasswordChangeRequestValue.builder();
      builder.passwordChangeRequest(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalPasswordChangeRequestValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalPasswordChangeRequestValue instance
     */
    public static ImmutableResourceList.InternalPasswordChangeRequestValue copyOf(ResourceList.InternalPasswordChangeRequestValue instance) {
      if (instance instanceof ImmutableResourceList.InternalPasswordChangeRequestValue) {
        return (ImmutableResourceList.InternalPasswordChangeRequestValue) instance;
      }
      return ImmutableResourceList.InternalPasswordChangeRequestValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalPasswordChangeRequestValue InternalPasswordChangeRequestValue}.
     * <pre>
     * ImmutableResourceList.InternalPasswordChangeRequestValue.builder()
     *    .passwordChangeRequest(com.fhir.types.fhir.PasswordChangeRequest) // required {@link ResourceList.InternalPasswordChangeRequestValue#passwordChangeRequest() passwordChangeRequest}
     *    .build();
     * </pre>
     * @return A new InternalPasswordChangeRequestValue builder
     */
    public static ImmutableResourceList.InternalPasswordChangeRequestValue.Builder builder() {
      return new ImmutableResourceList.InternalPasswordChangeRequestValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalPasswordChangeRequestValue InternalPasswordChangeRequestValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalPasswordChangeRequestValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PASSWORD_CHANGE_REQUEST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable PasswordChangeRequest passwordChangeRequest;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalPasswordChangeRequestValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalPasswordChangeRequestValue instance) {
        Objects.requireNonNull(instance, "instance");
        passwordChangeRequest(instance.passwordChangeRequest());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalPasswordChangeRequestValue#passwordChangeRequest() passwordChangeRequest} attribute.
       * @param passwordChangeRequest The value for passwordChangeRequest 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("passwordChangeRequest")
      public final Builder passwordChangeRequest(PasswordChangeRequest passwordChangeRequest) {
        this.passwordChangeRequest = Objects.requireNonNull(passwordChangeRequest, "passwordChangeRequest");
        initBits &= ~INIT_BIT_PASSWORD_CHANGE_REQUEST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalPasswordChangeRequestValue InternalPasswordChangeRequestValue}.
       * @return An immutable instance of InternalPasswordChangeRequestValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalPasswordChangeRequestValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalPasswordChangeRequestValue(passwordChangeRequest);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PASSWORD_CHANGE_REQUEST) != 0) attributes.add("passwordChangeRequest");
        return "Cannot build InternalPasswordChangeRequestValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalStructureMapValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalStructureMapValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalStructureMapValue", generator = "Immutables")
  @Immutable
  static final class InternalStructureMapValue
      implements ResourceList.InternalStructureMapValue {
    private final StructureMap structureMap;

    private InternalStructureMapValue(StructureMap structureMap) {
      this.structureMap = structureMap;
    }

    /**
     * @return The value of the {@code structureMap} attribute
     */
    @JsonProperty("structureMap")
    @JsonValue
    @Override
    public StructureMap structureMap() {
      return structureMap;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalStructureMapValue#structureMap() structureMap} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for structureMap
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalStructureMapValue withStructureMap(StructureMap value) {
      if (this.structureMap == value) return this;
      StructureMap newValue = Objects.requireNonNull(value, "structureMap");
      return new ImmutableResourceList.InternalStructureMapValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalStructureMapValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalStructureMapValue
          && equalTo((ImmutableResourceList.InternalStructureMapValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalStructureMapValue another) {
      return structureMap.equals(another.structureMap);
    }

    /**
     * Computes a hash code from attributes: {@code structureMap}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + structureMap.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalStructureMapValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalStructureMapValue{"
          + "structureMap=" + structureMap
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalStructureMapValue fromJson(StructureMap jsonValue) {
      ImmutableResourceList.InternalStructureMapValue.Builder builder = ImmutableResourceList.InternalStructureMapValue.builder();
      builder.structureMap(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalStructureMapValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalStructureMapValue instance
     */
    public static ImmutableResourceList.InternalStructureMapValue copyOf(ResourceList.InternalStructureMapValue instance) {
      if (instance instanceof ImmutableResourceList.InternalStructureMapValue) {
        return (ImmutableResourceList.InternalStructureMapValue) instance;
      }
      return ImmutableResourceList.InternalStructureMapValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalStructureMapValue InternalStructureMapValue}.
     * <pre>
     * ImmutableResourceList.InternalStructureMapValue.builder()
     *    .structureMap(com.fhir.types.fhir.StructureMap) // required {@link ResourceList.InternalStructureMapValue#structureMap() structureMap}
     *    .build();
     * </pre>
     * @return A new InternalStructureMapValue builder
     */
    public static ImmutableResourceList.InternalStructureMapValue.Builder builder() {
      return new ImmutableResourceList.InternalStructureMapValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalStructureMapValue InternalStructureMapValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalStructureMapValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_STRUCTURE_MAP = 0x1L;
      private long initBits = 0x1L;

      private @Nullable StructureMap structureMap;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalStructureMapValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalStructureMapValue instance) {
        Objects.requireNonNull(instance, "instance");
        structureMap(instance.structureMap());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalStructureMapValue#structureMap() structureMap} attribute.
       * @param structureMap The value for structureMap 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("structureMap")
      public final Builder structureMap(StructureMap structureMap) {
        this.structureMap = Objects.requireNonNull(structureMap, "structureMap");
        initBits &= ~INIT_BIT_STRUCTURE_MAP;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalStructureMapValue InternalStructureMapValue}.
       * @return An immutable instance of InternalStructureMapValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalStructureMapValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalStructureMapValue(structureMap);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_STRUCTURE_MAP) != 0) attributes.add("structureMap");
        return "Cannot build InternalStructureMapValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSubscriptionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSubscriptionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSubscriptionValue", generator = "Immutables")
  @Immutable
  static final class InternalSubscriptionValue
      implements ResourceList.InternalSubscriptionValue {
    private final Subscription subscription;

    private InternalSubscriptionValue(Subscription subscription) {
      this.subscription = subscription;
    }

    /**
     * @return The value of the {@code subscription} attribute
     */
    @JsonProperty("subscription")
    @JsonValue
    @Override
    public Subscription subscription() {
      return subscription;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSubscriptionValue#subscription() subscription} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for subscription
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSubscriptionValue withSubscription(Subscription value) {
      if (this.subscription == value) return this;
      Subscription newValue = Objects.requireNonNull(value, "subscription");
      return new ImmutableResourceList.InternalSubscriptionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSubscriptionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSubscriptionValue
          && equalTo((ImmutableResourceList.InternalSubscriptionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSubscriptionValue another) {
      return subscription.equals(another.subscription);
    }

    /**
     * Computes a hash code from attributes: {@code subscription}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + subscription.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSubscriptionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSubscriptionValue{"
          + "subscription=" + subscription
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSubscriptionValue fromJson(Subscription jsonValue) {
      ImmutableResourceList.InternalSubscriptionValue.Builder builder = ImmutableResourceList.InternalSubscriptionValue.builder();
      builder.subscription(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSubscriptionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSubscriptionValue instance
     */
    public static ImmutableResourceList.InternalSubscriptionValue copyOf(ResourceList.InternalSubscriptionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSubscriptionValue) {
        return (ImmutableResourceList.InternalSubscriptionValue) instance;
      }
      return ImmutableResourceList.InternalSubscriptionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSubscriptionValue InternalSubscriptionValue}.
     * <pre>
     * ImmutableResourceList.InternalSubscriptionValue.builder()
     *    .subscription(com.fhir.types.fhir.Subscription) // required {@link ResourceList.InternalSubscriptionValue#subscription() subscription}
     *    .build();
     * </pre>
     * @return A new InternalSubscriptionValue builder
     */
    public static ImmutableResourceList.InternalSubscriptionValue.Builder builder() {
      return new ImmutableResourceList.InternalSubscriptionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSubscriptionValue InternalSubscriptionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSubscriptionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUBSCRIPTION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Subscription subscription;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSubscriptionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSubscriptionValue instance) {
        Objects.requireNonNull(instance, "instance");
        subscription(instance.subscription());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSubscriptionValue#subscription() subscription} attribute.
       * @param subscription The value for subscription 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("subscription")
      public final Builder subscription(Subscription subscription) {
        this.subscription = Objects.requireNonNull(subscription, "subscription");
        initBits &= ~INIT_BIT_SUBSCRIPTION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSubscriptionValue InternalSubscriptionValue}.
       * @return An immutable instance of InternalSubscriptionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSubscriptionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSubscriptionValue(subscription);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUBSCRIPTION) != 0) attributes.add("subscription");
        return "Cannot build InternalSubscriptionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalOperationDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalOperationDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalOperationDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalOperationDefinitionValue
      implements ResourceList.InternalOperationDefinitionValue {
    private final OperationDefinition operationDefinition;

    private InternalOperationDefinitionValue(OperationDefinition operationDefinition) {
      this.operationDefinition = operationDefinition;
    }

    /**
     * @return The value of the {@code operationDefinition} attribute
     */
    @JsonProperty("operationDefinition")
    @JsonValue
    @Override
    public OperationDefinition operationDefinition() {
      return operationDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalOperationDefinitionValue#operationDefinition() operationDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for operationDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalOperationDefinitionValue withOperationDefinition(OperationDefinition value) {
      if (this.operationDefinition == value) return this;
      OperationDefinition newValue = Objects.requireNonNull(value, "operationDefinition");
      return new ImmutableResourceList.InternalOperationDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalOperationDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalOperationDefinitionValue
          && equalTo((ImmutableResourceList.InternalOperationDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalOperationDefinitionValue another) {
      return operationDefinition.equals(another.operationDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code operationDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + operationDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalOperationDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalOperationDefinitionValue{"
          + "operationDefinition=" + operationDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalOperationDefinitionValue fromJson(OperationDefinition jsonValue) {
      ImmutableResourceList.InternalOperationDefinitionValue.Builder builder = ImmutableResourceList.InternalOperationDefinitionValue.builder();
      builder.operationDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalOperationDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalOperationDefinitionValue instance
     */
    public static ImmutableResourceList.InternalOperationDefinitionValue copyOf(ResourceList.InternalOperationDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalOperationDefinitionValue) {
        return (ImmutableResourceList.InternalOperationDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalOperationDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalOperationDefinitionValue InternalOperationDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalOperationDefinitionValue.builder()
     *    .operationDefinition(com.fhir.types.fhir.OperationDefinition) // required {@link ResourceList.InternalOperationDefinitionValue#operationDefinition() operationDefinition}
     *    .build();
     * </pre>
     * @return A new InternalOperationDefinitionValue builder
     */
    public static ImmutableResourceList.InternalOperationDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalOperationDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalOperationDefinitionValue InternalOperationDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalOperationDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_OPERATION_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable OperationDefinition operationDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalOperationDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalOperationDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        operationDefinition(instance.operationDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalOperationDefinitionValue#operationDefinition() operationDefinition} attribute.
       * @param operationDefinition The value for operationDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("operationDefinition")
      public final Builder operationDefinition(OperationDefinition operationDefinition) {
        this.operationDefinition = Objects.requireNonNull(operationDefinition, "operationDefinition");
        initBits &= ~INIT_BIT_OPERATION_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalOperationDefinitionValue InternalOperationDefinitionValue}.
       * @return An immutable instance of InternalOperationDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalOperationDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalOperationDefinitionValue(operationDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_OPERATION_DEFINITION) != 0) attributes.add("operationDefinition");
        return "Cannot build InternalOperationDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalBotValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalBotValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalBotValue", generator = "Immutables")
  @Immutable
  static final class InternalBotValue implements ResourceList.InternalBotValue {
    private final Bot bot;

    private InternalBotValue(Bot bot) {
      this.bot = bot;
    }

    /**
     * @return The value of the {@code bot} attribute
     */
    @JsonProperty("bot")
    @JsonValue
    @Override
    public Bot bot() {
      return bot;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalBotValue#bot() bot} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for bot
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalBotValue withBot(Bot value) {
      if (this.bot == value) return this;
      Bot newValue = Objects.requireNonNull(value, "bot");
      return new ImmutableResourceList.InternalBotValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalBotValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalBotValue
          && equalTo((ImmutableResourceList.InternalBotValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalBotValue another) {
      return bot.equals(another.bot);
    }

    /**
     * Computes a hash code from attributes: {@code bot}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + bot.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalBotValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalBotValue{"
          + "bot=" + bot
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalBotValue fromJson(Bot jsonValue) {
      ImmutableResourceList.InternalBotValue.Builder builder = ImmutableResourceList.InternalBotValue.builder();
      builder.bot(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalBotValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalBotValue instance
     */
    public static ImmutableResourceList.InternalBotValue copyOf(ResourceList.InternalBotValue instance) {
      if (instance instanceof ImmutableResourceList.InternalBotValue) {
        return (ImmutableResourceList.InternalBotValue) instance;
      }
      return ImmutableResourceList.InternalBotValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalBotValue InternalBotValue}.
     * <pre>
     * ImmutableResourceList.InternalBotValue.builder()
     *    .bot(com.fhir.types.fhir.Bot) // required {@link ResourceList.InternalBotValue#bot() bot}
     *    .build();
     * </pre>
     * @return A new InternalBotValue builder
     */
    public static ImmutableResourceList.InternalBotValue.Builder builder() {
      return new ImmutableResourceList.InternalBotValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalBotValue InternalBotValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalBotValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_BOT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Bot bot;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalBotValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalBotValue instance) {
        Objects.requireNonNull(instance, "instance");
        bot(instance.bot());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalBotValue#bot() bot} attribute.
       * @param bot The value for bot 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("bot")
      public final Builder bot(Bot bot) {
        this.bot = Objects.requireNonNull(bot, "bot");
        initBits &= ~INIT_BIT_BOT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalBotValue InternalBotValue}.
       * @return An immutable instance of InternalBotValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalBotValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalBotValue(bot);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_BOT) != 0) attributes.add("bot");
        return "Cannot build InternalBotValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalOrganizationAffiliationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalOrganizationAffiliationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalOrganizationAffiliationValue", generator = "Immutables")
  @Immutable
  static final class InternalOrganizationAffiliationValue
      implements ResourceList.InternalOrganizationAffiliationValue {
    private final OrganizationAffiliation organizationAffiliation;

    private InternalOrganizationAffiliationValue(OrganizationAffiliation organizationAffiliation) {
      this.organizationAffiliation = organizationAffiliation;
    }

    /**
     * @return The value of the {@code organizationAffiliation} attribute
     */
    @JsonProperty("organizationAffiliation")
    @JsonValue
    @Override
    public OrganizationAffiliation organizationAffiliation() {
      return organizationAffiliation;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalOrganizationAffiliationValue#organizationAffiliation() organizationAffiliation} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for organizationAffiliation
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalOrganizationAffiliationValue withOrganizationAffiliation(OrganizationAffiliation value) {
      if (this.organizationAffiliation == value) return this;
      OrganizationAffiliation newValue = Objects.requireNonNull(value, "organizationAffiliation");
      return new ImmutableResourceList.InternalOrganizationAffiliationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalOrganizationAffiliationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalOrganizationAffiliationValue
          && equalTo((ImmutableResourceList.InternalOrganizationAffiliationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalOrganizationAffiliationValue another) {
      return organizationAffiliation.equals(another.organizationAffiliation);
    }

    /**
     * Computes a hash code from attributes: {@code organizationAffiliation}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + organizationAffiliation.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalOrganizationAffiliationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalOrganizationAffiliationValue{"
          + "organizationAffiliation=" + organizationAffiliation
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalOrganizationAffiliationValue fromJson(OrganizationAffiliation jsonValue) {
      ImmutableResourceList.InternalOrganizationAffiliationValue.Builder builder = ImmutableResourceList.InternalOrganizationAffiliationValue.builder();
      builder.organizationAffiliation(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalOrganizationAffiliationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalOrganizationAffiliationValue instance
     */
    public static ImmutableResourceList.InternalOrganizationAffiliationValue copyOf(ResourceList.InternalOrganizationAffiliationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalOrganizationAffiliationValue) {
        return (ImmutableResourceList.InternalOrganizationAffiliationValue) instance;
      }
      return ImmutableResourceList.InternalOrganizationAffiliationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalOrganizationAffiliationValue InternalOrganizationAffiliationValue}.
     * <pre>
     * ImmutableResourceList.InternalOrganizationAffiliationValue.builder()
     *    .organizationAffiliation(com.fhir.types.fhir.OrganizationAffiliation) // required {@link ResourceList.InternalOrganizationAffiliationValue#organizationAffiliation() organizationAffiliation}
     *    .build();
     * </pre>
     * @return A new InternalOrganizationAffiliationValue builder
     */
    public static ImmutableResourceList.InternalOrganizationAffiliationValue.Builder builder() {
      return new ImmutableResourceList.InternalOrganizationAffiliationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalOrganizationAffiliationValue InternalOrganizationAffiliationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalOrganizationAffiliationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ORGANIZATION_AFFILIATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable OrganizationAffiliation organizationAffiliation;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalOrganizationAffiliationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalOrganizationAffiliationValue instance) {
        Objects.requireNonNull(instance, "instance");
        organizationAffiliation(instance.organizationAffiliation());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalOrganizationAffiliationValue#organizationAffiliation() organizationAffiliation} attribute.
       * @param organizationAffiliation The value for organizationAffiliation 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("organizationAffiliation")
      public final Builder organizationAffiliation(OrganizationAffiliation organizationAffiliation) {
        this.organizationAffiliation = Objects.requireNonNull(organizationAffiliation, "organizationAffiliation");
        initBits &= ~INIT_BIT_ORGANIZATION_AFFILIATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalOrganizationAffiliationValue InternalOrganizationAffiliationValue}.
       * @return An immutable instance of InternalOrganizationAffiliationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalOrganizationAffiliationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalOrganizationAffiliationValue(organizationAffiliation);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ORGANIZATION_AFFILIATION) != 0) attributes.add("organizationAffiliation");
        return "Cannot build InternalOrganizationAffiliationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalNamingSystemValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalNamingSystemValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalNamingSystemValue", generator = "Immutables")
  @Immutable
  static final class InternalNamingSystemValue
      implements ResourceList.InternalNamingSystemValue {
    private final NamingSystem namingSystem;

    private InternalNamingSystemValue(NamingSystem namingSystem) {
      this.namingSystem = namingSystem;
    }

    /**
     * @return The value of the {@code namingSystem} attribute
     */
    @JsonProperty("namingSystem")
    @JsonValue
    @Override
    public NamingSystem namingSystem() {
      return namingSystem;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalNamingSystemValue#namingSystem() namingSystem} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for namingSystem
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalNamingSystemValue withNamingSystem(NamingSystem value) {
      if (this.namingSystem == value) return this;
      NamingSystem newValue = Objects.requireNonNull(value, "namingSystem");
      return new ImmutableResourceList.InternalNamingSystemValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalNamingSystemValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalNamingSystemValue
          && equalTo((ImmutableResourceList.InternalNamingSystemValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalNamingSystemValue another) {
      return namingSystem.equals(another.namingSystem);
    }

    /**
     * Computes a hash code from attributes: {@code namingSystem}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + namingSystem.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalNamingSystemValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalNamingSystemValue{"
          + "namingSystem=" + namingSystem
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalNamingSystemValue fromJson(NamingSystem jsonValue) {
      ImmutableResourceList.InternalNamingSystemValue.Builder builder = ImmutableResourceList.InternalNamingSystemValue.builder();
      builder.namingSystem(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalNamingSystemValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalNamingSystemValue instance
     */
    public static ImmutableResourceList.InternalNamingSystemValue copyOf(ResourceList.InternalNamingSystemValue instance) {
      if (instance instanceof ImmutableResourceList.InternalNamingSystemValue) {
        return (ImmutableResourceList.InternalNamingSystemValue) instance;
      }
      return ImmutableResourceList.InternalNamingSystemValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalNamingSystemValue InternalNamingSystemValue}.
     * <pre>
     * ImmutableResourceList.InternalNamingSystemValue.builder()
     *    .namingSystem(com.fhir.types.fhir.NamingSystem) // required {@link ResourceList.InternalNamingSystemValue#namingSystem() namingSystem}
     *    .build();
     * </pre>
     * @return A new InternalNamingSystemValue builder
     */
    public static ImmutableResourceList.InternalNamingSystemValue.Builder builder() {
      return new ImmutableResourceList.InternalNamingSystemValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalNamingSystemValue InternalNamingSystemValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalNamingSystemValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_NAMING_SYSTEM = 0x1L;
      private long initBits = 0x1L;

      private @Nullable NamingSystem namingSystem;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalNamingSystemValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalNamingSystemValue instance) {
        Objects.requireNonNull(instance, "instance");
        namingSystem(instance.namingSystem());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalNamingSystemValue#namingSystem() namingSystem} attribute.
       * @param namingSystem The value for namingSystem 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("namingSystem")
      public final Builder namingSystem(NamingSystem namingSystem) {
        this.namingSystem = Objects.requireNonNull(namingSystem, "namingSystem");
        initBits &= ~INIT_BIT_NAMING_SYSTEM;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalNamingSystemValue InternalNamingSystemValue}.
       * @return An immutable instance of InternalNamingSystemValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalNamingSystemValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalNamingSystemValue(namingSystem);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_NAMING_SYSTEM) != 0) attributes.add("namingSystem");
        return "Cannot build InternalNamingSystemValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalOperationOutcomeValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalOperationOutcomeValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalOperationOutcomeValue", generator = "Immutables")
  @Immutable
  static final class InternalOperationOutcomeValue
      implements ResourceList.InternalOperationOutcomeValue {
    private final OperationOutcome operationOutcome;

    private InternalOperationOutcomeValue(OperationOutcome operationOutcome) {
      this.operationOutcome = operationOutcome;
    }

    /**
     * @return The value of the {@code operationOutcome} attribute
     */
    @JsonProperty("operationOutcome")
    @JsonValue
    @Override
    public OperationOutcome operationOutcome() {
      return operationOutcome;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalOperationOutcomeValue#operationOutcome() operationOutcome} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for operationOutcome
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalOperationOutcomeValue withOperationOutcome(OperationOutcome value) {
      if (this.operationOutcome == value) return this;
      OperationOutcome newValue = Objects.requireNonNull(value, "operationOutcome");
      return new ImmutableResourceList.InternalOperationOutcomeValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalOperationOutcomeValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalOperationOutcomeValue
          && equalTo((ImmutableResourceList.InternalOperationOutcomeValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalOperationOutcomeValue another) {
      return operationOutcome.equals(another.operationOutcome);
    }

    /**
     * Computes a hash code from attributes: {@code operationOutcome}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + operationOutcome.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalOperationOutcomeValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalOperationOutcomeValue{"
          + "operationOutcome=" + operationOutcome
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalOperationOutcomeValue fromJson(OperationOutcome jsonValue) {
      ImmutableResourceList.InternalOperationOutcomeValue.Builder builder = ImmutableResourceList.InternalOperationOutcomeValue.builder();
      builder.operationOutcome(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalOperationOutcomeValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalOperationOutcomeValue instance
     */
    public static ImmutableResourceList.InternalOperationOutcomeValue copyOf(ResourceList.InternalOperationOutcomeValue instance) {
      if (instance instanceof ImmutableResourceList.InternalOperationOutcomeValue) {
        return (ImmutableResourceList.InternalOperationOutcomeValue) instance;
      }
      return ImmutableResourceList.InternalOperationOutcomeValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalOperationOutcomeValue InternalOperationOutcomeValue}.
     * <pre>
     * ImmutableResourceList.InternalOperationOutcomeValue.builder()
     *    .operationOutcome(com.fhir.types.fhir.OperationOutcome) // required {@link ResourceList.InternalOperationOutcomeValue#operationOutcome() operationOutcome}
     *    .build();
     * </pre>
     * @return A new InternalOperationOutcomeValue builder
     */
    public static ImmutableResourceList.InternalOperationOutcomeValue.Builder builder() {
      return new ImmutableResourceList.InternalOperationOutcomeValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalOperationOutcomeValue InternalOperationOutcomeValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalOperationOutcomeValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_OPERATION_OUTCOME = 0x1L;
      private long initBits = 0x1L;

      private @Nullable OperationOutcome operationOutcome;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalOperationOutcomeValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalOperationOutcomeValue instance) {
        Objects.requireNonNull(instance, "instance");
        operationOutcome(instance.operationOutcome());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalOperationOutcomeValue#operationOutcome() operationOutcome} attribute.
       * @param operationOutcome The value for operationOutcome 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("operationOutcome")
      public final Builder operationOutcome(OperationOutcome operationOutcome) {
        this.operationOutcome = Objects.requireNonNull(operationOutcome, "operationOutcome");
        initBits &= ~INIT_BIT_OPERATION_OUTCOME;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalOperationOutcomeValue InternalOperationOutcomeValue}.
       * @return An immutable instance of InternalOperationOutcomeValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalOperationOutcomeValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalOperationOutcomeValue(operationOutcome);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_OPERATION_OUTCOME) != 0) attributes.add("operationOutcome");
        return "Cannot build InternalOperationOutcomeValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalPatientValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalPatientValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalPatientValue", generator = "Immutables")
  @Immutable
  static final class InternalPatientValue implements ResourceList.InternalPatientValue {
    private final Patient patient;

    private InternalPatientValue(Patient patient) {
      this.patient = patient;
    }

    /**
     * @return The value of the {@code patient} attribute
     */
    @JsonProperty("patient")
    @JsonValue
    @Override
    public Patient patient() {
      return patient;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalPatientValue#patient() patient} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for patient
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalPatientValue withPatient(Patient value) {
      if (this.patient == value) return this;
      Patient newValue = Objects.requireNonNull(value, "patient");
      return new ImmutableResourceList.InternalPatientValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalPatientValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalPatientValue
          && equalTo((ImmutableResourceList.InternalPatientValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalPatientValue another) {
      return patient.equals(another.patient);
    }

    /**
     * Computes a hash code from attributes: {@code patient}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + patient.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalPatientValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalPatientValue{"
          + "patient=" + patient
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalPatientValue fromJson(Patient jsonValue) {
      ImmutableResourceList.InternalPatientValue.Builder builder = ImmutableResourceList.InternalPatientValue.builder();
      builder.patient(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalPatientValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalPatientValue instance
     */
    public static ImmutableResourceList.InternalPatientValue copyOf(ResourceList.InternalPatientValue instance) {
      if (instance instanceof ImmutableResourceList.InternalPatientValue) {
        return (ImmutableResourceList.InternalPatientValue) instance;
      }
      return ImmutableResourceList.InternalPatientValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalPatientValue InternalPatientValue}.
     * <pre>
     * ImmutableResourceList.InternalPatientValue.builder()
     *    .patient(com.fhir.types.fhir.Patient) // required {@link ResourceList.InternalPatientValue#patient() patient}
     *    .build();
     * </pre>
     * @return A new InternalPatientValue builder
     */
    public static ImmutableResourceList.InternalPatientValue.Builder builder() {
      return new ImmutableResourceList.InternalPatientValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalPatientValue InternalPatientValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalPatientValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PATIENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Patient patient;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalPatientValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalPatientValue instance) {
        Objects.requireNonNull(instance, "instance");
        patient(instance.patient());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalPatientValue#patient() patient} attribute.
       * @param patient The value for patient 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("patient")
      public final Builder patient(Patient patient) {
        this.patient = Objects.requireNonNull(patient, "patient");
        initBits &= ~INIT_BIT_PATIENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalPatientValue InternalPatientValue}.
       * @return An immutable instance of InternalPatientValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalPatientValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalPatientValue(patient);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PATIENT) != 0) attributes.add("patient");
        return "Cannot build InternalPatientValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalConsentValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalConsentValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalConsentValue", generator = "Immutables")
  @Immutable
  static final class InternalConsentValue implements ResourceList.InternalConsentValue {
    private final Consent consent;

    private InternalConsentValue(Consent consent) {
      this.consent = consent;
    }

    /**
     * @return The value of the {@code consent} attribute
     */
    @JsonProperty("consent")
    @JsonValue
    @Override
    public Consent consent() {
      return consent;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalConsentValue#consent() consent} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for consent
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalConsentValue withConsent(Consent value) {
      if (this.consent == value) return this;
      Consent newValue = Objects.requireNonNull(value, "consent");
      return new ImmutableResourceList.InternalConsentValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalConsentValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalConsentValue
          && equalTo((ImmutableResourceList.InternalConsentValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalConsentValue another) {
      return consent.equals(another.consent);
    }

    /**
     * Computes a hash code from attributes: {@code consent}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + consent.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalConsentValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalConsentValue{"
          + "consent=" + consent
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalConsentValue fromJson(Consent jsonValue) {
      ImmutableResourceList.InternalConsentValue.Builder builder = ImmutableResourceList.InternalConsentValue.builder();
      builder.consent(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalConsentValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalConsentValue instance
     */
    public static ImmutableResourceList.InternalConsentValue copyOf(ResourceList.InternalConsentValue instance) {
      if (instance instanceof ImmutableResourceList.InternalConsentValue) {
        return (ImmutableResourceList.InternalConsentValue) instance;
      }
      return ImmutableResourceList.InternalConsentValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalConsentValue InternalConsentValue}.
     * <pre>
     * ImmutableResourceList.InternalConsentValue.builder()
     *    .consent(com.fhir.types.fhir.Consent) // required {@link ResourceList.InternalConsentValue#consent() consent}
     *    .build();
     * </pre>
     * @return A new InternalConsentValue builder
     */
    public static ImmutableResourceList.InternalConsentValue.Builder builder() {
      return new ImmutableResourceList.InternalConsentValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalConsentValue InternalConsentValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalConsentValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CONSENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Consent consent;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalConsentValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalConsentValue instance) {
        Objects.requireNonNull(instance, "instance");
        consent(instance.consent());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalConsentValue#consent() consent} attribute.
       * @param consent The value for consent 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("consent")
      public final Builder consent(Consent consent) {
        this.consent = Objects.requireNonNull(consent, "consent");
        initBits &= ~INIT_BIT_CONSENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalConsentValue InternalConsentValue}.
       * @return An immutable instance of InternalConsentValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalConsentValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalConsentValue(consent);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CONSENT) != 0) attributes.add("consent");
        return "Cannot build InternalConsentValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCompartmentDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCompartmentDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCompartmentDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalCompartmentDefinitionValue
      implements ResourceList.InternalCompartmentDefinitionValue {
    private final CompartmentDefinition compartmentDefinition;

    private InternalCompartmentDefinitionValue(CompartmentDefinition compartmentDefinition) {
      this.compartmentDefinition = compartmentDefinition;
    }

    /**
     * @return The value of the {@code compartmentDefinition} attribute
     */
    @JsonProperty("compartmentDefinition")
    @JsonValue
    @Override
    public CompartmentDefinition compartmentDefinition() {
      return compartmentDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCompartmentDefinitionValue#compartmentDefinition() compartmentDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for compartmentDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCompartmentDefinitionValue withCompartmentDefinition(CompartmentDefinition value) {
      if (this.compartmentDefinition == value) return this;
      CompartmentDefinition newValue = Objects.requireNonNull(value, "compartmentDefinition");
      return new ImmutableResourceList.InternalCompartmentDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCompartmentDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCompartmentDefinitionValue
          && equalTo((ImmutableResourceList.InternalCompartmentDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCompartmentDefinitionValue another) {
      return compartmentDefinition.equals(another.compartmentDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code compartmentDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + compartmentDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCompartmentDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCompartmentDefinitionValue{"
          + "compartmentDefinition=" + compartmentDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCompartmentDefinitionValue fromJson(CompartmentDefinition jsonValue) {
      ImmutableResourceList.InternalCompartmentDefinitionValue.Builder builder = ImmutableResourceList.InternalCompartmentDefinitionValue.builder();
      builder.compartmentDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCompartmentDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCompartmentDefinitionValue instance
     */
    public static ImmutableResourceList.InternalCompartmentDefinitionValue copyOf(ResourceList.InternalCompartmentDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCompartmentDefinitionValue) {
        return (ImmutableResourceList.InternalCompartmentDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalCompartmentDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCompartmentDefinitionValue InternalCompartmentDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalCompartmentDefinitionValue.builder()
     *    .compartmentDefinition(com.fhir.types.fhir.CompartmentDefinition) // required {@link ResourceList.InternalCompartmentDefinitionValue#compartmentDefinition() compartmentDefinition}
     *    .build();
     * </pre>
     * @return A new InternalCompartmentDefinitionValue builder
     */
    public static ImmutableResourceList.InternalCompartmentDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalCompartmentDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCompartmentDefinitionValue InternalCompartmentDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCompartmentDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_COMPARTMENT_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable CompartmentDefinition compartmentDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCompartmentDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCompartmentDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        compartmentDefinition(instance.compartmentDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCompartmentDefinitionValue#compartmentDefinition() compartmentDefinition} attribute.
       * @param compartmentDefinition The value for compartmentDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("compartmentDefinition")
      public final Builder compartmentDefinition(CompartmentDefinition compartmentDefinition) {
        this.compartmentDefinition = Objects.requireNonNull(compartmentDefinition, "compartmentDefinition");
        initBits &= ~INIT_BIT_COMPARTMENT_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCompartmentDefinitionValue InternalCompartmentDefinitionValue}.
       * @return An immutable instance of InternalCompartmentDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCompartmentDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCompartmentDefinitionValue(compartmentDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_COMPARTMENT_DEFINITION) != 0) attributes.add("compartmentDefinition");
        return "Cannot build InternalCompartmentDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSubstanceNucleicAcidValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSubstanceNucleicAcidValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSubstanceNucleicAcidValue", generator = "Immutables")
  @Immutable
  static final class InternalSubstanceNucleicAcidValue
      implements ResourceList.InternalSubstanceNucleicAcidValue {
    private final SubstanceNucleicAcid substanceNucleicAcid;

    private InternalSubstanceNucleicAcidValue(SubstanceNucleicAcid substanceNucleicAcid) {
      this.substanceNucleicAcid = substanceNucleicAcid;
    }

    /**
     * @return The value of the {@code substanceNucleicAcid} attribute
     */
    @JsonProperty("substanceNucleicAcid")
    @JsonValue
    @Override
    public SubstanceNucleicAcid substanceNucleicAcid() {
      return substanceNucleicAcid;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSubstanceNucleicAcidValue#substanceNucleicAcid() substanceNucleicAcid} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for substanceNucleicAcid
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSubstanceNucleicAcidValue withSubstanceNucleicAcid(SubstanceNucleicAcid value) {
      if (this.substanceNucleicAcid == value) return this;
      SubstanceNucleicAcid newValue = Objects.requireNonNull(value, "substanceNucleicAcid");
      return new ImmutableResourceList.InternalSubstanceNucleicAcidValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSubstanceNucleicAcidValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSubstanceNucleicAcidValue
          && equalTo((ImmutableResourceList.InternalSubstanceNucleicAcidValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSubstanceNucleicAcidValue another) {
      return substanceNucleicAcid.equals(another.substanceNucleicAcid);
    }

    /**
     * Computes a hash code from attributes: {@code substanceNucleicAcid}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + substanceNucleicAcid.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSubstanceNucleicAcidValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSubstanceNucleicAcidValue{"
          + "substanceNucleicAcid=" + substanceNucleicAcid
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSubstanceNucleicAcidValue fromJson(SubstanceNucleicAcid jsonValue) {
      ImmutableResourceList.InternalSubstanceNucleicAcidValue.Builder builder = ImmutableResourceList.InternalSubstanceNucleicAcidValue.builder();
      builder.substanceNucleicAcid(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSubstanceNucleicAcidValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSubstanceNucleicAcidValue instance
     */
    public static ImmutableResourceList.InternalSubstanceNucleicAcidValue copyOf(ResourceList.InternalSubstanceNucleicAcidValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSubstanceNucleicAcidValue) {
        return (ImmutableResourceList.InternalSubstanceNucleicAcidValue) instance;
      }
      return ImmutableResourceList.InternalSubstanceNucleicAcidValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSubstanceNucleicAcidValue InternalSubstanceNucleicAcidValue}.
     * <pre>
     * ImmutableResourceList.InternalSubstanceNucleicAcidValue.builder()
     *    .substanceNucleicAcid(com.fhir.types.fhir.SubstanceNucleicAcid) // required {@link ResourceList.InternalSubstanceNucleicAcidValue#substanceNucleicAcid() substanceNucleicAcid}
     *    .build();
     * </pre>
     * @return A new InternalSubstanceNucleicAcidValue builder
     */
    public static ImmutableResourceList.InternalSubstanceNucleicAcidValue.Builder builder() {
      return new ImmutableResourceList.InternalSubstanceNucleicAcidValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSubstanceNucleicAcidValue InternalSubstanceNucleicAcidValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSubstanceNucleicAcidValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUBSTANCE_NUCLEIC_ACID = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SubstanceNucleicAcid substanceNucleicAcid;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSubstanceNucleicAcidValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSubstanceNucleicAcidValue instance) {
        Objects.requireNonNull(instance, "instance");
        substanceNucleicAcid(instance.substanceNucleicAcid());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSubstanceNucleicAcidValue#substanceNucleicAcid() substanceNucleicAcid} attribute.
       * @param substanceNucleicAcid The value for substanceNucleicAcid 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("substanceNucleicAcid")
      public final Builder substanceNucleicAcid(SubstanceNucleicAcid substanceNucleicAcid) {
        this.substanceNucleicAcid = Objects.requireNonNull(substanceNucleicAcid, "substanceNucleicAcid");
        initBits &= ~INIT_BIT_SUBSTANCE_NUCLEIC_ACID;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSubstanceNucleicAcidValue InternalSubstanceNucleicAcidValue}.
       * @return An immutable instance of InternalSubstanceNucleicAcidValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSubstanceNucleicAcidValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSubstanceNucleicAcidValue(substanceNucleicAcid);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUBSTANCE_NUCLEIC_ACID) != 0) attributes.add("substanceNucleicAcid");
        return "Cannot build InternalSubstanceNucleicAcidValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCatalogEntryValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCatalogEntryValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCatalogEntryValue", generator = "Immutables")
  @Immutable
  static final class InternalCatalogEntryValue
      implements ResourceList.InternalCatalogEntryValue {
    private final CatalogEntry catalogEntry;

    private InternalCatalogEntryValue(CatalogEntry catalogEntry) {
      this.catalogEntry = catalogEntry;
    }

    /**
     * @return The value of the {@code catalogEntry} attribute
     */
    @JsonProperty("catalogEntry")
    @JsonValue
    @Override
    public CatalogEntry catalogEntry() {
      return catalogEntry;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCatalogEntryValue#catalogEntry() catalogEntry} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for catalogEntry
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCatalogEntryValue withCatalogEntry(CatalogEntry value) {
      if (this.catalogEntry == value) return this;
      CatalogEntry newValue = Objects.requireNonNull(value, "catalogEntry");
      return new ImmutableResourceList.InternalCatalogEntryValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCatalogEntryValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCatalogEntryValue
          && equalTo((ImmutableResourceList.InternalCatalogEntryValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCatalogEntryValue another) {
      return catalogEntry.equals(another.catalogEntry);
    }

    /**
     * Computes a hash code from attributes: {@code catalogEntry}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + catalogEntry.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCatalogEntryValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCatalogEntryValue{"
          + "catalogEntry=" + catalogEntry
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCatalogEntryValue fromJson(CatalogEntry jsonValue) {
      ImmutableResourceList.InternalCatalogEntryValue.Builder builder = ImmutableResourceList.InternalCatalogEntryValue.builder();
      builder.catalogEntry(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCatalogEntryValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCatalogEntryValue instance
     */
    public static ImmutableResourceList.InternalCatalogEntryValue copyOf(ResourceList.InternalCatalogEntryValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCatalogEntryValue) {
        return (ImmutableResourceList.InternalCatalogEntryValue) instance;
      }
      return ImmutableResourceList.InternalCatalogEntryValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCatalogEntryValue InternalCatalogEntryValue}.
     * <pre>
     * ImmutableResourceList.InternalCatalogEntryValue.builder()
     *    .catalogEntry(com.fhir.types.fhir.CatalogEntry) // required {@link ResourceList.InternalCatalogEntryValue#catalogEntry() catalogEntry}
     *    .build();
     * </pre>
     * @return A new InternalCatalogEntryValue builder
     */
    public static ImmutableResourceList.InternalCatalogEntryValue.Builder builder() {
      return new ImmutableResourceList.InternalCatalogEntryValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCatalogEntryValue InternalCatalogEntryValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCatalogEntryValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CATALOG_ENTRY = 0x1L;
      private long initBits = 0x1L;

      private @Nullable CatalogEntry catalogEntry;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCatalogEntryValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCatalogEntryValue instance) {
        Objects.requireNonNull(instance, "instance");
        catalogEntry(instance.catalogEntry());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCatalogEntryValue#catalogEntry() catalogEntry} attribute.
       * @param catalogEntry The value for catalogEntry 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("catalogEntry")
      public final Builder catalogEntry(CatalogEntry catalogEntry) {
        this.catalogEntry = Objects.requireNonNull(catalogEntry, "catalogEntry");
        initBits &= ~INIT_BIT_CATALOG_ENTRY;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCatalogEntryValue InternalCatalogEntryValue}.
       * @return An immutable instance of InternalCatalogEntryValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCatalogEntryValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCatalogEntryValue(catalogEntry);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CATALOG_ENTRY) != 0) attributes.add("catalogEntry");
        return "Cannot build InternalCatalogEntryValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSubstanceProteinValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSubstanceProteinValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSubstanceProteinValue", generator = "Immutables")
  @Immutable
  static final class InternalSubstanceProteinValue
      implements ResourceList.InternalSubstanceProteinValue {
    private final SubstanceProtein substanceProtein;

    private InternalSubstanceProteinValue(SubstanceProtein substanceProtein) {
      this.substanceProtein = substanceProtein;
    }

    /**
     * @return The value of the {@code substanceProtein} attribute
     */
    @JsonProperty("substanceProtein")
    @JsonValue
    @Override
    public SubstanceProtein substanceProtein() {
      return substanceProtein;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSubstanceProteinValue#substanceProtein() substanceProtein} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for substanceProtein
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSubstanceProteinValue withSubstanceProtein(SubstanceProtein value) {
      if (this.substanceProtein == value) return this;
      SubstanceProtein newValue = Objects.requireNonNull(value, "substanceProtein");
      return new ImmutableResourceList.InternalSubstanceProteinValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSubstanceProteinValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSubstanceProteinValue
          && equalTo((ImmutableResourceList.InternalSubstanceProteinValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSubstanceProteinValue another) {
      return substanceProtein.equals(another.substanceProtein);
    }

    /**
     * Computes a hash code from attributes: {@code substanceProtein}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + substanceProtein.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSubstanceProteinValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSubstanceProteinValue{"
          + "substanceProtein=" + substanceProtein
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSubstanceProteinValue fromJson(SubstanceProtein jsonValue) {
      ImmutableResourceList.InternalSubstanceProteinValue.Builder builder = ImmutableResourceList.InternalSubstanceProteinValue.builder();
      builder.substanceProtein(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSubstanceProteinValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSubstanceProteinValue instance
     */
    public static ImmutableResourceList.InternalSubstanceProteinValue copyOf(ResourceList.InternalSubstanceProteinValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSubstanceProteinValue) {
        return (ImmutableResourceList.InternalSubstanceProteinValue) instance;
      }
      return ImmutableResourceList.InternalSubstanceProteinValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSubstanceProteinValue InternalSubstanceProteinValue}.
     * <pre>
     * ImmutableResourceList.InternalSubstanceProteinValue.builder()
     *    .substanceProtein(com.fhir.types.fhir.SubstanceProtein) // required {@link ResourceList.InternalSubstanceProteinValue#substanceProtein() substanceProtein}
     *    .build();
     * </pre>
     * @return A new InternalSubstanceProteinValue builder
     */
    public static ImmutableResourceList.InternalSubstanceProteinValue.Builder builder() {
      return new ImmutableResourceList.InternalSubstanceProteinValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSubstanceProteinValue InternalSubstanceProteinValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSubstanceProteinValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUBSTANCE_PROTEIN = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SubstanceProtein substanceProtein;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSubstanceProteinValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSubstanceProteinValue instance) {
        Objects.requireNonNull(instance, "instance");
        substanceProtein(instance.substanceProtein());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSubstanceProteinValue#substanceProtein() substanceProtein} attribute.
       * @param substanceProtein The value for substanceProtein 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("substanceProtein")
      public final Builder substanceProtein(SubstanceProtein substanceProtein) {
        this.substanceProtein = Objects.requireNonNull(substanceProtein, "substanceProtein");
        initBits &= ~INIT_BIT_SUBSTANCE_PROTEIN;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSubstanceProteinValue InternalSubstanceProteinValue}.
       * @return An immutable instance of InternalSubstanceProteinValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSubstanceProteinValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSubstanceProteinValue(substanceProtein);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUBSTANCE_PROTEIN) != 0) attributes.add("substanceProtein");
        return "Cannot build InternalSubstanceProteinValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalImmunizationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalImmunizationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalImmunizationValue", generator = "Immutables")
  @Immutable
  static final class InternalImmunizationValue
      implements ResourceList.InternalImmunizationValue {
    private final Immunization immunization;

    private InternalImmunizationValue(Immunization immunization) {
      this.immunization = immunization;
    }

    /**
     * @return The value of the {@code immunization} attribute
     */
    @JsonProperty("immunization")
    @JsonValue
    @Override
    public Immunization immunization() {
      return immunization;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalImmunizationValue#immunization() immunization} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for immunization
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalImmunizationValue withImmunization(Immunization value) {
      if (this.immunization == value) return this;
      Immunization newValue = Objects.requireNonNull(value, "immunization");
      return new ImmutableResourceList.InternalImmunizationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalImmunizationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalImmunizationValue
          && equalTo((ImmutableResourceList.InternalImmunizationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalImmunizationValue another) {
      return immunization.equals(another.immunization);
    }

    /**
     * Computes a hash code from attributes: {@code immunization}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + immunization.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalImmunizationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalImmunizationValue{"
          + "immunization=" + immunization
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalImmunizationValue fromJson(Immunization jsonValue) {
      ImmutableResourceList.InternalImmunizationValue.Builder builder = ImmutableResourceList.InternalImmunizationValue.builder();
      builder.immunization(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalImmunizationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalImmunizationValue instance
     */
    public static ImmutableResourceList.InternalImmunizationValue copyOf(ResourceList.InternalImmunizationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalImmunizationValue) {
        return (ImmutableResourceList.InternalImmunizationValue) instance;
      }
      return ImmutableResourceList.InternalImmunizationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalImmunizationValue InternalImmunizationValue}.
     * <pre>
     * ImmutableResourceList.InternalImmunizationValue.builder()
     *    .immunization(com.fhir.types.fhir.Immunization) // required {@link ResourceList.InternalImmunizationValue#immunization() immunization}
     *    .build();
     * </pre>
     * @return A new InternalImmunizationValue builder
     */
    public static ImmutableResourceList.InternalImmunizationValue.Builder builder() {
      return new ImmutableResourceList.InternalImmunizationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalImmunizationValue InternalImmunizationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalImmunizationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_IMMUNIZATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Immunization immunization;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalImmunizationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalImmunizationValue instance) {
        Objects.requireNonNull(instance, "instance");
        immunization(instance.immunization());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalImmunizationValue#immunization() immunization} attribute.
       * @param immunization The value for immunization 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("immunization")
      public final Builder immunization(Immunization immunization) {
        this.immunization = Objects.requireNonNull(immunization, "immunization");
        initBits &= ~INIT_BIT_IMMUNIZATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalImmunizationValue InternalImmunizationValue}.
       * @return An immutable instance of InternalImmunizationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalImmunizationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalImmunizationValue(immunization);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_IMMUNIZATION) != 0) attributes.add("immunization");
        return "Cannot build InternalImmunizationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalRefreshTokenValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalRefreshTokenValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalRefreshTokenValue", generator = "Immutables")
  @Immutable
  static final class InternalRefreshTokenValue
      implements ResourceList.InternalRefreshTokenValue {
    private final RefreshToken refreshToken;

    private InternalRefreshTokenValue(RefreshToken refreshToken) {
      this.refreshToken = refreshToken;
    }

    /**
     * @return The value of the {@code refreshToken} attribute
     */
    @JsonProperty("refreshToken")
    @Override
    public RefreshToken refreshToken() {
      return refreshToken;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalRefreshTokenValue#refreshToken() refreshToken} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for refreshToken
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalRefreshTokenValue withRefreshToken(RefreshToken value) {
      if (this.refreshToken == value) return this;
      RefreshToken newValue = Objects.requireNonNull(value, "refreshToken");
      return new ImmutableResourceList.InternalRefreshTokenValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalRefreshTokenValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalRefreshTokenValue
          && equalTo((ImmutableResourceList.InternalRefreshTokenValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalRefreshTokenValue another) {
      return refreshToken.equals(another.refreshToken);
    }

    /**
     * Computes a hash code from attributes: {@code refreshToken}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + refreshToken.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalRefreshTokenValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalRefreshTokenValue{"
          + "refreshToken=" + refreshToken
          + "}";
    }

    /**
     * Utility type used to correctly read immutable object from JSON representation.
     * @deprecated Do not use this type directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Generated(from = "ResourceList.InternalRefreshTokenValue", generator = "Immutables")
    @Deprecated
    @JsonDeserialize
    @JsonTypeInfo(use=JsonTypeInfo.Id.NONE)
    @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.NONE)
    static final class Json implements ResourceList.InternalRefreshTokenValue {
      @Nullable RefreshToken refreshToken;
      @JsonProperty("refreshToken")
      public void setRefreshToken(RefreshToken refreshToken) {
        this.refreshToken = refreshToken;
      }
      @Override
      public RefreshToken refreshToken() { throw new UnsupportedOperationException(); }
    }

    /**
     * @param json A JSON-bindable data structure
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalRefreshTokenValue fromJson(Json json) {
      ImmutableResourceList.InternalRefreshTokenValue.Builder builder = ImmutableResourceList.InternalRefreshTokenValue.builder();
      if (json.refreshToken != null) {
        builder.refreshToken(json.refreshToken);
      }
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalRefreshTokenValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalRefreshTokenValue instance
     */
    public static ImmutableResourceList.InternalRefreshTokenValue copyOf(ResourceList.InternalRefreshTokenValue instance) {
      if (instance instanceof ImmutableResourceList.InternalRefreshTokenValue) {
        return (ImmutableResourceList.InternalRefreshTokenValue) instance;
      }
      return ImmutableResourceList.InternalRefreshTokenValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalRefreshTokenValue InternalRefreshTokenValue}.
     * <pre>
     * ImmutableResourceList.InternalRefreshTokenValue.builder()
     *    .refreshToken(com.fhir.types.fhir.RefreshToken) // required {@link ResourceList.InternalRefreshTokenValue#refreshToken() refreshToken}
     *    .build();
     * </pre>
     * @return A new InternalRefreshTokenValue builder
     */
    public static ImmutableResourceList.InternalRefreshTokenValue.Builder builder() {
      return new ImmutableResourceList.InternalRefreshTokenValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalRefreshTokenValue InternalRefreshTokenValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalRefreshTokenValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_REFRESH_TOKEN = 0x1L;
      private long initBits = 0x1L;

      private @Nullable RefreshToken refreshToken;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalRefreshTokenValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalRefreshTokenValue instance) {
        Objects.requireNonNull(instance, "instance");
        refreshToken(instance.refreshToken());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalRefreshTokenValue#refreshToken() refreshToken} attribute.
       * @param refreshToken The value for refreshToken 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("refreshToken")
      public final Builder refreshToken(RefreshToken refreshToken) {
        this.refreshToken = Objects.requireNonNull(refreshToken, "refreshToken");
        initBits &= ~INIT_BIT_REFRESH_TOKEN;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalRefreshTokenValue InternalRefreshTokenValue}.
       * @return An immutable instance of InternalRefreshTokenValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalRefreshTokenValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalRefreshTokenValue(refreshToken);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_REFRESH_TOKEN) != 0) attributes.add("refreshToken");
        return "Cannot build InternalRefreshTokenValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalBiologicallyDerivedProductValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalBiologicallyDerivedProductValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalBiologicallyDerivedProductValue", generator = "Immutables")
  @Immutable
  static final class InternalBiologicallyDerivedProductValue
      implements ResourceList.InternalBiologicallyDerivedProductValue {
    private final BiologicallyDerivedProduct biologicallyDerivedProduct;

    private InternalBiologicallyDerivedProductValue(BiologicallyDerivedProduct biologicallyDerivedProduct) {
      this.biologicallyDerivedProduct = biologicallyDerivedProduct;
    }

    /**
     * @return The value of the {@code biologicallyDerivedProduct} attribute
     */
    @JsonProperty("biologicallyDerivedProduct")
    @JsonValue
    @Override
    public BiologicallyDerivedProduct biologicallyDerivedProduct() {
      return biologicallyDerivedProduct;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalBiologicallyDerivedProductValue#biologicallyDerivedProduct() biologicallyDerivedProduct} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for biologicallyDerivedProduct
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalBiologicallyDerivedProductValue withBiologicallyDerivedProduct(BiologicallyDerivedProduct value) {
      if (this.biologicallyDerivedProduct == value) return this;
      BiologicallyDerivedProduct newValue = Objects.requireNonNull(value, "biologicallyDerivedProduct");
      return new ImmutableResourceList.InternalBiologicallyDerivedProductValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalBiologicallyDerivedProductValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalBiologicallyDerivedProductValue
          && equalTo((ImmutableResourceList.InternalBiologicallyDerivedProductValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalBiologicallyDerivedProductValue another) {
      return biologicallyDerivedProduct.equals(another.biologicallyDerivedProduct);
    }

    /**
     * Computes a hash code from attributes: {@code biologicallyDerivedProduct}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + biologicallyDerivedProduct.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalBiologicallyDerivedProductValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalBiologicallyDerivedProductValue{"
          + "biologicallyDerivedProduct=" + biologicallyDerivedProduct
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalBiologicallyDerivedProductValue fromJson(BiologicallyDerivedProduct jsonValue) {
      ImmutableResourceList.InternalBiologicallyDerivedProductValue.Builder builder = ImmutableResourceList.InternalBiologicallyDerivedProductValue.builder();
      builder.biologicallyDerivedProduct(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalBiologicallyDerivedProductValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalBiologicallyDerivedProductValue instance
     */
    public static ImmutableResourceList.InternalBiologicallyDerivedProductValue copyOf(ResourceList.InternalBiologicallyDerivedProductValue instance) {
      if (instance instanceof ImmutableResourceList.InternalBiologicallyDerivedProductValue) {
        return (ImmutableResourceList.InternalBiologicallyDerivedProductValue) instance;
      }
      return ImmutableResourceList.InternalBiologicallyDerivedProductValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalBiologicallyDerivedProductValue InternalBiologicallyDerivedProductValue}.
     * <pre>
     * ImmutableResourceList.InternalBiologicallyDerivedProductValue.builder()
     *    .biologicallyDerivedProduct(com.fhir.types.fhir.BiologicallyDerivedProduct) // required {@link ResourceList.InternalBiologicallyDerivedProductValue#biologicallyDerivedProduct() biologicallyDerivedProduct}
     *    .build();
     * </pre>
     * @return A new InternalBiologicallyDerivedProductValue builder
     */
    public static ImmutableResourceList.InternalBiologicallyDerivedProductValue.Builder builder() {
      return new ImmutableResourceList.InternalBiologicallyDerivedProductValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalBiologicallyDerivedProductValue InternalBiologicallyDerivedProductValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalBiologicallyDerivedProductValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_BIOLOGICALLY_DERIVED_PRODUCT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable BiologicallyDerivedProduct biologicallyDerivedProduct;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalBiologicallyDerivedProductValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalBiologicallyDerivedProductValue instance) {
        Objects.requireNonNull(instance, "instance");
        biologicallyDerivedProduct(instance.biologicallyDerivedProduct());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalBiologicallyDerivedProductValue#biologicallyDerivedProduct() biologicallyDerivedProduct} attribute.
       * @param biologicallyDerivedProduct The value for biologicallyDerivedProduct 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("biologicallyDerivedProduct")
      public final Builder biologicallyDerivedProduct(BiologicallyDerivedProduct biologicallyDerivedProduct) {
        this.biologicallyDerivedProduct = Objects.requireNonNull(biologicallyDerivedProduct, "biologicallyDerivedProduct");
        initBits &= ~INIT_BIT_BIOLOGICALLY_DERIVED_PRODUCT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalBiologicallyDerivedProductValue InternalBiologicallyDerivedProductValue}.
       * @return An immutable instance of InternalBiologicallyDerivedProductValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalBiologicallyDerivedProductValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalBiologicallyDerivedProductValue(biologicallyDerivedProduct);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_BIOLOGICALLY_DERIVED_PRODUCT) != 0) attributes.add("biologicallyDerivedProduct");
        return "Cannot build InternalBiologicallyDerivedProductValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalDeviceUseStatementValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalDeviceUseStatementValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalDeviceUseStatementValue", generator = "Immutables")
  @Immutable
  static final class InternalDeviceUseStatementValue
      implements ResourceList.InternalDeviceUseStatementValue {
    private final DeviceUseStatement deviceUseStatement;

    private InternalDeviceUseStatementValue(DeviceUseStatement deviceUseStatement) {
      this.deviceUseStatement = deviceUseStatement;
    }

    /**
     * @return The value of the {@code deviceUseStatement} attribute
     */
    @JsonProperty("deviceUseStatement")
    @JsonValue
    @Override
    public DeviceUseStatement deviceUseStatement() {
      return deviceUseStatement;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalDeviceUseStatementValue#deviceUseStatement() deviceUseStatement} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for deviceUseStatement
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalDeviceUseStatementValue withDeviceUseStatement(DeviceUseStatement value) {
      if (this.deviceUseStatement == value) return this;
      DeviceUseStatement newValue = Objects.requireNonNull(value, "deviceUseStatement");
      return new ImmutableResourceList.InternalDeviceUseStatementValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalDeviceUseStatementValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalDeviceUseStatementValue
          && equalTo((ImmutableResourceList.InternalDeviceUseStatementValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalDeviceUseStatementValue another) {
      return deviceUseStatement.equals(another.deviceUseStatement);
    }

    /**
     * Computes a hash code from attributes: {@code deviceUseStatement}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + deviceUseStatement.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalDeviceUseStatementValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalDeviceUseStatementValue{"
          + "deviceUseStatement=" + deviceUseStatement
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalDeviceUseStatementValue fromJson(DeviceUseStatement jsonValue) {
      ImmutableResourceList.InternalDeviceUseStatementValue.Builder builder = ImmutableResourceList.InternalDeviceUseStatementValue.builder();
      builder.deviceUseStatement(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalDeviceUseStatementValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalDeviceUseStatementValue instance
     */
    public static ImmutableResourceList.InternalDeviceUseStatementValue copyOf(ResourceList.InternalDeviceUseStatementValue instance) {
      if (instance instanceof ImmutableResourceList.InternalDeviceUseStatementValue) {
        return (ImmutableResourceList.InternalDeviceUseStatementValue) instance;
      }
      return ImmutableResourceList.InternalDeviceUseStatementValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalDeviceUseStatementValue InternalDeviceUseStatementValue}.
     * <pre>
     * ImmutableResourceList.InternalDeviceUseStatementValue.builder()
     *    .deviceUseStatement(com.fhir.types.fhir.DeviceUseStatement) // required {@link ResourceList.InternalDeviceUseStatementValue#deviceUseStatement() deviceUseStatement}
     *    .build();
     * </pre>
     * @return A new InternalDeviceUseStatementValue builder
     */
    public static ImmutableResourceList.InternalDeviceUseStatementValue.Builder builder() {
      return new ImmutableResourceList.InternalDeviceUseStatementValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalDeviceUseStatementValue InternalDeviceUseStatementValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalDeviceUseStatementValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_DEVICE_USE_STATEMENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable DeviceUseStatement deviceUseStatement;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalDeviceUseStatementValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalDeviceUseStatementValue instance) {
        Objects.requireNonNull(instance, "instance");
        deviceUseStatement(instance.deviceUseStatement());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalDeviceUseStatementValue#deviceUseStatement() deviceUseStatement} attribute.
       * @param deviceUseStatement The value for deviceUseStatement 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("deviceUseStatement")
      public final Builder deviceUseStatement(DeviceUseStatement deviceUseStatement) {
        this.deviceUseStatement = Objects.requireNonNull(deviceUseStatement, "deviceUseStatement");
        initBits &= ~INIT_BIT_DEVICE_USE_STATEMENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalDeviceUseStatementValue InternalDeviceUseStatementValue}.
       * @return An immutable instance of InternalDeviceUseStatementValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalDeviceUseStatementValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalDeviceUseStatementValue(deviceUseStatement);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_DEVICE_USE_STATEMENT) != 0) attributes.add("deviceUseStatement");
        return "Cannot build InternalDeviceUseStatementValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalProvenanceValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalProvenanceValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalProvenanceValue", generator = "Immutables")
  @Immutable
  static final class InternalProvenanceValue
      implements ResourceList.InternalProvenanceValue {
    private final Provenance provenance;

    private InternalProvenanceValue(Provenance provenance) {
      this.provenance = provenance;
    }

    /**
     * @return The value of the {@code provenance} attribute
     */
    @JsonProperty("provenance")
    @JsonValue
    @Override
    public Provenance provenance() {
      return provenance;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalProvenanceValue#provenance() provenance} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for provenance
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalProvenanceValue withProvenance(Provenance value) {
      if (this.provenance == value) return this;
      Provenance newValue = Objects.requireNonNull(value, "provenance");
      return new ImmutableResourceList.InternalProvenanceValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalProvenanceValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalProvenanceValue
          && equalTo((ImmutableResourceList.InternalProvenanceValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalProvenanceValue another) {
      return provenance.equals(another.provenance);
    }

    /**
     * Computes a hash code from attributes: {@code provenance}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + provenance.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalProvenanceValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalProvenanceValue{"
          + "provenance=" + provenance
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalProvenanceValue fromJson(Provenance jsonValue) {
      ImmutableResourceList.InternalProvenanceValue.Builder builder = ImmutableResourceList.InternalProvenanceValue.builder();
      builder.provenance(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalProvenanceValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalProvenanceValue instance
     */
    public static ImmutableResourceList.InternalProvenanceValue copyOf(ResourceList.InternalProvenanceValue instance) {
      if (instance instanceof ImmutableResourceList.InternalProvenanceValue) {
        return (ImmutableResourceList.InternalProvenanceValue) instance;
      }
      return ImmutableResourceList.InternalProvenanceValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalProvenanceValue InternalProvenanceValue}.
     * <pre>
     * ImmutableResourceList.InternalProvenanceValue.builder()
     *    .provenance(com.fhir.types.fhir.Provenance) // required {@link ResourceList.InternalProvenanceValue#provenance() provenance}
     *    .build();
     * </pre>
     * @return A new InternalProvenanceValue builder
     */
    public static ImmutableResourceList.InternalProvenanceValue.Builder builder() {
      return new ImmutableResourceList.InternalProvenanceValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalProvenanceValue InternalProvenanceValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalProvenanceValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PROVENANCE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Provenance provenance;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalProvenanceValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalProvenanceValue instance) {
        Objects.requireNonNull(instance, "instance");
        provenance(instance.provenance());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalProvenanceValue#provenance() provenance} attribute.
       * @param provenance The value for provenance 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("provenance")
      public final Builder provenance(Provenance provenance) {
        this.provenance = Objects.requireNonNull(provenance, "provenance");
        initBits &= ~INIT_BIT_PROVENANCE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalProvenanceValue InternalProvenanceValue}.
       * @return An immutable instance of InternalProvenanceValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalProvenanceValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalProvenanceValue(provenance);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PROVENANCE) != 0) attributes.add("provenance");
        return "Cannot build InternalProvenanceValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalClaimValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalClaimValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalClaimValue", generator = "Immutables")
  @Immutable
  static final class InternalClaimValue implements ResourceList.InternalClaimValue {
    private final Claim claim;

    private InternalClaimValue(Claim claim) {
      this.claim = claim;
    }

    /**
     * @return The value of the {@code claim} attribute
     */
    @JsonProperty("claim")
    @JsonValue
    @Override
    public Claim claim() {
      return claim;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalClaimValue#claim() claim} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for claim
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalClaimValue withClaim(Claim value) {
      if (this.claim == value) return this;
      Claim newValue = Objects.requireNonNull(value, "claim");
      return new ImmutableResourceList.InternalClaimValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalClaimValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalClaimValue
          && equalTo((ImmutableResourceList.InternalClaimValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalClaimValue another) {
      return claim.equals(another.claim);
    }

    /**
     * Computes a hash code from attributes: {@code claim}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + claim.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalClaimValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalClaimValue{"
          + "claim=" + claim
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalClaimValue fromJson(Claim jsonValue) {
      ImmutableResourceList.InternalClaimValue.Builder builder = ImmutableResourceList.InternalClaimValue.builder();
      builder.claim(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalClaimValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalClaimValue instance
     */
    public static ImmutableResourceList.InternalClaimValue copyOf(ResourceList.InternalClaimValue instance) {
      if (instance instanceof ImmutableResourceList.InternalClaimValue) {
        return (ImmutableResourceList.InternalClaimValue) instance;
      }
      return ImmutableResourceList.InternalClaimValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalClaimValue InternalClaimValue}.
     * <pre>
     * ImmutableResourceList.InternalClaimValue.builder()
     *    .claim(com.fhir.types.fhir.Claim) // required {@link ResourceList.InternalClaimValue#claim() claim}
     *    .build();
     * </pre>
     * @return A new InternalClaimValue builder
     */
    public static ImmutableResourceList.InternalClaimValue.Builder builder() {
      return new ImmutableResourceList.InternalClaimValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalClaimValue InternalClaimValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalClaimValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CLAIM = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Claim claim;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalClaimValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalClaimValue instance) {
        Objects.requireNonNull(instance, "instance");
        claim(instance.claim());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalClaimValue#claim() claim} attribute.
       * @param claim The value for claim 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("claim")
      public final Builder claim(Claim claim) {
        this.claim = Objects.requireNonNull(claim, "claim");
        initBits &= ~INIT_BIT_CLAIM;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalClaimValue InternalClaimValue}.
       * @return An immutable instance of InternalClaimValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalClaimValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalClaimValue(claim);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CLAIM) != 0) attributes.add("claim");
        return "Cannot build InternalClaimValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalServiceRequestValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalServiceRequestValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalServiceRequestValue", generator = "Immutables")
  @Immutable
  static final class InternalServiceRequestValue
      implements ResourceList.InternalServiceRequestValue {
    private final ServiceRequest serviceRequest;

    private InternalServiceRequestValue(ServiceRequest serviceRequest) {
      this.serviceRequest = serviceRequest;
    }

    /**
     * @return The value of the {@code serviceRequest} attribute
     */
    @JsonProperty("serviceRequest")
    @JsonValue
    @Override
    public ServiceRequest serviceRequest() {
      return serviceRequest;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalServiceRequestValue#serviceRequest() serviceRequest} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for serviceRequest
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalServiceRequestValue withServiceRequest(ServiceRequest value) {
      if (this.serviceRequest == value) return this;
      ServiceRequest newValue = Objects.requireNonNull(value, "serviceRequest");
      return new ImmutableResourceList.InternalServiceRequestValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalServiceRequestValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalServiceRequestValue
          && equalTo((ImmutableResourceList.InternalServiceRequestValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalServiceRequestValue another) {
      return serviceRequest.equals(another.serviceRequest);
    }

    /**
     * Computes a hash code from attributes: {@code serviceRequest}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + serviceRequest.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalServiceRequestValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalServiceRequestValue{"
          + "serviceRequest=" + serviceRequest
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalServiceRequestValue fromJson(ServiceRequest jsonValue) {
      ImmutableResourceList.InternalServiceRequestValue.Builder builder = ImmutableResourceList.InternalServiceRequestValue.builder();
      builder.serviceRequest(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalServiceRequestValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalServiceRequestValue instance
     */
    public static ImmutableResourceList.InternalServiceRequestValue copyOf(ResourceList.InternalServiceRequestValue instance) {
      if (instance instanceof ImmutableResourceList.InternalServiceRequestValue) {
        return (ImmutableResourceList.InternalServiceRequestValue) instance;
      }
      return ImmutableResourceList.InternalServiceRequestValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalServiceRequestValue InternalServiceRequestValue}.
     * <pre>
     * ImmutableResourceList.InternalServiceRequestValue.builder()
     *    .serviceRequest(com.fhir.types.fhir.ServiceRequest) // required {@link ResourceList.InternalServiceRequestValue#serviceRequest() serviceRequest}
     *    .build();
     * </pre>
     * @return A new InternalServiceRequestValue builder
     */
    public static ImmutableResourceList.InternalServiceRequestValue.Builder builder() {
      return new ImmutableResourceList.InternalServiceRequestValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalServiceRequestValue InternalServiceRequestValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalServiceRequestValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SERVICE_REQUEST = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ServiceRequest serviceRequest;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalServiceRequestValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalServiceRequestValue instance) {
        Objects.requireNonNull(instance, "instance");
        serviceRequest(instance.serviceRequest());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalServiceRequestValue#serviceRequest() serviceRequest} attribute.
       * @param serviceRequest The value for serviceRequest 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("serviceRequest")
      public final Builder serviceRequest(ServiceRequest serviceRequest) {
        this.serviceRequest = Objects.requireNonNull(serviceRequest, "serviceRequest");
        initBits &= ~INIT_BIT_SERVICE_REQUEST;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalServiceRequestValue InternalServiceRequestValue}.
       * @return An immutable instance of InternalServiceRequestValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalServiceRequestValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalServiceRequestValue(serviceRequest);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SERVICE_REQUEST) != 0) attributes.add("serviceRequest");
        return "Cannot build InternalServiceRequestValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSubstanceReferenceInformationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSubstanceReferenceInformationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSubstanceReferenceInformationValue", generator = "Immutables")
  @Immutable
  static final class InternalSubstanceReferenceInformationValue
      implements ResourceList.InternalSubstanceReferenceInformationValue {
    private final SubstanceReferenceInformation substanceReferenceInformation;

    private InternalSubstanceReferenceInformationValue(SubstanceReferenceInformation substanceReferenceInformation) {
      this.substanceReferenceInformation = substanceReferenceInformation;
    }

    /**
     * @return The value of the {@code substanceReferenceInformation} attribute
     */
    @JsonProperty("substanceReferenceInformation")
    @JsonValue
    @Override
    public SubstanceReferenceInformation substanceReferenceInformation() {
      return substanceReferenceInformation;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSubstanceReferenceInformationValue#substanceReferenceInformation() substanceReferenceInformation} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for substanceReferenceInformation
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSubstanceReferenceInformationValue withSubstanceReferenceInformation(SubstanceReferenceInformation value) {
      if (this.substanceReferenceInformation == value) return this;
      SubstanceReferenceInformation newValue = Objects.requireNonNull(value, "substanceReferenceInformation");
      return new ImmutableResourceList.InternalSubstanceReferenceInformationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSubstanceReferenceInformationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSubstanceReferenceInformationValue
          && equalTo((ImmutableResourceList.InternalSubstanceReferenceInformationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSubstanceReferenceInformationValue another) {
      return substanceReferenceInformation.equals(another.substanceReferenceInformation);
    }

    /**
     * Computes a hash code from attributes: {@code substanceReferenceInformation}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + substanceReferenceInformation.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSubstanceReferenceInformationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSubstanceReferenceInformationValue{"
          + "substanceReferenceInformation=" + substanceReferenceInformation
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSubstanceReferenceInformationValue fromJson(SubstanceReferenceInformation jsonValue) {
      ImmutableResourceList.InternalSubstanceReferenceInformationValue.Builder builder = ImmutableResourceList.InternalSubstanceReferenceInformationValue.builder();
      builder.substanceReferenceInformation(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSubstanceReferenceInformationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSubstanceReferenceInformationValue instance
     */
    public static ImmutableResourceList.InternalSubstanceReferenceInformationValue copyOf(ResourceList.InternalSubstanceReferenceInformationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSubstanceReferenceInformationValue) {
        return (ImmutableResourceList.InternalSubstanceReferenceInformationValue) instance;
      }
      return ImmutableResourceList.InternalSubstanceReferenceInformationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSubstanceReferenceInformationValue InternalSubstanceReferenceInformationValue}.
     * <pre>
     * ImmutableResourceList.InternalSubstanceReferenceInformationValue.builder()
     *    .substanceReferenceInformation(com.fhir.types.fhir.SubstanceReferenceInformation) // required {@link ResourceList.InternalSubstanceReferenceInformationValue#substanceReferenceInformation() substanceReferenceInformation}
     *    .build();
     * </pre>
     * @return A new InternalSubstanceReferenceInformationValue builder
     */
    public static ImmutableResourceList.InternalSubstanceReferenceInformationValue.Builder builder() {
      return new ImmutableResourceList.InternalSubstanceReferenceInformationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSubstanceReferenceInformationValue InternalSubstanceReferenceInformationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSubstanceReferenceInformationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUBSTANCE_REFERENCE_INFORMATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SubstanceReferenceInformation substanceReferenceInformation;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSubstanceReferenceInformationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSubstanceReferenceInformationValue instance) {
        Objects.requireNonNull(instance, "instance");
        substanceReferenceInformation(instance.substanceReferenceInformation());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSubstanceReferenceInformationValue#substanceReferenceInformation() substanceReferenceInformation} attribute.
       * @param substanceReferenceInformation The value for substanceReferenceInformation 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("substanceReferenceInformation")
      public final Builder substanceReferenceInformation(SubstanceReferenceInformation substanceReferenceInformation) {
        this.substanceReferenceInformation = Objects.requireNonNull(substanceReferenceInformation, "substanceReferenceInformation");
        initBits &= ~INIT_BIT_SUBSTANCE_REFERENCE_INFORMATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSubstanceReferenceInformationValue InternalSubstanceReferenceInformationValue}.
       * @return An immutable instance of InternalSubstanceReferenceInformationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSubstanceReferenceInformationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSubstanceReferenceInformationValue(substanceReferenceInformation);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUBSTANCE_REFERENCE_INFORMATION) != 0) attributes.add("substanceReferenceInformation");
        return "Cannot build InternalSubstanceReferenceInformationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicationValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicationValue
      implements ResourceList.InternalMedicationValue {
    private final Medication medication;

    private InternalMedicationValue(Medication medication) {
      this.medication = medication;
    }

    /**
     * @return The value of the {@code medication} attribute
     */
    @JsonProperty("medication")
    @JsonValue
    @Override
    public Medication medication() {
      return medication;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicationValue#medication() medication} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medication
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicationValue withMedication(Medication value) {
      if (this.medication == value) return this;
      Medication newValue = Objects.requireNonNull(value, "medication");
      return new ImmutableResourceList.InternalMedicationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicationValue
          && equalTo((ImmutableResourceList.InternalMedicationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicationValue another) {
      return medication.equals(another.medication);
    }

    /**
     * Computes a hash code from attributes: {@code medication}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medication.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicationValue{"
          + "medication=" + medication
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicationValue fromJson(Medication jsonValue) {
      ImmutableResourceList.InternalMedicationValue.Builder builder = ImmutableResourceList.InternalMedicationValue.builder();
      builder.medication(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicationValue instance
     */
    public static ImmutableResourceList.InternalMedicationValue copyOf(ResourceList.InternalMedicationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicationValue) {
        return (ImmutableResourceList.InternalMedicationValue) instance;
      }
      return ImmutableResourceList.InternalMedicationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicationValue InternalMedicationValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicationValue.builder()
     *    .medication(com.fhir.types.fhir.Medication) // required {@link ResourceList.InternalMedicationValue#medication() medication}
     *    .build();
     * </pre>
     * @return A new InternalMedicationValue builder
     */
    public static ImmutableResourceList.InternalMedicationValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicationValue InternalMedicationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Medication medication;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicationValue instance) {
        Objects.requireNonNull(instance, "instance");
        medication(instance.medication());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicationValue#medication() medication} attribute.
       * @param medication The value for medication 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medication")
      public final Builder medication(Medication medication) {
        this.medication = Objects.requireNonNull(medication, "medication");
        initBits &= ~INIT_BIT_MEDICATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicationValue InternalMedicationValue}.
       * @return An immutable instance of InternalMedicationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicationValue(medication);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICATION) != 0) attributes.add("medication");
        return "Cannot build InternalMedicationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalDocumentReferenceValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalDocumentReferenceValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalDocumentReferenceValue", generator = "Immutables")
  @Immutable
  static final class InternalDocumentReferenceValue
      implements ResourceList.InternalDocumentReferenceValue {
    private final DocumentReference documentReference;

    private InternalDocumentReferenceValue(DocumentReference documentReference) {
      this.documentReference = documentReference;
    }

    /**
     * @return The value of the {@code documentReference} attribute
     */
    @JsonProperty("documentReference")
    @JsonValue
    @Override
    public DocumentReference documentReference() {
      return documentReference;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalDocumentReferenceValue#documentReference() documentReference} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for documentReference
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalDocumentReferenceValue withDocumentReference(DocumentReference value) {
      if (this.documentReference == value) return this;
      DocumentReference newValue = Objects.requireNonNull(value, "documentReference");
      return new ImmutableResourceList.InternalDocumentReferenceValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalDocumentReferenceValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalDocumentReferenceValue
          && equalTo((ImmutableResourceList.InternalDocumentReferenceValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalDocumentReferenceValue another) {
      return documentReference.equals(another.documentReference);
    }

    /**
     * Computes a hash code from attributes: {@code documentReference}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + documentReference.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalDocumentReferenceValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalDocumentReferenceValue{"
          + "documentReference=" + documentReference
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalDocumentReferenceValue fromJson(DocumentReference jsonValue) {
      ImmutableResourceList.InternalDocumentReferenceValue.Builder builder = ImmutableResourceList.InternalDocumentReferenceValue.builder();
      builder.documentReference(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalDocumentReferenceValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalDocumentReferenceValue instance
     */
    public static ImmutableResourceList.InternalDocumentReferenceValue copyOf(ResourceList.InternalDocumentReferenceValue instance) {
      if (instance instanceof ImmutableResourceList.InternalDocumentReferenceValue) {
        return (ImmutableResourceList.InternalDocumentReferenceValue) instance;
      }
      return ImmutableResourceList.InternalDocumentReferenceValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalDocumentReferenceValue InternalDocumentReferenceValue}.
     * <pre>
     * ImmutableResourceList.InternalDocumentReferenceValue.builder()
     *    .documentReference(com.fhir.types.fhir.DocumentReference) // required {@link ResourceList.InternalDocumentReferenceValue#documentReference() documentReference}
     *    .build();
     * </pre>
     * @return A new InternalDocumentReferenceValue builder
     */
    public static ImmutableResourceList.InternalDocumentReferenceValue.Builder builder() {
      return new ImmutableResourceList.InternalDocumentReferenceValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalDocumentReferenceValue InternalDocumentReferenceValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalDocumentReferenceValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_DOCUMENT_REFERENCE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable DocumentReference documentReference;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalDocumentReferenceValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalDocumentReferenceValue instance) {
        Objects.requireNonNull(instance, "instance");
        documentReference(instance.documentReference());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalDocumentReferenceValue#documentReference() documentReference} attribute.
       * @param documentReference The value for documentReference 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("documentReference")
      public final Builder documentReference(DocumentReference documentReference) {
        this.documentReference = Objects.requireNonNull(documentReference, "documentReference");
        initBits &= ~INIT_BIT_DOCUMENT_REFERENCE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalDocumentReferenceValue InternalDocumentReferenceValue}.
       * @return An immutable instance of InternalDocumentReferenceValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalDocumentReferenceValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalDocumentReferenceValue(documentReference);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_DOCUMENT_REFERENCE) != 0) attributes.add("documentReference");
        return "Cannot build InternalDocumentReferenceValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalImmunizationEvaluationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalImmunizationEvaluationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalImmunizationEvaluationValue", generator = "Immutables")
  @Immutable
  static final class InternalImmunizationEvaluationValue
      implements ResourceList.InternalImmunizationEvaluationValue {
    private final ImmunizationEvaluation immunizationEvaluation;

    private InternalImmunizationEvaluationValue(ImmunizationEvaluation immunizationEvaluation) {
      this.immunizationEvaluation = immunizationEvaluation;
    }

    /**
     * @return The value of the {@code immunizationEvaluation} attribute
     */
    @JsonProperty("immunizationEvaluation")
    @JsonValue
    @Override
    public ImmunizationEvaluation immunizationEvaluation() {
      return immunizationEvaluation;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalImmunizationEvaluationValue#immunizationEvaluation() immunizationEvaluation} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for immunizationEvaluation
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalImmunizationEvaluationValue withImmunizationEvaluation(ImmunizationEvaluation value) {
      if (this.immunizationEvaluation == value) return this;
      ImmunizationEvaluation newValue = Objects.requireNonNull(value, "immunizationEvaluation");
      return new ImmutableResourceList.InternalImmunizationEvaluationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalImmunizationEvaluationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalImmunizationEvaluationValue
          && equalTo((ImmutableResourceList.InternalImmunizationEvaluationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalImmunizationEvaluationValue another) {
      return immunizationEvaluation.equals(another.immunizationEvaluation);
    }

    /**
     * Computes a hash code from attributes: {@code immunizationEvaluation}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + immunizationEvaluation.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalImmunizationEvaluationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalImmunizationEvaluationValue{"
          + "immunizationEvaluation=" + immunizationEvaluation
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalImmunizationEvaluationValue fromJson(ImmunizationEvaluation jsonValue) {
      ImmutableResourceList.InternalImmunizationEvaluationValue.Builder builder = ImmutableResourceList.InternalImmunizationEvaluationValue.builder();
      builder.immunizationEvaluation(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalImmunizationEvaluationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalImmunizationEvaluationValue instance
     */
    public static ImmutableResourceList.InternalImmunizationEvaluationValue copyOf(ResourceList.InternalImmunizationEvaluationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalImmunizationEvaluationValue) {
        return (ImmutableResourceList.InternalImmunizationEvaluationValue) instance;
      }
      return ImmutableResourceList.InternalImmunizationEvaluationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalImmunizationEvaluationValue InternalImmunizationEvaluationValue}.
     * <pre>
     * ImmutableResourceList.InternalImmunizationEvaluationValue.builder()
     *    .immunizationEvaluation(com.fhir.types.fhir.ImmunizationEvaluation) // required {@link ResourceList.InternalImmunizationEvaluationValue#immunizationEvaluation() immunizationEvaluation}
     *    .build();
     * </pre>
     * @return A new InternalImmunizationEvaluationValue builder
     */
    public static ImmutableResourceList.InternalImmunizationEvaluationValue.Builder builder() {
      return new ImmutableResourceList.InternalImmunizationEvaluationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalImmunizationEvaluationValue InternalImmunizationEvaluationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalImmunizationEvaluationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_IMMUNIZATION_EVALUATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ImmunizationEvaluation immunizationEvaluation;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalImmunizationEvaluationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalImmunizationEvaluationValue instance) {
        Objects.requireNonNull(instance, "instance");
        immunizationEvaluation(instance.immunizationEvaluation());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalImmunizationEvaluationValue#immunizationEvaluation() immunizationEvaluation} attribute.
       * @param immunizationEvaluation The value for immunizationEvaluation 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("immunizationEvaluation")
      public final Builder immunizationEvaluation(ImmunizationEvaluation immunizationEvaluation) {
        this.immunizationEvaluation = Objects.requireNonNull(immunizationEvaluation, "immunizationEvaluation");
        initBits &= ~INIT_BIT_IMMUNIZATION_EVALUATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalImmunizationEvaluationValue InternalImmunizationEvaluationValue}.
       * @return An immutable instance of InternalImmunizationEvaluationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalImmunizationEvaluationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalImmunizationEvaluationValue(immunizationEvaluation);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_IMMUNIZATION_EVALUATION) != 0) attributes.add("immunizationEvaluation");
        return "Cannot build InternalImmunizationEvaluationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductInteractionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductInteractionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductInteractionValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductInteractionValue
      implements ResourceList.InternalMedicinalProductInteractionValue {
    private final MedicinalProductInteraction medicinalProductInteraction;

    private InternalMedicinalProductInteractionValue(MedicinalProductInteraction medicinalProductInteraction) {
      this.medicinalProductInteraction = medicinalProductInteraction;
    }

    /**
     * @return The value of the {@code medicinalProductInteraction} attribute
     */
    @JsonProperty("medicinalProductInteraction")
    @JsonValue
    @Override
    public MedicinalProductInteraction medicinalProductInteraction() {
      return medicinalProductInteraction;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductInteractionValue#medicinalProductInteraction() medicinalProductInteraction} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProductInteraction
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductInteractionValue withMedicinalProductInteraction(MedicinalProductInteraction value) {
      if (this.medicinalProductInteraction == value) return this;
      MedicinalProductInteraction newValue = Objects.requireNonNull(value, "medicinalProductInteraction");
      return new ImmutableResourceList.InternalMedicinalProductInteractionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductInteractionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductInteractionValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductInteractionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductInteractionValue another) {
      return medicinalProductInteraction.equals(another.medicinalProductInteraction);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProductInteraction}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProductInteraction.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductInteractionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductInteractionValue{"
          + "medicinalProductInteraction=" + medicinalProductInteraction
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductInteractionValue fromJson(MedicinalProductInteraction jsonValue) {
      ImmutableResourceList.InternalMedicinalProductInteractionValue.Builder builder = ImmutableResourceList.InternalMedicinalProductInteractionValue.builder();
      builder.medicinalProductInteraction(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductInteractionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductInteractionValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductInteractionValue copyOf(ResourceList.InternalMedicinalProductInteractionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductInteractionValue) {
        return (ImmutableResourceList.InternalMedicinalProductInteractionValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductInteractionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductInteractionValue InternalMedicinalProductInteractionValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductInteractionValue.builder()
     *    .medicinalProductInteraction(com.fhir.types.fhir.MedicinalProductInteraction) // required {@link ResourceList.InternalMedicinalProductInteractionValue#medicinalProductInteraction() medicinalProductInteraction}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductInteractionValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductInteractionValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductInteractionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductInteractionValue InternalMedicinalProductInteractionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductInteractionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT_INTERACTION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProductInteraction medicinalProductInteraction;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductInteractionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductInteractionValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProductInteraction(instance.medicinalProductInteraction());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductInteractionValue#medicinalProductInteraction() medicinalProductInteraction} attribute.
       * @param medicinalProductInteraction The value for medicinalProductInteraction 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProductInteraction")
      public final Builder medicinalProductInteraction(MedicinalProductInteraction medicinalProductInteraction) {
        this.medicinalProductInteraction = Objects.requireNonNull(medicinalProductInteraction, "medicinalProductInteraction");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT_INTERACTION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductInteractionValue InternalMedicinalProductInteractionValue}.
       * @return An immutable instance of InternalMedicinalProductInteractionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductInteractionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductInteractionValue(medicinalProductInteraction);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT_INTERACTION) != 0) attributes.add("medicinalProductInteraction");
        return "Cannot build InternalMedicinalProductInteractionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalBasicValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalBasicValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalBasicValue", generator = "Immutables")
  @Immutable
  static final class InternalBasicValue implements ResourceList.InternalBasicValue {
    private final Basic basic;

    private InternalBasicValue(Basic basic) {
      this.basic = basic;
    }

    /**
     * @return The value of the {@code basic} attribute
     */
    @JsonProperty("basic")
    @JsonValue
    @Override
    public Basic basic() {
      return basic;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalBasicValue#basic() basic} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for basic
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalBasicValue withBasic(Basic value) {
      if (this.basic == value) return this;
      Basic newValue = Objects.requireNonNull(value, "basic");
      return new ImmutableResourceList.InternalBasicValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalBasicValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalBasicValue
          && equalTo((ImmutableResourceList.InternalBasicValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalBasicValue another) {
      return basic.equals(another.basic);
    }

    /**
     * Computes a hash code from attributes: {@code basic}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + basic.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalBasicValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalBasicValue{"
          + "basic=" + basic
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalBasicValue fromJson(Basic jsonValue) {
      ImmutableResourceList.InternalBasicValue.Builder builder = ImmutableResourceList.InternalBasicValue.builder();
      builder.basic(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalBasicValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalBasicValue instance
     */
    public static ImmutableResourceList.InternalBasicValue copyOf(ResourceList.InternalBasicValue instance) {
      if (instance instanceof ImmutableResourceList.InternalBasicValue) {
        return (ImmutableResourceList.InternalBasicValue) instance;
      }
      return ImmutableResourceList.InternalBasicValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalBasicValue InternalBasicValue}.
     * <pre>
     * ImmutableResourceList.InternalBasicValue.builder()
     *    .basic(com.fhir.types.fhir.Basic) // required {@link ResourceList.InternalBasicValue#basic() basic}
     *    .build();
     * </pre>
     * @return A new InternalBasicValue builder
     */
    public static ImmutableResourceList.InternalBasicValue.Builder builder() {
      return new ImmutableResourceList.InternalBasicValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalBasicValue InternalBasicValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalBasicValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_BASIC = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Basic basic;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalBasicValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalBasicValue instance) {
        Objects.requireNonNull(instance, "instance");
        basic(instance.basic());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalBasicValue#basic() basic} attribute.
       * @param basic The value for basic 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("basic")
      public final Builder basic(Basic basic) {
        this.basic = Objects.requireNonNull(basic, "basic");
        initBits &= ~INIT_BIT_BASIC;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalBasicValue InternalBasicValue}.
       * @return An immutable instance of InternalBasicValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalBasicValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalBasicValue(basic);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_BASIC) != 0) attributes.add("basic");
        return "Cannot build InternalBasicValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicinalProductUndesirableEffectValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicinalProductUndesirableEffectValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicinalProductUndesirableEffectValue
      implements ResourceList.InternalMedicinalProductUndesirableEffectValue {
    private final MedicinalProductUndesirableEffect medicinalProductUndesirableEffect;

    private InternalMedicinalProductUndesirableEffectValue(MedicinalProductUndesirableEffect medicinalProductUndesirableEffect) {
      this.medicinalProductUndesirableEffect = medicinalProductUndesirableEffect;
    }

    /**
     * @return The value of the {@code medicinalProductUndesirableEffect} attribute
     */
    @JsonProperty("medicinalProductUndesirableEffect")
    @JsonValue
    @Override
    public MedicinalProductUndesirableEffect medicinalProductUndesirableEffect() {
      return medicinalProductUndesirableEffect;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicinalProductUndesirableEffectValue#medicinalProductUndesirableEffect() medicinalProductUndesirableEffect} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicinalProductUndesirableEffect
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue withMedicinalProductUndesirableEffect(MedicinalProductUndesirableEffect value) {
      if (this.medicinalProductUndesirableEffect == value) return this;
      MedicinalProductUndesirableEffect newValue = Objects.requireNonNull(value, "medicinalProductUndesirableEffect");
      return new ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicinalProductUndesirableEffectValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue
          && equalTo((ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue another) {
      return medicinalProductUndesirableEffect.equals(another.medicinalProductUndesirableEffect);
    }

    /**
     * Computes a hash code from attributes: {@code medicinalProductUndesirableEffect}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicinalProductUndesirableEffect.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicinalProductUndesirableEffectValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicinalProductUndesirableEffectValue{"
          + "medicinalProductUndesirableEffect=" + medicinalProductUndesirableEffect
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue fromJson(MedicinalProductUndesirableEffect jsonValue) {
      ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue.Builder builder = ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue.builder();
      builder.medicinalProductUndesirableEffect(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicinalProductUndesirableEffectValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicinalProductUndesirableEffectValue instance
     */
    public static ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue copyOf(ResourceList.InternalMedicinalProductUndesirableEffectValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue) {
        return (ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue) instance;
      }
      return ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue InternalMedicinalProductUndesirableEffectValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue.builder()
     *    .medicinalProductUndesirableEffect(com.fhir.types.fhir.MedicinalProductUndesirableEffect) // required {@link ResourceList.InternalMedicinalProductUndesirableEffectValue#medicinalProductUndesirableEffect() medicinalProductUndesirableEffect}
     *    .build();
     * </pre>
     * @return A new InternalMedicinalProductUndesirableEffectValue builder
     */
    public static ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue InternalMedicinalProductUndesirableEffectValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicinalProductUndesirableEffectValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICINAL_PRODUCT_UNDESIRABLE_EFFECT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicinalProductUndesirableEffect medicinalProductUndesirableEffect;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicinalProductUndesirableEffectValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicinalProductUndesirableEffectValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicinalProductUndesirableEffect(instance.medicinalProductUndesirableEffect());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicinalProductUndesirableEffectValue#medicinalProductUndesirableEffect() medicinalProductUndesirableEffect} attribute.
       * @param medicinalProductUndesirableEffect The value for medicinalProductUndesirableEffect 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicinalProductUndesirableEffect")
      public final Builder medicinalProductUndesirableEffect(MedicinalProductUndesirableEffect medicinalProductUndesirableEffect) {
        this.medicinalProductUndesirableEffect = Objects.requireNonNull(medicinalProductUndesirableEffect, "medicinalProductUndesirableEffect");
        initBits &= ~INIT_BIT_MEDICINAL_PRODUCT_UNDESIRABLE_EFFECT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue InternalMedicinalProductUndesirableEffectValue}.
       * @return An immutable instance of InternalMedicinalProductUndesirableEffectValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicinalProductUndesirableEffectValue(medicinalProductUndesirableEffect);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICINAL_PRODUCT_UNDESIRABLE_EFFECT) != 0) attributes.add("medicinalProductUndesirableEffect");
        return "Cannot build InternalMedicinalProductUndesirableEffectValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalImplementationGuideValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalImplementationGuideValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalImplementationGuideValue", generator = "Immutables")
  @Immutable
  static final class InternalImplementationGuideValue
      implements ResourceList.InternalImplementationGuideValue {
    private final ImplementationGuide implementationGuide;

    private InternalImplementationGuideValue(ImplementationGuide implementationGuide) {
      this.implementationGuide = implementationGuide;
    }

    /**
     * @return The value of the {@code implementationGuide} attribute
     */
    @JsonProperty("implementationGuide")
    @JsonValue
    @Override
    public ImplementationGuide implementationGuide() {
      return implementationGuide;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalImplementationGuideValue#implementationGuide() implementationGuide} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for implementationGuide
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalImplementationGuideValue withImplementationGuide(ImplementationGuide value) {
      if (this.implementationGuide == value) return this;
      ImplementationGuide newValue = Objects.requireNonNull(value, "implementationGuide");
      return new ImmutableResourceList.InternalImplementationGuideValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalImplementationGuideValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalImplementationGuideValue
          && equalTo((ImmutableResourceList.InternalImplementationGuideValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalImplementationGuideValue another) {
      return implementationGuide.equals(another.implementationGuide);
    }

    /**
     * Computes a hash code from attributes: {@code implementationGuide}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + implementationGuide.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalImplementationGuideValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalImplementationGuideValue{"
          + "implementationGuide=" + implementationGuide
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalImplementationGuideValue fromJson(ImplementationGuide jsonValue) {
      ImmutableResourceList.InternalImplementationGuideValue.Builder builder = ImmutableResourceList.InternalImplementationGuideValue.builder();
      builder.implementationGuide(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalImplementationGuideValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalImplementationGuideValue instance
     */
    public static ImmutableResourceList.InternalImplementationGuideValue copyOf(ResourceList.InternalImplementationGuideValue instance) {
      if (instance instanceof ImmutableResourceList.InternalImplementationGuideValue) {
        return (ImmutableResourceList.InternalImplementationGuideValue) instance;
      }
      return ImmutableResourceList.InternalImplementationGuideValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalImplementationGuideValue InternalImplementationGuideValue}.
     * <pre>
     * ImmutableResourceList.InternalImplementationGuideValue.builder()
     *    .implementationGuide(com.fhir.types.fhir.ImplementationGuide) // required {@link ResourceList.InternalImplementationGuideValue#implementationGuide() implementationGuide}
     *    .build();
     * </pre>
     * @return A new InternalImplementationGuideValue builder
     */
    public static ImmutableResourceList.InternalImplementationGuideValue.Builder builder() {
      return new ImmutableResourceList.InternalImplementationGuideValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalImplementationGuideValue InternalImplementationGuideValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalImplementationGuideValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_IMPLEMENTATION_GUIDE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ImplementationGuide implementationGuide;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalImplementationGuideValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalImplementationGuideValue instance) {
        Objects.requireNonNull(instance, "instance");
        implementationGuide(instance.implementationGuide());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalImplementationGuideValue#implementationGuide() implementationGuide} attribute.
       * @param implementationGuide The value for implementationGuide 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("implementationGuide")
      public final Builder implementationGuide(ImplementationGuide implementationGuide) {
        this.implementationGuide = Objects.requireNonNull(implementationGuide, "implementationGuide");
        initBits &= ~INIT_BIT_IMPLEMENTATION_GUIDE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalImplementationGuideValue InternalImplementationGuideValue}.
       * @return An immutable instance of InternalImplementationGuideValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalImplementationGuideValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalImplementationGuideValue(implementationGuide);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_IMPLEMENTATION_GUIDE) != 0) attributes.add("implementationGuide");
        return "Cannot build InternalImplementationGuideValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCarePlanValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCarePlanValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCarePlanValue", generator = "Immutables")
  @Immutable
  static final class InternalCarePlanValue implements ResourceList.InternalCarePlanValue {
    private final CarePlan carePlan;

    private InternalCarePlanValue(CarePlan carePlan) {
      this.carePlan = carePlan;
    }

    /**
     * @return The value of the {@code carePlan} attribute
     */
    @JsonProperty("carePlan")
    @JsonValue
    @Override
    public CarePlan carePlan() {
      return carePlan;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCarePlanValue#carePlan() carePlan} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for carePlan
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCarePlanValue withCarePlan(CarePlan value) {
      if (this.carePlan == value) return this;
      CarePlan newValue = Objects.requireNonNull(value, "carePlan");
      return new ImmutableResourceList.InternalCarePlanValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCarePlanValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCarePlanValue
          && equalTo((ImmutableResourceList.InternalCarePlanValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCarePlanValue another) {
      return carePlan.equals(another.carePlan);
    }

    /**
     * Computes a hash code from attributes: {@code carePlan}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + carePlan.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCarePlanValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCarePlanValue{"
          + "carePlan=" + carePlan
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCarePlanValue fromJson(CarePlan jsonValue) {
      ImmutableResourceList.InternalCarePlanValue.Builder builder = ImmutableResourceList.InternalCarePlanValue.builder();
      builder.carePlan(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCarePlanValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCarePlanValue instance
     */
    public static ImmutableResourceList.InternalCarePlanValue copyOf(ResourceList.InternalCarePlanValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCarePlanValue) {
        return (ImmutableResourceList.InternalCarePlanValue) instance;
      }
      return ImmutableResourceList.InternalCarePlanValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCarePlanValue InternalCarePlanValue}.
     * <pre>
     * ImmutableResourceList.InternalCarePlanValue.builder()
     *    .carePlan(com.fhir.types.fhir.CarePlan) // required {@link ResourceList.InternalCarePlanValue#carePlan() carePlan}
     *    .build();
     * </pre>
     * @return A new InternalCarePlanValue builder
     */
    public static ImmutableResourceList.InternalCarePlanValue.Builder builder() {
      return new ImmutableResourceList.InternalCarePlanValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCarePlanValue InternalCarePlanValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCarePlanValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CARE_PLAN = 0x1L;
      private long initBits = 0x1L;

      private @Nullable CarePlan carePlan;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCarePlanValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCarePlanValue instance) {
        Objects.requireNonNull(instance, "instance");
        carePlan(instance.carePlan());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCarePlanValue#carePlan() carePlan} attribute.
       * @param carePlan The value for carePlan 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("carePlan")
      public final Builder carePlan(CarePlan carePlan) {
        this.carePlan = Objects.requireNonNull(carePlan, "carePlan");
        initBits &= ~INIT_BIT_CARE_PLAN;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCarePlanValue InternalCarePlanValue}.
       * @return An immutable instance of InternalCarePlanValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCarePlanValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCarePlanValue(carePlan);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CARE_PLAN) != 0) attributes.add("carePlan");
        return "Cannot build InternalCarePlanValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalObservationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalObservationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalObservationValue", generator = "Immutables")
  @Immutable
  static final class InternalObservationValue
      implements ResourceList.InternalObservationValue {
    private final Observation observation;

    private InternalObservationValue(Observation observation) {
      this.observation = observation;
    }

    /**
     * @return The value of the {@code observation} attribute
     */
    @JsonProperty("observation")
    @JsonValue
    @Override
    public Observation observation() {
      return observation;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalObservationValue#observation() observation} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for observation
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalObservationValue withObservation(Observation value) {
      if (this.observation == value) return this;
      Observation newValue = Objects.requireNonNull(value, "observation");
      return new ImmutableResourceList.InternalObservationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalObservationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalObservationValue
          && equalTo((ImmutableResourceList.InternalObservationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalObservationValue another) {
      return observation.equals(another.observation);
    }

    /**
     * Computes a hash code from attributes: {@code observation}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + observation.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalObservationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalObservationValue{"
          + "observation=" + observation
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalObservationValue fromJson(Observation jsonValue) {
      ImmutableResourceList.InternalObservationValue.Builder builder = ImmutableResourceList.InternalObservationValue.builder();
      builder.observation(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalObservationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalObservationValue instance
     */
    public static ImmutableResourceList.InternalObservationValue copyOf(ResourceList.InternalObservationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalObservationValue) {
        return (ImmutableResourceList.InternalObservationValue) instance;
      }
      return ImmutableResourceList.InternalObservationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalObservationValue InternalObservationValue}.
     * <pre>
     * ImmutableResourceList.InternalObservationValue.builder()
     *    .observation(com.fhir.types.fhir.Observation) // required {@link ResourceList.InternalObservationValue#observation() observation}
     *    .build();
     * </pre>
     * @return A new InternalObservationValue builder
     */
    public static ImmutableResourceList.InternalObservationValue.Builder builder() {
      return new ImmutableResourceList.InternalObservationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalObservationValue InternalObservationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalObservationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_OBSERVATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Observation observation;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalObservationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalObservationValue instance) {
        Objects.requireNonNull(instance, "instance");
        observation(instance.observation());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalObservationValue#observation() observation} attribute.
       * @param observation The value for observation 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("observation")
      public final Builder observation(Observation observation) {
        this.observation = Objects.requireNonNull(observation, "observation");
        initBits &= ~INIT_BIT_OBSERVATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalObservationValue InternalObservationValue}.
       * @return An immutable instance of InternalObservationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalObservationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalObservationValue(observation);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_OBSERVATION) != 0) attributes.add("observation");
        return "Cannot build InternalObservationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalAccountValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalAccountValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalAccountValue", generator = "Immutables")
  @Immutable
  static final class InternalAccountValue implements ResourceList.InternalAccountValue {
    private final Account account;

    private InternalAccountValue(Account account) {
      this.account = account;
    }

    /**
     * @return The value of the {@code account} attribute
     */
    @JsonProperty("account")
    @JsonValue
    @Override
    public Account account() {
      return account;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalAccountValue#account() account} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for account
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalAccountValue withAccount(Account value) {
      if (this.account == value) return this;
      Account newValue = Objects.requireNonNull(value, "account");
      return new ImmutableResourceList.InternalAccountValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalAccountValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalAccountValue
          && equalTo((ImmutableResourceList.InternalAccountValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalAccountValue another) {
      return account.equals(another.account);
    }

    /**
     * Computes a hash code from attributes: {@code account}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + account.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalAccountValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalAccountValue{"
          + "account=" + account
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalAccountValue fromJson(Account jsonValue) {
      ImmutableResourceList.InternalAccountValue.Builder builder = ImmutableResourceList.InternalAccountValue.builder();
      builder.account(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalAccountValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalAccountValue instance
     */
    public static ImmutableResourceList.InternalAccountValue copyOf(ResourceList.InternalAccountValue instance) {
      if (instance instanceof ImmutableResourceList.InternalAccountValue) {
        return (ImmutableResourceList.InternalAccountValue) instance;
      }
      return ImmutableResourceList.InternalAccountValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalAccountValue InternalAccountValue}.
     * <pre>
     * ImmutableResourceList.InternalAccountValue.builder()
     *    .account(com.fhir.types.fhir.Account) // required {@link ResourceList.InternalAccountValue#account() account}
     *    .build();
     * </pre>
     * @return A new InternalAccountValue builder
     */
    public static ImmutableResourceList.InternalAccountValue.Builder builder() {
      return new ImmutableResourceList.InternalAccountValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalAccountValue InternalAccountValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalAccountValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ACCOUNT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Account account;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalAccountValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalAccountValue instance) {
        Objects.requireNonNull(instance, "instance");
        account(instance.account());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalAccountValue#account() account} attribute.
       * @param account The value for account 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("account")
      public final Builder account(Account account) {
        this.account = Objects.requireNonNull(account, "account");
        initBits &= ~INIT_BIT_ACCOUNT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalAccountValue InternalAccountValue}.
       * @return An immutable instance of InternalAccountValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalAccountValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalAccountValue(account);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ACCOUNT) != 0) attributes.add("account");
        return "Cannot build InternalAccountValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalQuestionnaireResponseValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalQuestionnaireResponseValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalQuestionnaireResponseValue", generator = "Immutables")
  @Immutable
  static final class InternalQuestionnaireResponseValue
      implements ResourceList.InternalQuestionnaireResponseValue {
    private final QuestionnaireResponse questionnaireResponse;

    private InternalQuestionnaireResponseValue(QuestionnaireResponse questionnaireResponse) {
      this.questionnaireResponse = questionnaireResponse;
    }

    /**
     * @return The value of the {@code questionnaireResponse} attribute
     */
    @JsonProperty("questionnaireResponse")
    @JsonValue
    @Override
    public QuestionnaireResponse questionnaireResponse() {
      return questionnaireResponse;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalQuestionnaireResponseValue#questionnaireResponse() questionnaireResponse} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for questionnaireResponse
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalQuestionnaireResponseValue withQuestionnaireResponse(QuestionnaireResponse value) {
      if (this.questionnaireResponse == value) return this;
      QuestionnaireResponse newValue = Objects.requireNonNull(value, "questionnaireResponse");
      return new ImmutableResourceList.InternalQuestionnaireResponseValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalQuestionnaireResponseValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalQuestionnaireResponseValue
          && equalTo((ImmutableResourceList.InternalQuestionnaireResponseValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalQuestionnaireResponseValue another) {
      return questionnaireResponse.equals(another.questionnaireResponse);
    }

    /**
     * Computes a hash code from attributes: {@code questionnaireResponse}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + questionnaireResponse.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalQuestionnaireResponseValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalQuestionnaireResponseValue{"
          + "questionnaireResponse=" + questionnaireResponse
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalQuestionnaireResponseValue fromJson(QuestionnaireResponse jsonValue) {
      ImmutableResourceList.InternalQuestionnaireResponseValue.Builder builder = ImmutableResourceList.InternalQuestionnaireResponseValue.builder();
      builder.questionnaireResponse(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalQuestionnaireResponseValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalQuestionnaireResponseValue instance
     */
    public static ImmutableResourceList.InternalQuestionnaireResponseValue copyOf(ResourceList.InternalQuestionnaireResponseValue instance) {
      if (instance instanceof ImmutableResourceList.InternalQuestionnaireResponseValue) {
        return (ImmutableResourceList.InternalQuestionnaireResponseValue) instance;
      }
      return ImmutableResourceList.InternalQuestionnaireResponseValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalQuestionnaireResponseValue InternalQuestionnaireResponseValue}.
     * <pre>
     * ImmutableResourceList.InternalQuestionnaireResponseValue.builder()
     *    .questionnaireResponse(com.fhir.types.fhir.QuestionnaireResponse) // required {@link ResourceList.InternalQuestionnaireResponseValue#questionnaireResponse() questionnaireResponse}
     *    .build();
     * </pre>
     * @return A new InternalQuestionnaireResponseValue builder
     */
    public static ImmutableResourceList.InternalQuestionnaireResponseValue.Builder builder() {
      return new ImmutableResourceList.InternalQuestionnaireResponseValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalQuestionnaireResponseValue InternalQuestionnaireResponseValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalQuestionnaireResponseValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_QUESTIONNAIRE_RESPONSE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable QuestionnaireResponse questionnaireResponse;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalQuestionnaireResponseValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalQuestionnaireResponseValue instance) {
        Objects.requireNonNull(instance, "instance");
        questionnaireResponse(instance.questionnaireResponse());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalQuestionnaireResponseValue#questionnaireResponse() questionnaireResponse} attribute.
       * @param questionnaireResponse The value for questionnaireResponse 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("questionnaireResponse")
      public final Builder questionnaireResponse(QuestionnaireResponse questionnaireResponse) {
        this.questionnaireResponse = Objects.requireNonNull(questionnaireResponse, "questionnaireResponse");
        initBits &= ~INIT_BIT_QUESTIONNAIRE_RESPONSE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalQuestionnaireResponseValue InternalQuestionnaireResponseValue}.
       * @return An immutable instance of InternalQuestionnaireResponseValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalQuestionnaireResponseValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalQuestionnaireResponseValue(questionnaireResponse);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_QUESTIONNAIRE_RESPONSE) != 0) attributes.add("questionnaireResponse");
        return "Cannot build InternalQuestionnaireResponseValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalTerminologyCapabilitiesValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalTerminologyCapabilitiesValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalTerminologyCapabilitiesValue", generator = "Immutables")
  @Immutable
  static final class InternalTerminologyCapabilitiesValue
      implements ResourceList.InternalTerminologyCapabilitiesValue {
    private final TerminologyCapabilities terminologyCapabilities;

    private InternalTerminologyCapabilitiesValue(TerminologyCapabilities terminologyCapabilities) {
      this.terminologyCapabilities = terminologyCapabilities;
    }

    /**
     * @return The value of the {@code terminologyCapabilities} attribute
     */
    @JsonProperty("terminologyCapabilities")
    @JsonValue
    @Override
    public TerminologyCapabilities terminologyCapabilities() {
      return terminologyCapabilities;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalTerminologyCapabilitiesValue#terminologyCapabilities() terminologyCapabilities} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for terminologyCapabilities
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalTerminologyCapabilitiesValue withTerminologyCapabilities(TerminologyCapabilities value) {
      if (this.terminologyCapabilities == value) return this;
      TerminologyCapabilities newValue = Objects.requireNonNull(value, "terminologyCapabilities");
      return new ImmutableResourceList.InternalTerminologyCapabilitiesValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalTerminologyCapabilitiesValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalTerminologyCapabilitiesValue
          && equalTo((ImmutableResourceList.InternalTerminologyCapabilitiesValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalTerminologyCapabilitiesValue another) {
      return terminologyCapabilities.equals(another.terminologyCapabilities);
    }

    /**
     * Computes a hash code from attributes: {@code terminologyCapabilities}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + terminologyCapabilities.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalTerminologyCapabilitiesValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalTerminologyCapabilitiesValue{"
          + "terminologyCapabilities=" + terminologyCapabilities
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalTerminologyCapabilitiesValue fromJson(TerminologyCapabilities jsonValue) {
      ImmutableResourceList.InternalTerminologyCapabilitiesValue.Builder builder = ImmutableResourceList.InternalTerminologyCapabilitiesValue.builder();
      builder.terminologyCapabilities(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalTerminologyCapabilitiesValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalTerminologyCapabilitiesValue instance
     */
    public static ImmutableResourceList.InternalTerminologyCapabilitiesValue copyOf(ResourceList.InternalTerminologyCapabilitiesValue instance) {
      if (instance instanceof ImmutableResourceList.InternalTerminologyCapabilitiesValue) {
        return (ImmutableResourceList.InternalTerminologyCapabilitiesValue) instance;
      }
      return ImmutableResourceList.InternalTerminologyCapabilitiesValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalTerminologyCapabilitiesValue InternalTerminologyCapabilitiesValue}.
     * <pre>
     * ImmutableResourceList.InternalTerminologyCapabilitiesValue.builder()
     *    .terminologyCapabilities(com.fhir.types.fhir.TerminologyCapabilities) // required {@link ResourceList.InternalTerminologyCapabilitiesValue#terminologyCapabilities() terminologyCapabilities}
     *    .build();
     * </pre>
     * @return A new InternalTerminologyCapabilitiesValue builder
     */
    public static ImmutableResourceList.InternalTerminologyCapabilitiesValue.Builder builder() {
      return new ImmutableResourceList.InternalTerminologyCapabilitiesValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalTerminologyCapabilitiesValue InternalTerminologyCapabilitiesValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalTerminologyCapabilitiesValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_TERMINOLOGY_CAPABILITIES = 0x1L;
      private long initBits = 0x1L;

      private @Nullable TerminologyCapabilities terminologyCapabilities;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalTerminologyCapabilitiesValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalTerminologyCapabilitiesValue instance) {
        Objects.requireNonNull(instance, "instance");
        terminologyCapabilities(instance.terminologyCapabilities());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalTerminologyCapabilitiesValue#terminologyCapabilities() terminologyCapabilities} attribute.
       * @param terminologyCapabilities The value for terminologyCapabilities 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("terminologyCapabilities")
      public final Builder terminologyCapabilities(TerminologyCapabilities terminologyCapabilities) {
        this.terminologyCapabilities = Objects.requireNonNull(terminologyCapabilities, "terminologyCapabilities");
        initBits &= ~INIT_BIT_TERMINOLOGY_CAPABILITIES;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalTerminologyCapabilitiesValue InternalTerminologyCapabilitiesValue}.
       * @return An immutable instance of InternalTerminologyCapabilitiesValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalTerminologyCapabilitiesValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalTerminologyCapabilitiesValue(terminologyCapabilities);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_TERMINOLOGY_CAPABILITIES) != 0) attributes.add("terminologyCapabilities");
        return "Cannot build InternalTerminologyCapabilitiesValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalUserConfigurationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalUserConfigurationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalUserConfigurationValue", generator = "Immutables")
  @Immutable
  static final class InternalUserConfigurationValue
      implements ResourceList.InternalUserConfigurationValue {
    private final UserConfiguration userConfiguration;

    private InternalUserConfigurationValue(UserConfiguration userConfiguration) {
      this.userConfiguration = userConfiguration;
    }

    /**
     * @return The value of the {@code userConfiguration} attribute
     */
    @JsonProperty("userConfiguration")
    @JsonValue
    @Override
    public UserConfiguration userConfiguration() {
      return userConfiguration;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalUserConfigurationValue#userConfiguration() userConfiguration} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for userConfiguration
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalUserConfigurationValue withUserConfiguration(UserConfiguration value) {
      if (this.userConfiguration == value) return this;
      UserConfiguration newValue = Objects.requireNonNull(value, "userConfiguration");
      return new ImmutableResourceList.InternalUserConfigurationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalUserConfigurationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalUserConfigurationValue
          && equalTo((ImmutableResourceList.InternalUserConfigurationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalUserConfigurationValue another) {
      return userConfiguration.equals(another.userConfiguration);
    }

    /**
     * Computes a hash code from attributes: {@code userConfiguration}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + userConfiguration.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalUserConfigurationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalUserConfigurationValue{"
          + "userConfiguration=" + userConfiguration
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalUserConfigurationValue fromJson(UserConfiguration jsonValue) {
      ImmutableResourceList.InternalUserConfigurationValue.Builder builder = ImmutableResourceList.InternalUserConfigurationValue.builder();
      builder.userConfiguration(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalUserConfigurationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalUserConfigurationValue instance
     */
    public static ImmutableResourceList.InternalUserConfigurationValue copyOf(ResourceList.InternalUserConfigurationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalUserConfigurationValue) {
        return (ImmutableResourceList.InternalUserConfigurationValue) instance;
      }
      return ImmutableResourceList.InternalUserConfigurationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalUserConfigurationValue InternalUserConfigurationValue}.
     * <pre>
     * ImmutableResourceList.InternalUserConfigurationValue.builder()
     *    .userConfiguration(com.fhir.types.fhir.UserConfiguration) // required {@link ResourceList.InternalUserConfigurationValue#userConfiguration() userConfiguration}
     *    .build();
     * </pre>
     * @return A new InternalUserConfigurationValue builder
     */
    public static ImmutableResourceList.InternalUserConfigurationValue.Builder builder() {
      return new ImmutableResourceList.InternalUserConfigurationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalUserConfigurationValue InternalUserConfigurationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalUserConfigurationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_USER_CONFIGURATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable UserConfiguration userConfiguration;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalUserConfigurationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalUserConfigurationValue instance) {
        Objects.requireNonNull(instance, "instance");
        userConfiguration(instance.userConfiguration());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalUserConfigurationValue#userConfiguration() userConfiguration} attribute.
       * @param userConfiguration The value for userConfiguration 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("userConfiguration")
      public final Builder userConfiguration(UserConfiguration userConfiguration) {
        this.userConfiguration = Objects.requireNonNull(userConfiguration, "userConfiguration");
        initBits &= ~INIT_BIT_USER_CONFIGURATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalUserConfigurationValue InternalUserConfigurationValue}.
       * @return An immutable instance of InternalUserConfigurationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalUserConfigurationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalUserConfigurationValue(userConfiguration);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_USER_CONFIGURATION) != 0) attributes.add("userConfiguration");
        return "Cannot build InternalUserConfigurationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalProjectValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalProjectValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalProjectValue", generator = "Immutables")
  @Immutable
  static final class InternalProjectValue implements ResourceList.InternalProjectValue {
    private final Project project;

    private InternalProjectValue(Project project) {
      this.project = project;
    }

    /**
     * @return The value of the {@code project} attribute
     */
    @JsonProperty("project")
    @JsonValue
    @Override
    public Project project() {
      return project;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalProjectValue#project() project} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for project
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalProjectValue withProject(Project value) {
      if (this.project == value) return this;
      Project newValue = Objects.requireNonNull(value, "project");
      return new ImmutableResourceList.InternalProjectValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalProjectValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalProjectValue
          && equalTo((ImmutableResourceList.InternalProjectValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalProjectValue another) {
      return project.equals(another.project);
    }

    /**
     * Computes a hash code from attributes: {@code project}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + project.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalProjectValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalProjectValue{"
          + "project=" + project
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalProjectValue fromJson(Project jsonValue) {
      ImmutableResourceList.InternalProjectValue.Builder builder = ImmutableResourceList.InternalProjectValue.builder();
      builder.project(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalProjectValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalProjectValue instance
     */
    public static ImmutableResourceList.InternalProjectValue copyOf(ResourceList.InternalProjectValue instance) {
      if (instance instanceof ImmutableResourceList.InternalProjectValue) {
        return (ImmutableResourceList.InternalProjectValue) instance;
      }
      return ImmutableResourceList.InternalProjectValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalProjectValue InternalProjectValue}.
     * <pre>
     * ImmutableResourceList.InternalProjectValue.builder()
     *    .project(com.fhir.types.fhir.Project) // required {@link ResourceList.InternalProjectValue#project() project}
     *    .build();
     * </pre>
     * @return A new InternalProjectValue builder
     */
    public static ImmutableResourceList.InternalProjectValue.Builder builder() {
      return new ImmutableResourceList.InternalProjectValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalProjectValue InternalProjectValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalProjectValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_PROJECT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Project project;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalProjectValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalProjectValue instance) {
        Objects.requireNonNull(instance, "instance");
        project(instance.project());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalProjectValue#project() project} attribute.
       * @param project The value for project 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("project")
      public final Builder project(Project project) {
        this.project = Objects.requireNonNull(project, "project");
        initBits &= ~INIT_BIT_PROJECT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalProjectValue InternalProjectValue}.
       * @return An immutable instance of InternalProjectValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalProjectValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalProjectValue(project);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_PROJECT) != 0) attributes.add("project");
        return "Cannot build InternalProjectValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalConceptMapValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalConceptMapValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalConceptMapValue", generator = "Immutables")
  @Immutable
  static final class InternalConceptMapValue
      implements ResourceList.InternalConceptMapValue {
    private final ConceptMap conceptMap;

    private InternalConceptMapValue(ConceptMap conceptMap) {
      this.conceptMap = conceptMap;
    }

    /**
     * @return The value of the {@code conceptMap} attribute
     */
    @JsonProperty("conceptMap")
    @JsonValue
    @Override
    public ConceptMap conceptMap() {
      return conceptMap;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalConceptMapValue#conceptMap() conceptMap} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for conceptMap
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalConceptMapValue withConceptMap(ConceptMap value) {
      if (this.conceptMap == value) return this;
      ConceptMap newValue = Objects.requireNonNull(value, "conceptMap");
      return new ImmutableResourceList.InternalConceptMapValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalConceptMapValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalConceptMapValue
          && equalTo((ImmutableResourceList.InternalConceptMapValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalConceptMapValue another) {
      return conceptMap.equals(another.conceptMap);
    }

    /**
     * Computes a hash code from attributes: {@code conceptMap}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + conceptMap.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalConceptMapValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalConceptMapValue{"
          + "conceptMap=" + conceptMap
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalConceptMapValue fromJson(ConceptMap jsonValue) {
      ImmutableResourceList.InternalConceptMapValue.Builder builder = ImmutableResourceList.InternalConceptMapValue.builder();
      builder.conceptMap(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalConceptMapValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalConceptMapValue instance
     */
    public static ImmutableResourceList.InternalConceptMapValue copyOf(ResourceList.InternalConceptMapValue instance) {
      if (instance instanceof ImmutableResourceList.InternalConceptMapValue) {
        return (ImmutableResourceList.InternalConceptMapValue) instance;
      }
      return ImmutableResourceList.InternalConceptMapValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalConceptMapValue InternalConceptMapValue}.
     * <pre>
     * ImmutableResourceList.InternalConceptMapValue.builder()
     *    .conceptMap(com.fhir.types.fhir.ConceptMap) // required {@link ResourceList.InternalConceptMapValue#conceptMap() conceptMap}
     *    .build();
     * </pre>
     * @return A new InternalConceptMapValue builder
     */
    public static ImmutableResourceList.InternalConceptMapValue.Builder builder() {
      return new ImmutableResourceList.InternalConceptMapValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalConceptMapValue InternalConceptMapValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalConceptMapValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CONCEPT_MAP = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ConceptMap conceptMap;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalConceptMapValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalConceptMapValue instance) {
        Objects.requireNonNull(instance, "instance");
        conceptMap(instance.conceptMap());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalConceptMapValue#conceptMap() conceptMap} attribute.
       * @param conceptMap The value for conceptMap 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("conceptMap")
      public final Builder conceptMap(ConceptMap conceptMap) {
        this.conceptMap = Objects.requireNonNull(conceptMap, "conceptMap");
        initBits &= ~INIT_BIT_CONCEPT_MAP;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalConceptMapValue InternalConceptMapValue}.
       * @return An immutable instance of InternalConceptMapValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalConceptMapValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalConceptMapValue(conceptMap);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CONCEPT_MAP) != 0) attributes.add("conceptMap");
        return "Cannot build InternalConceptMapValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalLocationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalLocationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalLocationValue", generator = "Immutables")
  @Immutable
  static final class InternalLocationValue implements ResourceList.InternalLocationValue {
    private final Location location;

    private InternalLocationValue(Location location) {
      this.location = location;
    }

    /**
     * @return The value of the {@code location} attribute
     */
    @JsonProperty("location")
    @JsonValue
    @Override
    public Location location() {
      return location;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalLocationValue#location() location} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for location
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalLocationValue withLocation(Location value) {
      if (this.location == value) return this;
      Location newValue = Objects.requireNonNull(value, "location");
      return new ImmutableResourceList.InternalLocationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalLocationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalLocationValue
          && equalTo((ImmutableResourceList.InternalLocationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalLocationValue another) {
      return location.equals(another.location);
    }

    /**
     * Computes a hash code from attributes: {@code location}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + location.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalLocationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalLocationValue{"
          + "location=" + location
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalLocationValue fromJson(Location jsonValue) {
      ImmutableResourceList.InternalLocationValue.Builder builder = ImmutableResourceList.InternalLocationValue.builder();
      builder.location(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalLocationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalLocationValue instance
     */
    public static ImmutableResourceList.InternalLocationValue copyOf(ResourceList.InternalLocationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalLocationValue) {
        return (ImmutableResourceList.InternalLocationValue) instance;
      }
      return ImmutableResourceList.InternalLocationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalLocationValue InternalLocationValue}.
     * <pre>
     * ImmutableResourceList.InternalLocationValue.builder()
     *    .location(com.fhir.types.fhir.Location) // required {@link ResourceList.InternalLocationValue#location() location}
     *    .build();
     * </pre>
     * @return A new InternalLocationValue builder
     */
    public static ImmutableResourceList.InternalLocationValue.Builder builder() {
      return new ImmutableResourceList.InternalLocationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalLocationValue InternalLocationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalLocationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_LOCATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Location location;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalLocationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalLocationValue instance) {
        Objects.requireNonNull(instance, "instance");
        location(instance.location());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalLocationValue#location() location} attribute.
       * @param location The value for location 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("location")
      public final Builder location(Location location) {
        this.location = Objects.requireNonNull(location, "location");
        initBits &= ~INIT_BIT_LOCATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalLocationValue InternalLocationValue}.
       * @return An immutable instance of InternalLocationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalLocationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalLocationValue(location);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_LOCATION) != 0) attributes.add("location");
        return "Cannot build InternalLocationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalEpisodeOfCareValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalEpisodeOfCareValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalEpisodeOfCareValue", generator = "Immutables")
  @Immutable
  static final class InternalEpisodeOfCareValue
      implements ResourceList.InternalEpisodeOfCareValue {
    private final EpisodeOfCare episodeOfCare;

    private InternalEpisodeOfCareValue(EpisodeOfCare episodeOfCare) {
      this.episodeOfCare = episodeOfCare;
    }

    /**
     * @return The value of the {@code episodeOfCare} attribute
     */
    @JsonProperty("episodeOfCare")
    @JsonValue
    @Override
    public EpisodeOfCare episodeOfCare() {
      return episodeOfCare;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalEpisodeOfCareValue#episodeOfCare() episodeOfCare} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for episodeOfCare
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalEpisodeOfCareValue withEpisodeOfCare(EpisodeOfCare value) {
      if (this.episodeOfCare == value) return this;
      EpisodeOfCare newValue = Objects.requireNonNull(value, "episodeOfCare");
      return new ImmutableResourceList.InternalEpisodeOfCareValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalEpisodeOfCareValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalEpisodeOfCareValue
          && equalTo((ImmutableResourceList.InternalEpisodeOfCareValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalEpisodeOfCareValue another) {
      return episodeOfCare.equals(another.episodeOfCare);
    }

    /**
     * Computes a hash code from attributes: {@code episodeOfCare}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + episodeOfCare.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalEpisodeOfCareValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalEpisodeOfCareValue{"
          + "episodeOfCare=" + episodeOfCare
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalEpisodeOfCareValue fromJson(EpisodeOfCare jsonValue) {
      ImmutableResourceList.InternalEpisodeOfCareValue.Builder builder = ImmutableResourceList.InternalEpisodeOfCareValue.builder();
      builder.episodeOfCare(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalEpisodeOfCareValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalEpisodeOfCareValue instance
     */
    public static ImmutableResourceList.InternalEpisodeOfCareValue copyOf(ResourceList.InternalEpisodeOfCareValue instance) {
      if (instance instanceof ImmutableResourceList.InternalEpisodeOfCareValue) {
        return (ImmutableResourceList.InternalEpisodeOfCareValue) instance;
      }
      return ImmutableResourceList.InternalEpisodeOfCareValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalEpisodeOfCareValue InternalEpisodeOfCareValue}.
     * <pre>
     * ImmutableResourceList.InternalEpisodeOfCareValue.builder()
     *    .episodeOfCare(com.fhir.types.fhir.EpisodeOfCare) // required {@link ResourceList.InternalEpisodeOfCareValue#episodeOfCare() episodeOfCare}
     *    .build();
     * </pre>
     * @return A new InternalEpisodeOfCareValue builder
     */
    public static ImmutableResourceList.InternalEpisodeOfCareValue.Builder builder() {
      return new ImmutableResourceList.InternalEpisodeOfCareValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalEpisodeOfCareValue InternalEpisodeOfCareValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalEpisodeOfCareValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_EPISODE_OF_CARE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable EpisodeOfCare episodeOfCare;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalEpisodeOfCareValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalEpisodeOfCareValue instance) {
        Objects.requireNonNull(instance, "instance");
        episodeOfCare(instance.episodeOfCare());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalEpisodeOfCareValue#episodeOfCare() episodeOfCare} attribute.
       * @param episodeOfCare The value for episodeOfCare 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("episodeOfCare")
      public final Builder episodeOfCare(EpisodeOfCare episodeOfCare) {
        this.episodeOfCare = Objects.requireNonNull(episodeOfCare, "episodeOfCare");
        initBits &= ~INIT_BIT_EPISODE_OF_CARE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalEpisodeOfCareValue InternalEpisodeOfCareValue}.
       * @return An immutable instance of InternalEpisodeOfCareValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalEpisodeOfCareValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalEpisodeOfCareValue(episodeOfCare);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_EPISODE_OF_CARE) != 0) attributes.add("episodeOfCare");
        return "Cannot build InternalEpisodeOfCareValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalGoalValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalGoalValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalGoalValue", generator = "Immutables")
  @Immutable
  static final class InternalGoalValue implements ResourceList.InternalGoalValue {
    private final Goal goal;

    private InternalGoalValue(Goal goal) {
      this.goal = goal;
    }

    /**
     * @return The value of the {@code goal} attribute
     */
    @JsonProperty("goal")
    @JsonValue
    @Override
    public Goal goal() {
      return goal;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalGoalValue#goal() goal} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for goal
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalGoalValue withGoal(Goal value) {
      if (this.goal == value) return this;
      Goal newValue = Objects.requireNonNull(value, "goal");
      return new ImmutableResourceList.InternalGoalValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalGoalValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalGoalValue
          && equalTo((ImmutableResourceList.InternalGoalValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalGoalValue another) {
      return goal.equals(another.goal);
    }

    /**
     * Computes a hash code from attributes: {@code goal}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + goal.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalGoalValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalGoalValue{"
          + "goal=" + goal
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalGoalValue fromJson(Goal jsonValue) {
      ImmutableResourceList.InternalGoalValue.Builder builder = ImmutableResourceList.InternalGoalValue.builder();
      builder.goal(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalGoalValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalGoalValue instance
     */
    public static ImmutableResourceList.InternalGoalValue copyOf(ResourceList.InternalGoalValue instance) {
      if (instance instanceof ImmutableResourceList.InternalGoalValue) {
        return (ImmutableResourceList.InternalGoalValue) instance;
      }
      return ImmutableResourceList.InternalGoalValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalGoalValue InternalGoalValue}.
     * <pre>
     * ImmutableResourceList.InternalGoalValue.builder()
     *    .goal(com.fhir.types.fhir.Goal) // required {@link ResourceList.InternalGoalValue#goal() goal}
     *    .build();
     * </pre>
     * @return A new InternalGoalValue builder
     */
    public static ImmutableResourceList.InternalGoalValue.Builder builder() {
      return new ImmutableResourceList.InternalGoalValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalGoalValue InternalGoalValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalGoalValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_GOAL = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Goal goal;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalGoalValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalGoalValue instance) {
        Objects.requireNonNull(instance, "instance");
        goal(instance.goal());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalGoalValue#goal() goal} attribute.
       * @param goal The value for goal 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("goal")
      public final Builder goal(Goal goal) {
        this.goal = Objects.requireNonNull(goal, "goal");
        initBits &= ~INIT_BIT_GOAL;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalGoalValue InternalGoalValue}.
       * @return An immutable instance of InternalGoalValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalGoalValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalGoalValue(goal);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_GOAL) != 0) attributes.add("goal");
        return "Cannot build InternalGoalValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalEventDefinitionValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalEventDefinitionValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalEventDefinitionValue", generator = "Immutables")
  @Immutable
  static final class InternalEventDefinitionValue
      implements ResourceList.InternalEventDefinitionValue {
    private final EventDefinition eventDefinition;

    private InternalEventDefinitionValue(EventDefinition eventDefinition) {
      this.eventDefinition = eventDefinition;
    }

    /**
     * @return The value of the {@code eventDefinition} attribute
     */
    @JsonProperty("eventDefinition")
    @JsonValue
    @Override
    public EventDefinition eventDefinition() {
      return eventDefinition;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalEventDefinitionValue#eventDefinition() eventDefinition} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for eventDefinition
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalEventDefinitionValue withEventDefinition(EventDefinition value) {
      if (this.eventDefinition == value) return this;
      EventDefinition newValue = Objects.requireNonNull(value, "eventDefinition");
      return new ImmutableResourceList.InternalEventDefinitionValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalEventDefinitionValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalEventDefinitionValue
          && equalTo((ImmutableResourceList.InternalEventDefinitionValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalEventDefinitionValue another) {
      return eventDefinition.equals(another.eventDefinition);
    }

    /**
     * Computes a hash code from attributes: {@code eventDefinition}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + eventDefinition.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalEventDefinitionValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalEventDefinitionValue{"
          + "eventDefinition=" + eventDefinition
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalEventDefinitionValue fromJson(EventDefinition jsonValue) {
      ImmutableResourceList.InternalEventDefinitionValue.Builder builder = ImmutableResourceList.InternalEventDefinitionValue.builder();
      builder.eventDefinition(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalEventDefinitionValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalEventDefinitionValue instance
     */
    public static ImmutableResourceList.InternalEventDefinitionValue copyOf(ResourceList.InternalEventDefinitionValue instance) {
      if (instance instanceof ImmutableResourceList.InternalEventDefinitionValue) {
        return (ImmutableResourceList.InternalEventDefinitionValue) instance;
      }
      return ImmutableResourceList.InternalEventDefinitionValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalEventDefinitionValue InternalEventDefinitionValue}.
     * <pre>
     * ImmutableResourceList.InternalEventDefinitionValue.builder()
     *    .eventDefinition(com.fhir.types.fhir.EventDefinition) // required {@link ResourceList.InternalEventDefinitionValue#eventDefinition() eventDefinition}
     *    .build();
     * </pre>
     * @return A new InternalEventDefinitionValue builder
     */
    public static ImmutableResourceList.InternalEventDefinitionValue.Builder builder() {
      return new ImmutableResourceList.InternalEventDefinitionValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalEventDefinitionValue InternalEventDefinitionValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalEventDefinitionValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_EVENT_DEFINITION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable EventDefinition eventDefinition;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalEventDefinitionValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalEventDefinitionValue instance) {
        Objects.requireNonNull(instance, "instance");
        eventDefinition(instance.eventDefinition());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalEventDefinitionValue#eventDefinition() eventDefinition} attribute.
       * @param eventDefinition The value for eventDefinition 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("eventDefinition")
      public final Builder eventDefinition(EventDefinition eventDefinition) {
        this.eventDefinition = Objects.requireNonNull(eventDefinition, "eventDefinition");
        initBits &= ~INIT_BIT_EVENT_DEFINITION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalEventDefinitionValue InternalEventDefinitionValue}.
       * @return An immutable instance of InternalEventDefinitionValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalEventDefinitionValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalEventDefinitionValue(eventDefinition);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_EVENT_DEFINITION) != 0) attributes.add("eventDefinition");
        return "Cannot build InternalEventDefinitionValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalVerificationResultValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalVerificationResultValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalVerificationResultValue", generator = "Immutables")
  @Immutable
  static final class InternalVerificationResultValue
      implements ResourceList.InternalVerificationResultValue {
    private final VerificationResult verificationResult;

    private InternalVerificationResultValue(VerificationResult verificationResult) {
      this.verificationResult = verificationResult;
    }

    /**
     * @return The value of the {@code verificationResult} attribute
     */
    @JsonProperty("verificationResult")
    @JsonValue
    @Override
    public VerificationResult verificationResult() {
      return verificationResult;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalVerificationResultValue#verificationResult() verificationResult} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for verificationResult
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalVerificationResultValue withVerificationResult(VerificationResult value) {
      if (this.verificationResult == value) return this;
      VerificationResult newValue = Objects.requireNonNull(value, "verificationResult");
      return new ImmutableResourceList.InternalVerificationResultValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalVerificationResultValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalVerificationResultValue
          && equalTo((ImmutableResourceList.InternalVerificationResultValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalVerificationResultValue another) {
      return verificationResult.equals(another.verificationResult);
    }

    /**
     * Computes a hash code from attributes: {@code verificationResult}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + verificationResult.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalVerificationResultValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalVerificationResultValue{"
          + "verificationResult=" + verificationResult
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalVerificationResultValue fromJson(VerificationResult jsonValue) {
      ImmutableResourceList.InternalVerificationResultValue.Builder builder = ImmutableResourceList.InternalVerificationResultValue.builder();
      builder.verificationResult(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalVerificationResultValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalVerificationResultValue instance
     */
    public static ImmutableResourceList.InternalVerificationResultValue copyOf(ResourceList.InternalVerificationResultValue instance) {
      if (instance instanceof ImmutableResourceList.InternalVerificationResultValue) {
        return (ImmutableResourceList.InternalVerificationResultValue) instance;
      }
      return ImmutableResourceList.InternalVerificationResultValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalVerificationResultValue InternalVerificationResultValue}.
     * <pre>
     * ImmutableResourceList.InternalVerificationResultValue.builder()
     *    .verificationResult(com.fhir.types.fhir.VerificationResult) // required {@link ResourceList.InternalVerificationResultValue#verificationResult() verificationResult}
     *    .build();
     * </pre>
     * @return A new InternalVerificationResultValue builder
     */
    public static ImmutableResourceList.InternalVerificationResultValue.Builder builder() {
      return new ImmutableResourceList.InternalVerificationResultValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalVerificationResultValue InternalVerificationResultValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalVerificationResultValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_VERIFICATION_RESULT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable VerificationResult verificationResult;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalVerificationResultValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalVerificationResultValue instance) {
        Objects.requireNonNull(instance, "instance");
        verificationResult(instance.verificationResult());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalVerificationResultValue#verificationResult() verificationResult} attribute.
       * @param verificationResult The value for verificationResult 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("verificationResult")
      public final Builder verificationResult(VerificationResult verificationResult) {
        this.verificationResult = Objects.requireNonNull(verificationResult, "verificationResult");
        initBits &= ~INIT_BIT_VERIFICATION_RESULT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalVerificationResultValue InternalVerificationResultValue}.
       * @return An immutable instance of InternalVerificationResultValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalVerificationResultValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalVerificationResultValue(verificationResult);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_VERIFICATION_RESULT) != 0) attributes.add("verificationResult");
        return "Cannot build InternalVerificationResultValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalValueSetValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalValueSetValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalValueSetValue", generator = "Immutables")
  @Immutable
  static final class InternalValueSetValue implements ResourceList.InternalValueSetValue {
    private final ValueSet valueSet;

    private InternalValueSetValue(ValueSet valueSet) {
      this.valueSet = valueSet;
    }

    /**
     * @return The value of the {@code valueSet} attribute
     */
    @JsonProperty("valueSet")
    @JsonValue
    @Override
    public ValueSet valueSet() {
      return valueSet;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalValueSetValue#valueSet() valueSet} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for valueSet
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalValueSetValue withValueSet(ValueSet value) {
      if (this.valueSet == value) return this;
      ValueSet newValue = Objects.requireNonNull(value, "valueSet");
      return new ImmutableResourceList.InternalValueSetValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalValueSetValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalValueSetValue
          && equalTo((ImmutableResourceList.InternalValueSetValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalValueSetValue another) {
      return valueSet.equals(another.valueSet);
    }

    /**
     * Computes a hash code from attributes: {@code valueSet}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + valueSet.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalValueSetValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalValueSetValue{"
          + "valueSet=" + valueSet
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalValueSetValue fromJson(ValueSet jsonValue) {
      ImmutableResourceList.InternalValueSetValue.Builder builder = ImmutableResourceList.InternalValueSetValue.builder();
      builder.valueSet(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalValueSetValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalValueSetValue instance
     */
    public static ImmutableResourceList.InternalValueSetValue copyOf(ResourceList.InternalValueSetValue instance) {
      if (instance instanceof ImmutableResourceList.InternalValueSetValue) {
        return (ImmutableResourceList.InternalValueSetValue) instance;
      }
      return ImmutableResourceList.InternalValueSetValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalValueSetValue InternalValueSetValue}.
     * <pre>
     * ImmutableResourceList.InternalValueSetValue.builder()
     *    .valueSet(com.fhir.types.fhir.ValueSet) // required {@link ResourceList.InternalValueSetValue#valueSet() valueSet}
     *    .build();
     * </pre>
     * @return A new InternalValueSetValue builder
     */
    public static ImmutableResourceList.InternalValueSetValue.Builder builder() {
      return new ImmutableResourceList.InternalValueSetValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalValueSetValue InternalValueSetValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalValueSetValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_VALUE_SET = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ValueSet valueSet;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalValueSetValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalValueSetValue instance) {
        Objects.requireNonNull(instance, "instance");
        valueSet(instance.valueSet());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalValueSetValue#valueSet() valueSet} attribute.
       * @param valueSet The value for valueSet 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("valueSet")
      public final Builder valueSet(ValueSet valueSet) {
        this.valueSet = Objects.requireNonNull(valueSet, "valueSet");
        initBits &= ~INIT_BIT_VALUE_SET;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalValueSetValue InternalValueSetValue}.
       * @return An immutable instance of InternalValueSetValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalValueSetValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalValueSetValue(valueSet);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_VALUE_SET) != 0) attributes.add("valueSet");
        return "Cannot build InternalValueSetValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSubstanceSpecificationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSubstanceSpecificationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSubstanceSpecificationValue", generator = "Immutables")
  @Immutable
  static final class InternalSubstanceSpecificationValue
      implements ResourceList.InternalSubstanceSpecificationValue {
    private final SubstanceSpecification substanceSpecification;

    private InternalSubstanceSpecificationValue(SubstanceSpecification substanceSpecification) {
      this.substanceSpecification = substanceSpecification;
    }

    /**
     * @return The value of the {@code substanceSpecification} attribute
     */
    @JsonProperty("substanceSpecification")
    @JsonValue
    @Override
    public SubstanceSpecification substanceSpecification() {
      return substanceSpecification;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSubstanceSpecificationValue#substanceSpecification() substanceSpecification} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for substanceSpecification
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSubstanceSpecificationValue withSubstanceSpecification(SubstanceSpecification value) {
      if (this.substanceSpecification == value) return this;
      SubstanceSpecification newValue = Objects.requireNonNull(value, "substanceSpecification");
      return new ImmutableResourceList.InternalSubstanceSpecificationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSubstanceSpecificationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSubstanceSpecificationValue
          && equalTo((ImmutableResourceList.InternalSubstanceSpecificationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSubstanceSpecificationValue another) {
      return substanceSpecification.equals(another.substanceSpecification);
    }

    /**
     * Computes a hash code from attributes: {@code substanceSpecification}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + substanceSpecification.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSubstanceSpecificationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSubstanceSpecificationValue{"
          + "substanceSpecification=" + substanceSpecification
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSubstanceSpecificationValue fromJson(SubstanceSpecification jsonValue) {
      ImmutableResourceList.InternalSubstanceSpecificationValue.Builder builder = ImmutableResourceList.InternalSubstanceSpecificationValue.builder();
      builder.substanceSpecification(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSubstanceSpecificationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSubstanceSpecificationValue instance
     */
    public static ImmutableResourceList.InternalSubstanceSpecificationValue copyOf(ResourceList.InternalSubstanceSpecificationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSubstanceSpecificationValue) {
        return (ImmutableResourceList.InternalSubstanceSpecificationValue) instance;
      }
      return ImmutableResourceList.InternalSubstanceSpecificationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSubstanceSpecificationValue InternalSubstanceSpecificationValue}.
     * <pre>
     * ImmutableResourceList.InternalSubstanceSpecificationValue.builder()
     *    .substanceSpecification(com.fhir.types.fhir.SubstanceSpecification) // required {@link ResourceList.InternalSubstanceSpecificationValue#substanceSpecification() substanceSpecification}
     *    .build();
     * </pre>
     * @return A new InternalSubstanceSpecificationValue builder
     */
    public static ImmutableResourceList.InternalSubstanceSpecificationValue.Builder builder() {
      return new ImmutableResourceList.InternalSubstanceSpecificationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSubstanceSpecificationValue InternalSubstanceSpecificationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSubstanceSpecificationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUBSTANCE_SPECIFICATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SubstanceSpecification substanceSpecification;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSubstanceSpecificationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSubstanceSpecificationValue instance) {
        Objects.requireNonNull(instance, "instance");
        substanceSpecification(instance.substanceSpecification());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSubstanceSpecificationValue#substanceSpecification() substanceSpecification} attribute.
       * @param substanceSpecification The value for substanceSpecification 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("substanceSpecification")
      public final Builder substanceSpecification(SubstanceSpecification substanceSpecification) {
        this.substanceSpecification = Objects.requireNonNull(substanceSpecification, "substanceSpecification");
        initBits &= ~INIT_BIT_SUBSTANCE_SPECIFICATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSubstanceSpecificationValue InternalSubstanceSpecificationValue}.
       * @return An immutable instance of InternalSubstanceSpecificationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSubstanceSpecificationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSubstanceSpecificationValue(substanceSpecification);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUBSTANCE_SPECIFICATION) != 0) attributes.add("substanceSpecification");
        return "Cannot build InternalSubstanceSpecificationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSubstancePolymerValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSubstancePolymerValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSubstancePolymerValue", generator = "Immutables")
  @Immutable
  static final class InternalSubstancePolymerValue
      implements ResourceList.InternalSubstancePolymerValue {
    private final SubstancePolymer substancePolymer;

    private InternalSubstancePolymerValue(SubstancePolymer substancePolymer) {
      this.substancePolymer = substancePolymer;
    }

    /**
     * @return The value of the {@code substancePolymer} attribute
     */
    @JsonProperty("substancePolymer")
    @JsonValue
    @Override
    public SubstancePolymer substancePolymer() {
      return substancePolymer;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSubstancePolymerValue#substancePolymer() substancePolymer} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for substancePolymer
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSubstancePolymerValue withSubstancePolymer(SubstancePolymer value) {
      if (this.substancePolymer == value) return this;
      SubstancePolymer newValue = Objects.requireNonNull(value, "substancePolymer");
      return new ImmutableResourceList.InternalSubstancePolymerValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSubstancePolymerValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSubstancePolymerValue
          && equalTo((ImmutableResourceList.InternalSubstancePolymerValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSubstancePolymerValue another) {
      return substancePolymer.equals(another.substancePolymer);
    }

    /**
     * Computes a hash code from attributes: {@code substancePolymer}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + substancePolymer.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSubstancePolymerValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSubstancePolymerValue{"
          + "substancePolymer=" + substancePolymer
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSubstancePolymerValue fromJson(SubstancePolymer jsonValue) {
      ImmutableResourceList.InternalSubstancePolymerValue.Builder builder = ImmutableResourceList.InternalSubstancePolymerValue.builder();
      builder.substancePolymer(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSubstancePolymerValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSubstancePolymerValue instance
     */
    public static ImmutableResourceList.InternalSubstancePolymerValue copyOf(ResourceList.InternalSubstancePolymerValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSubstancePolymerValue) {
        return (ImmutableResourceList.InternalSubstancePolymerValue) instance;
      }
      return ImmutableResourceList.InternalSubstancePolymerValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSubstancePolymerValue InternalSubstancePolymerValue}.
     * <pre>
     * ImmutableResourceList.InternalSubstancePolymerValue.builder()
     *    .substancePolymer(com.fhir.types.fhir.SubstancePolymer) // required {@link ResourceList.InternalSubstancePolymerValue#substancePolymer() substancePolymer}
     *    .build();
     * </pre>
     * @return A new InternalSubstancePolymerValue builder
     */
    public static ImmutableResourceList.InternalSubstancePolymerValue.Builder builder() {
      return new ImmutableResourceList.InternalSubstancePolymerValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSubstancePolymerValue InternalSubstancePolymerValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSubstancePolymerValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SUBSTANCE_POLYMER = 0x1L;
      private long initBits = 0x1L;

      private @Nullable SubstancePolymer substancePolymer;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSubstancePolymerValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSubstancePolymerValue instance) {
        Objects.requireNonNull(instance, "instance");
        substancePolymer(instance.substancePolymer());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSubstancePolymerValue#substancePolymer() substancePolymer} attribute.
       * @param substancePolymer The value for substancePolymer 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("substancePolymer")
      public final Builder substancePolymer(SubstancePolymer substancePolymer) {
        this.substancePolymer = Objects.requireNonNull(substancePolymer, "substancePolymer");
        initBits &= ~INIT_BIT_SUBSTANCE_POLYMER;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSubstancePolymerValue InternalSubstancePolymerValue}.
       * @return An immutable instance of InternalSubstancePolymerValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSubstancePolymerValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSubstancePolymerValue(substancePolymer);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SUBSTANCE_POLYMER) != 0) attributes.add("substancePolymer");
        return "Cannot build InternalSubstancePolymerValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalBinaryValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalBinaryValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalBinaryValue", generator = "Immutables")
  @Immutable
  static final class InternalBinaryValue implements ResourceList.InternalBinaryValue {
    private final Binary binary;

    private InternalBinaryValue(Binary binary) {
      this.binary = binary;
    }

    /**
     * @return The value of the {@code binary} attribute
     */
    @JsonProperty("binary")
    @JsonValue
    @Override
    public Binary binary() {
      return binary;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalBinaryValue#binary() binary} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for binary
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalBinaryValue withBinary(Binary value) {
      if (this.binary == value) return this;
      Binary newValue = Objects.requireNonNull(value, "binary");
      return new ImmutableResourceList.InternalBinaryValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalBinaryValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalBinaryValue
          && equalTo((ImmutableResourceList.InternalBinaryValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalBinaryValue another) {
      return binary.equals(another.binary);
    }

    /**
     * Computes a hash code from attributes: {@code binary}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + binary.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalBinaryValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalBinaryValue{"
          + "binary=" + binary
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalBinaryValue fromJson(Binary jsonValue) {
      ImmutableResourceList.InternalBinaryValue.Builder builder = ImmutableResourceList.InternalBinaryValue.builder();
      builder.binary(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalBinaryValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalBinaryValue instance
     */
    public static ImmutableResourceList.InternalBinaryValue copyOf(ResourceList.InternalBinaryValue instance) {
      if (instance instanceof ImmutableResourceList.InternalBinaryValue) {
        return (ImmutableResourceList.InternalBinaryValue) instance;
      }
      return ImmutableResourceList.InternalBinaryValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalBinaryValue InternalBinaryValue}.
     * <pre>
     * ImmutableResourceList.InternalBinaryValue.builder()
     *    .binary(com.fhir.types.fhir.Binary) // required {@link ResourceList.InternalBinaryValue#binary() binary}
     *    .build();
     * </pre>
     * @return A new InternalBinaryValue builder
     */
    public static ImmutableResourceList.InternalBinaryValue.Builder builder() {
      return new ImmutableResourceList.InternalBinaryValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalBinaryValue InternalBinaryValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalBinaryValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_BINARY = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Binary binary;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalBinaryValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalBinaryValue instance) {
        Objects.requireNonNull(instance, "instance");
        binary(instance.binary());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalBinaryValue#binary() binary} attribute.
       * @param binary The value for binary 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("binary")
      public final Builder binary(Binary binary) {
        this.binary = Objects.requireNonNull(binary, "binary");
        initBits &= ~INIT_BIT_BINARY;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalBinaryValue InternalBinaryValue}.
       * @return An immutable instance of InternalBinaryValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalBinaryValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalBinaryValue(binary);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_BINARY) != 0) attributes.add("binary");
        return "Cannot build InternalBinaryValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalLibraryValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalLibraryValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalLibraryValue", generator = "Immutables")
  @Immutable
  static final class InternalLibraryValue implements ResourceList.InternalLibraryValue {
    private final Library library;

    private InternalLibraryValue(Library library) {
      this.library = library;
    }

    /**
     * @return The value of the {@code library} attribute
     */
    @JsonProperty("library")
    @JsonValue
    @Override
    public Library library() {
      return library;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalLibraryValue#library() library} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for library
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalLibraryValue withLibrary(Library value) {
      if (this.library == value) return this;
      Library newValue = Objects.requireNonNull(value, "library");
      return new ImmutableResourceList.InternalLibraryValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalLibraryValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalLibraryValue
          && equalTo((ImmutableResourceList.InternalLibraryValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalLibraryValue another) {
      return library.equals(another.library);
    }

    /**
     * Computes a hash code from attributes: {@code library}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + library.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalLibraryValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalLibraryValue{"
          + "library=" + library
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalLibraryValue fromJson(Library jsonValue) {
      ImmutableResourceList.InternalLibraryValue.Builder builder = ImmutableResourceList.InternalLibraryValue.builder();
      builder.library(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalLibraryValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalLibraryValue instance
     */
    public static ImmutableResourceList.InternalLibraryValue copyOf(ResourceList.InternalLibraryValue instance) {
      if (instance instanceof ImmutableResourceList.InternalLibraryValue) {
        return (ImmutableResourceList.InternalLibraryValue) instance;
      }
      return ImmutableResourceList.InternalLibraryValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalLibraryValue InternalLibraryValue}.
     * <pre>
     * ImmutableResourceList.InternalLibraryValue.builder()
     *    .library(com.fhir.types.fhir.Library) // required {@link ResourceList.InternalLibraryValue#library() library}
     *    .build();
     * </pre>
     * @return A new InternalLibraryValue builder
     */
    public static ImmutableResourceList.InternalLibraryValue.Builder builder() {
      return new ImmutableResourceList.InternalLibraryValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalLibraryValue InternalLibraryValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalLibraryValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_LIBRARY = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Library library;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalLibraryValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalLibraryValue instance) {
        Objects.requireNonNull(instance, "instance");
        library(instance.library());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalLibraryValue#library() library} attribute.
       * @param library The value for library 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("library")
      public final Builder library(Library library) {
        this.library = Objects.requireNonNull(library, "library");
        initBits &= ~INIT_BIT_LIBRARY;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalLibraryValue InternalLibraryValue}.
       * @return An immutable instance of InternalLibraryValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalLibraryValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalLibraryValue(library);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_LIBRARY) != 0) attributes.add("library");
        return "Cannot build InternalLibraryValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalClientApplicationValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalClientApplicationValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalClientApplicationValue", generator = "Immutables")
  @Immutable
  static final class InternalClientApplicationValue
      implements ResourceList.InternalClientApplicationValue {
    private final ClientApplication clientApplication;

    private InternalClientApplicationValue(ClientApplication clientApplication) {
      this.clientApplication = clientApplication;
    }

    /**
     * @return The value of the {@code clientApplication} attribute
     */
    @JsonProperty("clientApplication")
    @JsonValue
    @Override
    public ClientApplication clientApplication() {
      return clientApplication;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalClientApplicationValue#clientApplication() clientApplication} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for clientApplication
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalClientApplicationValue withClientApplication(ClientApplication value) {
      if (this.clientApplication == value) return this;
      ClientApplication newValue = Objects.requireNonNull(value, "clientApplication");
      return new ImmutableResourceList.InternalClientApplicationValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalClientApplicationValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalClientApplicationValue
          && equalTo((ImmutableResourceList.InternalClientApplicationValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalClientApplicationValue another) {
      return clientApplication.equals(another.clientApplication);
    }

    /**
     * Computes a hash code from attributes: {@code clientApplication}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + clientApplication.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalClientApplicationValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalClientApplicationValue{"
          + "clientApplication=" + clientApplication
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalClientApplicationValue fromJson(ClientApplication jsonValue) {
      ImmutableResourceList.InternalClientApplicationValue.Builder builder = ImmutableResourceList.InternalClientApplicationValue.builder();
      builder.clientApplication(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalClientApplicationValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalClientApplicationValue instance
     */
    public static ImmutableResourceList.InternalClientApplicationValue copyOf(ResourceList.InternalClientApplicationValue instance) {
      if (instance instanceof ImmutableResourceList.InternalClientApplicationValue) {
        return (ImmutableResourceList.InternalClientApplicationValue) instance;
      }
      return ImmutableResourceList.InternalClientApplicationValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalClientApplicationValue InternalClientApplicationValue}.
     * <pre>
     * ImmutableResourceList.InternalClientApplicationValue.builder()
     *    .clientApplication(com.fhir.types.fhir.ClientApplication) // required {@link ResourceList.InternalClientApplicationValue#clientApplication() clientApplication}
     *    .build();
     * </pre>
     * @return A new InternalClientApplicationValue builder
     */
    public static ImmutableResourceList.InternalClientApplicationValue.Builder builder() {
      return new ImmutableResourceList.InternalClientApplicationValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalClientApplicationValue InternalClientApplicationValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalClientApplicationValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CLIENT_APPLICATION = 0x1L;
      private long initBits = 0x1L;

      private @Nullable ClientApplication clientApplication;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalClientApplicationValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalClientApplicationValue instance) {
        Objects.requireNonNull(instance, "instance");
        clientApplication(instance.clientApplication());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalClientApplicationValue#clientApplication() clientApplication} attribute.
       * @param clientApplication The value for clientApplication 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("clientApplication")
      public final Builder clientApplication(ClientApplication clientApplication) {
        this.clientApplication = Objects.requireNonNull(clientApplication, "clientApplication");
        initBits &= ~INIT_BIT_CLIENT_APPLICATION;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalClientApplicationValue InternalClientApplicationValue}.
       * @return An immutable instance of InternalClientApplicationValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalClientApplicationValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalClientApplicationValue(clientApplication);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CLIENT_APPLICATION) != 0) attributes.add("clientApplication");
        return "Cannot build InternalClientApplicationValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMessageHeaderValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMessageHeaderValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMessageHeaderValue", generator = "Immutables")
  @Immutable
  static final class InternalMessageHeaderValue
      implements ResourceList.InternalMessageHeaderValue {
    private final MessageHeader messageHeader;

    private InternalMessageHeaderValue(MessageHeader messageHeader) {
      this.messageHeader = messageHeader;
    }

    /**
     * @return The value of the {@code messageHeader} attribute
     */
    @JsonProperty("messageHeader")
    @JsonValue
    @Override
    public MessageHeader messageHeader() {
      return messageHeader;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMessageHeaderValue#messageHeader() messageHeader} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for messageHeader
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMessageHeaderValue withMessageHeader(MessageHeader value) {
      if (this.messageHeader == value) return this;
      MessageHeader newValue = Objects.requireNonNull(value, "messageHeader");
      return new ImmutableResourceList.InternalMessageHeaderValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMessageHeaderValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMessageHeaderValue
          && equalTo((ImmutableResourceList.InternalMessageHeaderValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMessageHeaderValue another) {
      return messageHeader.equals(another.messageHeader);
    }

    /**
     * Computes a hash code from attributes: {@code messageHeader}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + messageHeader.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMessageHeaderValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMessageHeaderValue{"
          + "messageHeader=" + messageHeader
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMessageHeaderValue fromJson(MessageHeader jsonValue) {
      ImmutableResourceList.InternalMessageHeaderValue.Builder builder = ImmutableResourceList.InternalMessageHeaderValue.builder();
      builder.messageHeader(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMessageHeaderValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMessageHeaderValue instance
     */
    public static ImmutableResourceList.InternalMessageHeaderValue copyOf(ResourceList.InternalMessageHeaderValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMessageHeaderValue) {
        return (ImmutableResourceList.InternalMessageHeaderValue) instance;
      }
      return ImmutableResourceList.InternalMessageHeaderValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMessageHeaderValue InternalMessageHeaderValue}.
     * <pre>
     * ImmutableResourceList.InternalMessageHeaderValue.builder()
     *    .messageHeader(com.fhir.types.fhir.MessageHeader) // required {@link ResourceList.InternalMessageHeaderValue#messageHeader() messageHeader}
     *    .build();
     * </pre>
     * @return A new InternalMessageHeaderValue builder
     */
    public static ImmutableResourceList.InternalMessageHeaderValue.Builder builder() {
      return new ImmutableResourceList.InternalMessageHeaderValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMessageHeaderValue InternalMessageHeaderValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMessageHeaderValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MESSAGE_HEADER = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MessageHeader messageHeader;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMessageHeaderValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMessageHeaderValue instance) {
        Objects.requireNonNull(instance, "instance");
        messageHeader(instance.messageHeader());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMessageHeaderValue#messageHeader() messageHeader} attribute.
       * @param messageHeader The value for messageHeader 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("messageHeader")
      public final Builder messageHeader(MessageHeader messageHeader) {
        this.messageHeader = Objects.requireNonNull(messageHeader, "messageHeader");
        initBits &= ~INIT_BIT_MESSAGE_HEADER;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMessageHeaderValue InternalMessageHeaderValue}.
       * @return An immutable instance of InternalMessageHeaderValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMessageHeaderValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMessageHeaderValue(messageHeader);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MESSAGE_HEADER) != 0) attributes.add("messageHeader");
        return "Cannot build InternalMessageHeaderValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalCodeSystemValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalCodeSystemValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalCodeSystemValue", generator = "Immutables")
  @Immutable
  static final class InternalCodeSystemValue
      implements ResourceList.InternalCodeSystemValue {
    private final CodeSystem codeSystem;

    private InternalCodeSystemValue(CodeSystem codeSystem) {
      this.codeSystem = codeSystem;
    }

    /**
     * @return The value of the {@code codeSystem} attribute
     */
    @JsonProperty("codeSystem")
    @JsonValue
    @Override
    public CodeSystem codeSystem() {
      return codeSystem;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalCodeSystemValue#codeSystem() codeSystem} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for codeSystem
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalCodeSystemValue withCodeSystem(CodeSystem value) {
      if (this.codeSystem == value) return this;
      CodeSystem newValue = Objects.requireNonNull(value, "codeSystem");
      return new ImmutableResourceList.InternalCodeSystemValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalCodeSystemValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalCodeSystemValue
          && equalTo((ImmutableResourceList.InternalCodeSystemValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalCodeSystemValue another) {
      return codeSystem.equals(another.codeSystem);
    }

    /**
     * Computes a hash code from attributes: {@code codeSystem}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + codeSystem.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalCodeSystemValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalCodeSystemValue{"
          + "codeSystem=" + codeSystem
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalCodeSystemValue fromJson(CodeSystem jsonValue) {
      ImmutableResourceList.InternalCodeSystemValue.Builder builder = ImmutableResourceList.InternalCodeSystemValue.builder();
      builder.codeSystem(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalCodeSystemValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalCodeSystemValue instance
     */
    public static ImmutableResourceList.InternalCodeSystemValue copyOf(ResourceList.InternalCodeSystemValue instance) {
      if (instance instanceof ImmutableResourceList.InternalCodeSystemValue) {
        return (ImmutableResourceList.InternalCodeSystemValue) instance;
      }
      return ImmutableResourceList.InternalCodeSystemValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalCodeSystemValue InternalCodeSystemValue}.
     * <pre>
     * ImmutableResourceList.InternalCodeSystemValue.builder()
     *    .codeSystem(com.fhir.types.fhir.CodeSystem) // required {@link ResourceList.InternalCodeSystemValue#codeSystem() codeSystem}
     *    .build();
     * </pre>
     * @return A new InternalCodeSystemValue builder
     */
    public static ImmutableResourceList.InternalCodeSystemValue.Builder builder() {
      return new ImmutableResourceList.InternalCodeSystemValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalCodeSystemValue InternalCodeSystemValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalCodeSystemValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_CODE_SYSTEM = 0x1L;
      private long initBits = 0x1L;

      private @Nullable CodeSystem codeSystem;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalCodeSystemValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalCodeSystemValue instance) {
        Objects.requireNonNull(instance, "instance");
        codeSystem(instance.codeSystem());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalCodeSystemValue#codeSystem() codeSystem} attribute.
       * @param codeSystem The value for codeSystem 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("codeSystem")
      public final Builder codeSystem(CodeSystem codeSystem) {
        this.codeSystem = Objects.requireNonNull(codeSystem, "codeSystem");
        initBits &= ~INIT_BIT_CODE_SYSTEM;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalCodeSystemValue InternalCodeSystemValue}.
       * @return An immutable instance of InternalCodeSystemValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalCodeSystemValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalCodeSystemValue(codeSystem);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_CODE_SYSTEM) != 0) attributes.add("codeSystem");
        return "Cannot build InternalCodeSystemValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalMedicationKnowledgeValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalMedicationKnowledgeValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalMedicationKnowledgeValue", generator = "Immutables")
  @Immutable
  static final class InternalMedicationKnowledgeValue
      implements ResourceList.InternalMedicationKnowledgeValue {
    private final MedicationKnowledge medicationKnowledge;

    private InternalMedicationKnowledgeValue(MedicationKnowledge medicationKnowledge) {
      this.medicationKnowledge = medicationKnowledge;
    }

    /**
     * @return The value of the {@code medicationKnowledge} attribute
     */
    @JsonProperty("medicationKnowledge")
    @JsonValue
    @Override
    public MedicationKnowledge medicationKnowledge() {
      return medicationKnowledge;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalMedicationKnowledgeValue#medicationKnowledge() medicationKnowledge} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for medicationKnowledge
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalMedicationKnowledgeValue withMedicationKnowledge(MedicationKnowledge value) {
      if (this.medicationKnowledge == value) return this;
      MedicationKnowledge newValue = Objects.requireNonNull(value, "medicationKnowledge");
      return new ImmutableResourceList.InternalMedicationKnowledgeValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalMedicationKnowledgeValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalMedicationKnowledgeValue
          && equalTo((ImmutableResourceList.InternalMedicationKnowledgeValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalMedicationKnowledgeValue another) {
      return medicationKnowledge.equals(another.medicationKnowledge);
    }

    /**
     * Computes a hash code from attributes: {@code medicationKnowledge}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + medicationKnowledge.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalMedicationKnowledgeValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalMedicationKnowledgeValue{"
          + "medicationKnowledge=" + medicationKnowledge
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalMedicationKnowledgeValue fromJson(MedicationKnowledge jsonValue) {
      ImmutableResourceList.InternalMedicationKnowledgeValue.Builder builder = ImmutableResourceList.InternalMedicationKnowledgeValue.builder();
      builder.medicationKnowledge(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalMedicationKnowledgeValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalMedicationKnowledgeValue instance
     */
    public static ImmutableResourceList.InternalMedicationKnowledgeValue copyOf(ResourceList.InternalMedicationKnowledgeValue instance) {
      if (instance instanceof ImmutableResourceList.InternalMedicationKnowledgeValue) {
        return (ImmutableResourceList.InternalMedicationKnowledgeValue) instance;
      }
      return ImmutableResourceList.InternalMedicationKnowledgeValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalMedicationKnowledgeValue InternalMedicationKnowledgeValue}.
     * <pre>
     * ImmutableResourceList.InternalMedicationKnowledgeValue.builder()
     *    .medicationKnowledge(com.fhir.types.fhir.MedicationKnowledge) // required {@link ResourceList.InternalMedicationKnowledgeValue#medicationKnowledge() medicationKnowledge}
     *    .build();
     * </pre>
     * @return A new InternalMedicationKnowledgeValue builder
     */
    public static ImmutableResourceList.InternalMedicationKnowledgeValue.Builder builder() {
      return new ImmutableResourceList.InternalMedicationKnowledgeValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalMedicationKnowledgeValue InternalMedicationKnowledgeValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalMedicationKnowledgeValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_MEDICATION_KNOWLEDGE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable MedicationKnowledge medicationKnowledge;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalMedicationKnowledgeValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalMedicationKnowledgeValue instance) {
        Objects.requireNonNull(instance, "instance");
        medicationKnowledge(instance.medicationKnowledge());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalMedicationKnowledgeValue#medicationKnowledge() medicationKnowledge} attribute.
       * @param medicationKnowledge The value for medicationKnowledge 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("medicationKnowledge")
      public final Builder medicationKnowledge(MedicationKnowledge medicationKnowledge) {
        this.medicationKnowledge = Objects.requireNonNull(medicationKnowledge, "medicationKnowledge");
        initBits &= ~INIT_BIT_MEDICATION_KNOWLEDGE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalMedicationKnowledgeValue InternalMedicationKnowledgeValue}.
       * @return An immutable instance of InternalMedicationKnowledgeValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalMedicationKnowledgeValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalMedicationKnowledgeValue(medicationKnowledge);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_MEDICATION_KNOWLEDGE) != 0) attributes.add("medicationKnowledge");
        return "Cannot build InternalMedicationKnowledgeValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalEndpointValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalEndpointValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalEndpointValue", generator = "Immutables")
  @Immutable
  static final class InternalEndpointValue implements ResourceList.InternalEndpointValue {
    private final Endpoint endpoint;

    private InternalEndpointValue(Endpoint endpoint) {
      this.endpoint = endpoint;
    }

    /**
     * @return The value of the {@code endpoint} attribute
     */
    @JsonProperty("endpoint")
    @JsonValue
    @Override
    public Endpoint endpoint() {
      return endpoint;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalEndpointValue#endpoint() endpoint} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for endpoint
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalEndpointValue withEndpoint(Endpoint value) {
      if (this.endpoint == value) return this;
      Endpoint newValue = Objects.requireNonNull(value, "endpoint");
      return new ImmutableResourceList.InternalEndpointValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalEndpointValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalEndpointValue
          && equalTo((ImmutableResourceList.InternalEndpointValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalEndpointValue another) {
      return endpoint.equals(another.endpoint);
    }

    /**
     * Computes a hash code from attributes: {@code endpoint}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + endpoint.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalEndpointValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalEndpointValue{"
          + "endpoint=" + endpoint
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalEndpointValue fromJson(Endpoint jsonValue) {
      ImmutableResourceList.InternalEndpointValue.Builder builder = ImmutableResourceList.InternalEndpointValue.builder();
      builder.endpoint(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalEndpointValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalEndpointValue instance
     */
    public static ImmutableResourceList.InternalEndpointValue copyOf(ResourceList.InternalEndpointValue instance) {
      if (instance instanceof ImmutableResourceList.InternalEndpointValue) {
        return (ImmutableResourceList.InternalEndpointValue) instance;
      }
      return ImmutableResourceList.InternalEndpointValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalEndpointValue InternalEndpointValue}.
     * <pre>
     * ImmutableResourceList.InternalEndpointValue.builder()
     *    .endpoint(com.fhir.types.fhir.Endpoint) // required {@link ResourceList.InternalEndpointValue#endpoint() endpoint}
     *    .build();
     * </pre>
     * @return A new InternalEndpointValue builder
     */
    public static ImmutableResourceList.InternalEndpointValue.Builder builder() {
      return new ImmutableResourceList.InternalEndpointValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalEndpointValue InternalEndpointValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalEndpointValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ENDPOINT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Endpoint endpoint;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalEndpointValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalEndpointValue instance) {
        Objects.requireNonNull(instance, "instance");
        endpoint(instance.endpoint());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalEndpointValue#endpoint() endpoint} attribute.
       * @param endpoint The value for endpoint 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("endpoint")
      public final Builder endpoint(Endpoint endpoint) {
        this.endpoint = Objects.requireNonNull(endpoint, "endpoint");
        initBits &= ~INIT_BIT_ENDPOINT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalEndpointValue InternalEndpointValue}.
       * @return An immutable instance of InternalEndpointValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalEndpointValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalEndpointValue(endpoint);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ENDPOINT) != 0) attributes.add("endpoint");
        return "Cannot build InternalEndpointValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalRelatedPersonValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalRelatedPersonValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalRelatedPersonValue", generator = "Immutables")
  @Immutable
  static final class InternalRelatedPersonValue
      implements ResourceList.InternalRelatedPersonValue {
    private final RelatedPerson relatedPerson;

    private InternalRelatedPersonValue(RelatedPerson relatedPerson) {
      this.relatedPerson = relatedPerson;
    }

    /**
     * @return The value of the {@code relatedPerson} attribute
     */
    @JsonProperty("relatedPerson")
    @JsonValue
    @Override
    public RelatedPerson relatedPerson() {
      return relatedPerson;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalRelatedPersonValue#relatedPerson() relatedPerson} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for relatedPerson
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalRelatedPersonValue withRelatedPerson(RelatedPerson value) {
      if (this.relatedPerson == value) return this;
      RelatedPerson newValue = Objects.requireNonNull(value, "relatedPerson");
      return new ImmutableResourceList.InternalRelatedPersonValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalRelatedPersonValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalRelatedPersonValue
          && equalTo((ImmutableResourceList.InternalRelatedPersonValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalRelatedPersonValue another) {
      return relatedPerson.equals(another.relatedPerson);
    }

    /**
     * Computes a hash code from attributes: {@code relatedPerson}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + relatedPerson.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalRelatedPersonValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalRelatedPersonValue{"
          + "relatedPerson=" + relatedPerson
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalRelatedPersonValue fromJson(RelatedPerson jsonValue) {
      ImmutableResourceList.InternalRelatedPersonValue.Builder builder = ImmutableResourceList.InternalRelatedPersonValue.builder();
      builder.relatedPerson(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalRelatedPersonValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalRelatedPersonValue instance
     */
    public static ImmutableResourceList.InternalRelatedPersonValue copyOf(ResourceList.InternalRelatedPersonValue instance) {
      if (instance instanceof ImmutableResourceList.InternalRelatedPersonValue) {
        return (ImmutableResourceList.InternalRelatedPersonValue) instance;
      }
      return ImmutableResourceList.InternalRelatedPersonValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalRelatedPersonValue InternalRelatedPersonValue}.
     * <pre>
     * ImmutableResourceList.InternalRelatedPersonValue.builder()
     *    .relatedPerson(com.fhir.types.fhir.RelatedPerson) // required {@link ResourceList.InternalRelatedPersonValue#relatedPerson() relatedPerson}
     *    .build();
     * </pre>
     * @return A new InternalRelatedPersonValue builder
     */
    public static ImmutableResourceList.InternalRelatedPersonValue.Builder builder() {
      return new ImmutableResourceList.InternalRelatedPersonValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalRelatedPersonValue InternalRelatedPersonValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalRelatedPersonValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_RELATED_PERSON = 0x1L;
      private long initBits = 0x1L;

      private @Nullable RelatedPerson relatedPerson;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalRelatedPersonValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalRelatedPersonValue instance) {
        Objects.requireNonNull(instance, "instance");
        relatedPerson(instance.relatedPerson());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalRelatedPersonValue#relatedPerson() relatedPerson} attribute.
       * @param relatedPerson The value for relatedPerson 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("relatedPerson")
      public final Builder relatedPerson(RelatedPerson relatedPerson) {
        this.relatedPerson = Objects.requireNonNull(relatedPerson, "relatedPerson");
        initBits &= ~INIT_BIT_RELATED_PERSON;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalRelatedPersonValue InternalRelatedPersonValue}.
       * @return An immutable instance of InternalRelatedPersonValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalRelatedPersonValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalRelatedPersonValue(relatedPerson);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_RELATED_PERSON) != 0) attributes.add("relatedPerson");
        return "Cannot build InternalRelatedPersonValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalSlotValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalSlotValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalSlotValue", generator = "Immutables")
  @Immutable
  static final class InternalSlotValue implements ResourceList.InternalSlotValue {
    private final Slot slot;

    private InternalSlotValue(Slot slot) {
      this.slot = slot;
    }

    /**
     * @return The value of the {@code slot} attribute
     */
    @JsonProperty("slot")
    @JsonValue
    @Override
    public Slot slot() {
      return slot;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalSlotValue#slot() slot} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for slot
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalSlotValue withSlot(Slot value) {
      if (this.slot == value) return this;
      Slot newValue = Objects.requireNonNull(value, "slot");
      return new ImmutableResourceList.InternalSlotValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalSlotValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalSlotValue
          && equalTo((ImmutableResourceList.InternalSlotValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalSlotValue another) {
      return slot.equals(another.slot);
    }

    /**
     * Computes a hash code from attributes: {@code slot}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + slot.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalSlotValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalSlotValue{"
          + "slot=" + slot
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalSlotValue fromJson(Slot jsonValue) {
      ImmutableResourceList.InternalSlotValue.Builder builder = ImmutableResourceList.InternalSlotValue.builder();
      builder.slot(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalSlotValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalSlotValue instance
     */
    public static ImmutableResourceList.InternalSlotValue copyOf(ResourceList.InternalSlotValue instance) {
      if (instance instanceof ImmutableResourceList.InternalSlotValue) {
        return (ImmutableResourceList.InternalSlotValue) instance;
      }
      return ImmutableResourceList.InternalSlotValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalSlotValue InternalSlotValue}.
     * <pre>
     * ImmutableResourceList.InternalSlotValue.builder()
     *    .slot(com.fhir.types.fhir.Slot) // required {@link ResourceList.InternalSlotValue#slot() slot}
     *    .build();
     * </pre>
     * @return A new InternalSlotValue builder
     */
    public static ImmutableResourceList.InternalSlotValue.Builder builder() {
      return new ImmutableResourceList.InternalSlotValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalSlotValue InternalSlotValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalSlotValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_SLOT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Slot slot;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalSlotValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalSlotValue instance) {
        Objects.requireNonNull(instance, "instance");
        slot(instance.slot());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalSlotValue#slot() slot} attribute.
       * @param slot The value for slot 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("slot")
      public final Builder slot(Slot slot) {
        this.slot = Objects.requireNonNull(slot, "slot");
        initBits &= ~INIT_BIT_SLOT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalSlotValue InternalSlotValue}.
       * @return An immutable instance of InternalSlotValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalSlotValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalSlotValue(slot);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_SLOT) != 0) attributes.add("slot");
        return "Cannot build InternalSlotValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalAdverseEventValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalAdverseEventValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalAdverseEventValue", generator = "Immutables")
  @Immutable
  static final class InternalAdverseEventValue
      implements ResourceList.InternalAdverseEventValue {
    private final AdverseEvent adverseEvent;

    private InternalAdverseEventValue(AdverseEvent adverseEvent) {
      this.adverseEvent = adverseEvent;
    }

    /**
     * @return The value of the {@code adverseEvent} attribute
     */
    @JsonProperty("adverseEvent")
    @JsonValue
    @Override
    public AdverseEvent adverseEvent() {
      return adverseEvent;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalAdverseEventValue#adverseEvent() adverseEvent} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for adverseEvent
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalAdverseEventValue withAdverseEvent(AdverseEvent value) {
      if (this.adverseEvent == value) return this;
      AdverseEvent newValue = Objects.requireNonNull(value, "adverseEvent");
      return new ImmutableResourceList.InternalAdverseEventValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalAdverseEventValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalAdverseEventValue
          && equalTo((ImmutableResourceList.InternalAdverseEventValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalAdverseEventValue another) {
      return adverseEvent.equals(another.adverseEvent);
    }

    /**
     * Computes a hash code from attributes: {@code adverseEvent}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + adverseEvent.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalAdverseEventValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalAdverseEventValue{"
          + "adverseEvent=" + adverseEvent
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalAdverseEventValue fromJson(AdverseEvent jsonValue) {
      ImmutableResourceList.InternalAdverseEventValue.Builder builder = ImmutableResourceList.InternalAdverseEventValue.builder();
      builder.adverseEvent(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalAdverseEventValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalAdverseEventValue instance
     */
    public static ImmutableResourceList.InternalAdverseEventValue copyOf(ResourceList.InternalAdverseEventValue instance) {
      if (instance instanceof ImmutableResourceList.InternalAdverseEventValue) {
        return (ImmutableResourceList.InternalAdverseEventValue) instance;
      }
      return ImmutableResourceList.InternalAdverseEventValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalAdverseEventValue InternalAdverseEventValue}.
     * <pre>
     * ImmutableResourceList.InternalAdverseEventValue.builder()
     *    .adverseEvent(com.fhir.types.fhir.AdverseEvent) // required {@link ResourceList.InternalAdverseEventValue#adverseEvent() adverseEvent}
     *    .build();
     * </pre>
     * @return A new InternalAdverseEventValue builder
     */
    public static ImmutableResourceList.InternalAdverseEventValue.Builder builder() {
      return new ImmutableResourceList.InternalAdverseEventValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalAdverseEventValue InternalAdverseEventValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalAdverseEventValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_ADVERSE_EVENT = 0x1L;
      private long initBits = 0x1L;

      private @Nullable AdverseEvent adverseEvent;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalAdverseEventValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalAdverseEventValue instance) {
        Objects.requireNonNull(instance, "instance");
        adverseEvent(instance.adverseEvent());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalAdverseEventValue#adverseEvent() adverseEvent} attribute.
       * @param adverseEvent The value for adverseEvent 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("adverseEvent")
      public final Builder adverseEvent(AdverseEvent adverseEvent) {
        this.adverseEvent = Objects.requireNonNull(adverseEvent, "adverseEvent");
        initBits &= ~INIT_BIT_ADVERSE_EVENT;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalAdverseEventValue InternalAdverseEventValue}.
       * @return An immutable instance of InternalAdverseEventValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalAdverseEventValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalAdverseEventValue(adverseEvent);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_ADVERSE_EVENT) != 0) attributes.add("adverseEvent");
        return "Cannot build InternalAdverseEventValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.InternalQuestionnaireValue}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.InternalQuestionnaireValue.builder()}.
   */
  @Generated(from = "ResourceList.InternalQuestionnaireValue", generator = "Immutables")
  @Immutable
  static final class InternalQuestionnaireValue
      implements ResourceList.InternalQuestionnaireValue {
    private final Questionnaire questionnaire;

    private InternalQuestionnaireValue(Questionnaire questionnaire) {
      this.questionnaire = questionnaire;
    }

    /**
     * @return The value of the {@code questionnaire} attribute
     */
    @JsonProperty("questionnaire")
    @JsonValue
    @Override
    public Questionnaire questionnaire() {
      return questionnaire;
    }

    /**
     * Copy the current immutable object by setting a value for the {@link ResourceList.InternalQuestionnaireValue#questionnaire() questionnaire} attribute.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param value A new value for questionnaire
     * @return A modified copy of the {@code this} object
     */
    public final ImmutableResourceList.InternalQuestionnaireValue withQuestionnaire(Questionnaire value) {
      if (this.questionnaire == value) return this;
      Questionnaire newValue = Objects.requireNonNull(value, "questionnaire");
      return new ImmutableResourceList.InternalQuestionnaireValue(newValue);
    }

    /**
     * This instance is equal to all instances of {@code InternalQuestionnaireValue} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.InternalQuestionnaireValue
          && equalTo((ImmutableResourceList.InternalQuestionnaireValue) another);
    }

    private boolean equalTo(ImmutableResourceList.InternalQuestionnaireValue another) {
      return questionnaire.equals(another.questionnaire);
    }

    /**
     * Computes a hash code from attributes: {@code questionnaire}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + questionnaire.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code InternalQuestionnaireValue} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "InternalQuestionnaireValue{"
          + "questionnaire=" + questionnaire
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.InternalQuestionnaireValue fromJson(Questionnaire jsonValue) {
      ImmutableResourceList.InternalQuestionnaireValue.Builder builder = ImmutableResourceList.InternalQuestionnaireValue.builder();
      builder.questionnaire(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.InternalQuestionnaireValue} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable InternalQuestionnaireValue instance
     */
    public static ImmutableResourceList.InternalQuestionnaireValue copyOf(ResourceList.InternalQuestionnaireValue instance) {
      if (instance instanceof ImmutableResourceList.InternalQuestionnaireValue) {
        return (ImmutableResourceList.InternalQuestionnaireValue) instance;
      }
      return ImmutableResourceList.InternalQuestionnaireValue.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.InternalQuestionnaireValue InternalQuestionnaireValue}.
     * <pre>
     * ImmutableResourceList.InternalQuestionnaireValue.builder()
     *    .questionnaire(com.fhir.types.fhir.Questionnaire) // required {@link ResourceList.InternalQuestionnaireValue#questionnaire() questionnaire}
     *    .build();
     * </pre>
     * @return A new InternalQuestionnaireValue builder
     */
    public static ImmutableResourceList.InternalQuestionnaireValue.Builder builder() {
      return new ImmutableResourceList.InternalQuestionnaireValue.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.InternalQuestionnaireValue InternalQuestionnaireValue}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.InternalQuestionnaireValue", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private static final long INIT_BIT_QUESTIONNAIRE = 0x1L;
      private long initBits = 0x1L;

      private @Nullable Questionnaire questionnaire;

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code InternalQuestionnaireValue} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.InternalQuestionnaireValue instance) {
        Objects.requireNonNull(instance, "instance");
        questionnaire(instance.questionnaire());
        return this;
      }

      /**
       * Initializes the value for the {@link ResourceList.InternalQuestionnaireValue#questionnaire() questionnaire} attribute.
       * @param questionnaire The value for questionnaire 
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("questionnaire")
      public final Builder questionnaire(Questionnaire questionnaire) {
        this.questionnaire = Objects.requireNonNull(questionnaire, "questionnaire");
        initBits &= ~INIT_BIT_QUESTIONNAIRE;
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.InternalQuestionnaireValue InternalQuestionnaireValue}.
       * @return An immutable instance of InternalQuestionnaireValue
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.InternalQuestionnaireValue build() {
        if (initBits != 0) {
          throw new IllegalStateException(formatRequiredAttributesMessage());
        }
        return new ImmutableResourceList.InternalQuestionnaireValue(questionnaire);
      }

      private String formatRequiredAttributesMessage() {
        List<String> attributes = new ArrayList<>();
        if ((initBits & INIT_BIT_QUESTIONNAIRE) != 0) attributes.add("questionnaire");
        return "Cannot build InternalQuestionnaireValue, some of required attributes are not set " + attributes;
      }
    }
  }

  /**
   * Immutable implementation of {@link ResourceList.Unknown}.
   * <p>
   * Use the builder to create immutable instances:
   * {@code ImmutableResourceList.Unknown.builder()}.
   */
  @Generated(from = "ResourceList.Unknown", generator = "Immutables")
  @Immutable
  static final class Unknown implements ResourceList.Unknown {
    private final Map<String, Object> value;

    private Unknown(Map<String, Object> value) {
      this.value = value;
    }

    /**
     * @return The value of the {@code value} attribute
     */
    @JsonProperty("value")
    @JsonValue
    @Override
    public Map<String, Object> value() {
      return value;
    }

    /**
     * Copy the current immutable object by replacing the {@link ResourceList.Unknown#value() value} map with the specified map.
     * Nulls are not permitted as keys or values.
     * A shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
     * @param entries The entries to be added to the value map
     * @return A modified copy of {@code this} object
     */
    public final ImmutableResourceList.Unknown withValue(Map<String, ? extends Object> entries) {
      if (this.value == entries) return this;
      Map<String, Object> newValue = createUnmodifiableMap(true, false, entries);
      return new ImmutableResourceList.Unknown(newValue);
    }

    /**
     * This instance is equal to all instances of {@code Unknown} that have equal attribute values.
     * @return {@code true} if {@code this} is equal to {@code another} instance
     */
    @Override
    public boolean equals(@Nullable Object another) {
      if (this == another) return true;
      return another instanceof ImmutableResourceList.Unknown
          && equalTo((ImmutableResourceList.Unknown) another);
    }

    private boolean equalTo(ImmutableResourceList.Unknown another) {
      return value.equals(another.value);
    }

    /**
     * Computes a hash code from attributes: {@code value}.
     * @return hashCode value
     */
    @Override
    public int hashCode() {
      int h = 5381;
      h += (h << 5) + value.hashCode();
      return h;
    }

    /**
     * Prints the immutable value {@code Unknown} with attribute values.
     * @return A string representation of the value
     */
    @Override
    public String toString() {
      return "Unknown{"
          + "value=" + value
          + "}";
    }

    /**
     * @param jsonValue to construct object from
     * @return An immutable value type
     * @deprecated Do not use this method directly, it exists only for the <em>Jackson</em>-binding infrastructure
     */
    @Deprecated
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    static ImmutableResourceList.Unknown fromJson(Map<String, Object> jsonValue) {
      ImmutableResourceList.Unknown.Builder builder = ImmutableResourceList.Unknown.builder();
      builder.putAllValue(jsonValue);
      return builder.build();
    }

    /**
     * Creates an immutable copy of a {@link ResourceList.Unknown} value.
     * Uses accessors to get values to initialize the new immutable instance.
     * If an instance is already immutable, it is returned as is.
     * @param instance The instance to copy
     * @return A copied immutable Unknown instance
     */
    public static ImmutableResourceList.Unknown copyOf(ResourceList.Unknown instance) {
      if (instance instanceof ImmutableResourceList.Unknown) {
        return (ImmutableResourceList.Unknown) instance;
      }
      return ImmutableResourceList.Unknown.builder()
          .from(instance)
          .build();
    }

    /**
     * Creates a builder for {@link ImmutableResourceList.Unknown Unknown}.
     * <pre>
     * ImmutableResourceList.Unknown.builder()
     *    .putValue|putAllValue(String =&gt; Object) // {@link ResourceList.Unknown#value() value} mappings
     *    .build();
     * </pre>
     * @return A new Unknown builder
     */
    public static ImmutableResourceList.Unknown.Builder builder() {
      return new ImmutableResourceList.Unknown.Builder();
    }

    /**
     * Builds instances of type {@link ImmutableResourceList.Unknown Unknown}.
     * Initialize attributes and then invoke the {@link #build()} method to create an
     * immutable instance.
     * <p><em>{@code Builder} is not thread-safe and generally should not be stored in a field or collection,
     * but instead used immediately to create instances.</em>
     */
    @Generated(from = "ResourceList.Unknown", generator = "Immutables")
    @NotThreadSafe
    public static final class Builder {
      private Map<String, Object> value = new LinkedHashMap<String, Object>();

      private Builder() {
      }

      /**
       * Fill a builder with attribute values from the provided {@code Unknown} instance.
       * Regular attribute values will be replaced with those from the given instance.
       * Absent optional values will not replace present values.
       * Collection elements and entries will be added, not replaced.
       * @param instance The instance from which to copy values
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder from(ResourceList.Unknown instance) {
        Objects.requireNonNull(instance, "instance");
        putAllValue(instance.value());
        return this;
      }

      /**
       * Put one entry to the {@link ResourceList.Unknown#value() value} map.
       * @param key The key in the value map
       * @param value The associated value in the value map
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder putValue(String key, Object value) {
        this.value.put(
            Objects.requireNonNull(key, "value key"),
            Objects.requireNonNull(value, "value value"));
        return this;
      }

      /**
       * Put one entry to the {@link ResourceList.Unknown#value() value} map. Nulls are not permitted
       * @param entry The key and value entry
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder putValue(Map.Entry<String, ? extends Object> entry) {
        String k = entry.getKey();
        Object v = entry.getValue();
        this.value.put(
            Objects.requireNonNull(k, "value key"),
            Objects.requireNonNull(v, "value value"));
        return this;
      }

      /**
       * Sets or replaces all mappings from the specified map as entries for the {@link ResourceList.Unknown#value() value} map. Nulls are not permitted
       * @param entries The entries that will be added to the value map
       * @return {@code this} builder for use in a chained invocation
       */
      @JsonProperty("value")
      public final Builder value(Map<String, ? extends Object> entries) {
        this.value.clear();
        return putAllValue(entries);
      }

      /**
       * Put all mappings from the specified map as entries to {@link ResourceList.Unknown#value() value} map. Nulls are not permitted
       * @param entries The entries that will be added to the value map
       * @return {@code this} builder for use in a chained invocation
       */
      public final Builder putAllValue(Map<String, ? extends Object> entries) {
        for (Map.Entry<String, ? extends Object> e : entries.entrySet()) {
          String k = e.getKey();
          Object v = e.getValue();
          this.value.put(
              Objects.requireNonNull(k, "value key"),
              Objects.requireNonNull(v, "value value"));
        }
        return this;
      }

      /**
       * Builds a new {@link ImmutableResourceList.Unknown Unknown}.
       * @return An immutable instance of Unknown
       * @throws java.lang.IllegalStateException if any required attributes are missing
       */
      public ImmutableResourceList.Unknown build() {
        return new ImmutableResourceList.Unknown(createUnmodifiableMap(false, false, value));
      }
    }
  }

  private static <K, V> Map<K, V> createUnmodifiableMap(boolean checkNulls, boolean skipNulls, Map<? extends K, ? extends V> map) {
    switch (map.size()) {
    case 0: return Collections.emptyMap();
    case 1: {
      Map.Entry<? extends K, ? extends V> e = map.entrySet().iterator().next();
      K k = e.getKey();
      V v = e.getValue();
      if (checkNulls) {
        Objects.requireNonNull(k, "key");
        Objects.requireNonNull(v, "value");
      }
      if (skipNulls && (k == null || v == null)) {
        return Collections.emptyMap();
      }
      return Collections.singletonMap(k, v);
    }
    default: {
      Map<K, V> linkedMap = new LinkedHashMap<>(map.size());
      if (skipNulls || checkNulls) {
        for (Map.Entry<? extends K, ? extends V> e : map.entrySet()) {
          K k = e.getKey();
          V v = e.getValue();
          if (skipNulls) {
            if (k == null || v == null) continue;
          } else if (checkNulls) {
            Objects.requireNonNull(k, "key");
            Objects.requireNonNull(v, "value");
          }
          linkedMap.put(k, v);
        }
      } else {
        linkedMap.putAll(map);
      }
      return Collections.unmodifiableMap(linkedMap);
    }
    }
  }
}
