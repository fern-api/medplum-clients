"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageJsonRule = void 0;
const mrlint_commons_1 = require("@fern-api/mrlint-commons");
const immer_1 = __importDefault(require("immer"));
const path_1 = __importDefault(require("path"));
const Executables_1 = require("../utils/Executables");
const getDependencies_1 = require("../utils/getDependencies");
const tryGetPackageJson_1 = require("../utils/tryGetPackageJson");
const writePackageFile_1 = require("../utils/writePackageFile");
const PRODUCTION_ENVIRONMENT_ENV_VAR = "REACT_APP_PRODUCTION_ENVIRONMENT";
const EXPECTED_DEV_DEPENDENCIES = ["@types/node"];
const PATH_TO_CLI_SCRIPT = "./cli";
exports.PackageJsonRule = {
    ruleId: "package-json",
    type: mrlint_commons_1.RuleType.PACKAGE,
    targetedPackages: [
        mrlint_commons_1.PackageType.REACT_APP,
        mrlint_commons_1.PackageType.REACT_LIBRARY,
        mrlint_commons_1.PackageType.TYPESCRIPT_LIBRARY,
        mrlint_commons_1.PackageType.TYPESCRIPT_CLI,
    ],
    run: runRule,
};
async function runRule({ fileSystems, relativePathToRoot, relativePathToSharedConfigs, packageToLint, logger, addDevDependency, }) {
    const result = mrlint_commons_1.Result.success();
    const executables = new Executables_1.Executables();
    let packageJson;
    try {
        packageJson = generatePackageJson({
            packageToLint,
            relativePathToRoot,
            relativePathToSharedConfigs,
            logger,
            executables,
        });
    }
    catch (error) {
        logger.error({
            message: "Failed to generate package.json",
            error,
        });
        return mrlint_commons_1.Result.failure();
    }
    packageJson = (0, immer_1.default)(packageJson, (draft) => {
        draft.dependencies = updateWorkspaceVersions(packageJson.dependencies);
        draft.devDependencies = updateWorkspaceVersions(packageJson.devDependencies);
    });
    result.accumulate(await (0, writePackageFile_1.writePackageFile)({
        fileSystem: fileSystems.getFileSystemForPackage(packageToLint),
        filename: "package.json",
        contents: JSON.stringify(packageJson),
        logger,
    }));
    for (const requiredDependency of executables.getRequiredDependencies()) {
        addDevDependency(requiredDependency.dependency);
    }
    for (const dependency of EXPECTED_DEV_DEPENDENCIES) {
        addDevDependency(dependency);
    }
    return result;
}
function generatePackageJson({ packageToLint, relativePathToRoot, relativePathToSharedConfigs, logger, executables, }) {
    const oldPackageJson = (0, tryGetPackageJson_1.tryGetPackageJson)(packageToLint, logger);
    if (oldPackageJson == null) {
        throw new Error("Missing package.json");
    }
    const pathToEslintIgnore = path_1.default.join(relativePathToRoot, ".eslintignore");
    const pathToPrettierIgnore = path_1.default.join(relativePathToSharedConfigs, ".prettierignore");
    const packageJson = (0, immer_1.default)({}, (draft) => {
        draft.name = oldPackageJson.name;
        if (packageToLint.config.private) {
            draft.private = true;
        }
        draft.main = "lib/index.js";
        draft.types = "lib/index.d.ts";
        draft.files = ["lib"];
        if (packageToLint.config.type === mrlint_commons_1.PackageType.TYPESCRIPT_CLI) {
            draft.bin =
                packageToLint.config.cliName == null
                    ? PATH_TO_CLI_SCRIPT
                    : {
                        [packageToLint.config.cliName]: PATH_TO_CLI_SCRIPT,
                    };
        }
        addScripts({
            draft,
            executables,
            pathToEslintIgnore,
            pathToPrettierIgnore,
            packageToLint,
        });
        if (packageToLint.config.type === mrlint_commons_1.PackageType.REACT_APP) {
            draft.browserslist = {
                production: [">0.2%", "not dead", "not op_mini all"],
                development: ["last 1 chrome version", "last 1 firefox version", "last 1 safari version"],
            };
        }
        if (oldPackageJson.dependencies != null) {
            draft.dependencies = sortDependencies(oldPackageJson.dependencies);
        }
        if (oldPackageJson.devDependencies != null) {
            draft.devDependencies = sortDependencies(oldPackageJson.devDependencies);
        }
        if (canPackageContainCss(packageToLint) &&
            (0, getDependencies_1.getDependencies)(packageJson.dependencies).some((d) => d.startsWith("@blueprintjs/"))) {
            draft.postcss = {
                "postcss-modules": {
                    globalModulePaths: ["@blueprintjs.*"],
                },
            };
        }
    });
    return packageJson;
}
function addScripts({ draft, executables, pathToEslintIgnore, pathToPrettierIgnore, packageToLint, }) {
    let scripts = {
        clean: `${executables.get(Executables_1.Executable.TSC)} --build --clean`,
        compile: `${executables.get(Executables_1.Executable.TSC)} --build`,
        test: `${executables.get(Executables_1.Executable.JEST)} --passWithNoTests`,
        "lint:eslint": `${executables.get(Executables_1.Executable.ESLINT)} --max-warnings 0 . --ignore-path=${pathToEslintIgnore}`,
        "lint:eslint:fix": `${executables.get(Executables_1.Executable.ESLINT)} --max-warnings 0 . --ignore-path=${pathToEslintIgnore} --fix`,
        "lint:style": `${executables.get(Executables_1.Executable.STYLELINT)} '**/*.scss' --allow-empty-input --max-warnings 0`,
        "lint:style:fix": `${executables.get(Executables_1.Executable.STYLELINT)} '**/*.scss' --allow-empty-input --max-warnings 0 --fix`,
        format: `${executables.get(Executables_1.Executable.PRETTIER)} --write --ignore-unknown --ignore-path ${pathToPrettierIgnore} "**"`,
        "format:check": `${executables.get(Executables_1.Executable.PRETTIER)} --check --ignore-unknown --ignore-path ${pathToPrettierIgnore} "**"`,
        depcheck: executables.get(Executables_1.Executable.DEPCHECK),
    };
    if (packageToLint.config.type === mrlint_commons_1.PackageType.REACT_APP) {
        scripts = Object.assign(Object.assign({}, scripts), { start: `${executables.get(Executables_1.Executable.ENV_CMD)} -e development ${executables.get(Executables_1.Executable.ENV_CMD)} -f .env.local --silent craco start`, "build:staging": `${PRODUCTION_ENVIRONMENT_ENV_VAR}=STAGING ${executables.get(Executables_1.Executable.ENV_CMD)} -e development craco --max_old_space_size=4096 build`, "build:production": `${PRODUCTION_ENVIRONMENT_ENV_VAR}=PRODUCTION ${executables.get(Executables_1.Executable.ENV_CMD)} -e production craco --max_old_space_size=4096 build`, "deploy:staging": `${PRODUCTION_ENVIRONMENT_ENV_VAR}=STAGING ${executables.get(Executables_1.Executable.AWS_CDK)} deploy --output deploy/cdk.out --require-approval never --progress events`, "deploy:production": `${PRODUCTION_ENVIRONMENT_ENV_VAR}=PRODUCTION ${executables.get(Executables_1.Executable.AWS_CDK)} deploy --output deploy/cdk.out --require-approval never --progress events`, eject: `${executables.get(Executables_1.Executable.REACT_SCRIPTS)} eject` });
    }
    draft.scripts = scripts;
}
function sortDependencies(dependencies) {
    return Object.keys(dependencies)
        .sort()
        .reduce((all, key) => (Object.assign(Object.assign({}, all), { [key]: dependencies === null || dependencies === void 0 ? void 0 : dependencies[key] })), {});
}
function canPackageContainCss(p) {
    if (p.config.type == null) {
        return false;
    }
    switch (p.config.type) {
        case mrlint_commons_1.PackageType.REACT_APP:
        case mrlint_commons_1.PackageType.REACT_LIBRARY:
            return true;
        case mrlint_commons_1.PackageType.TYPESCRIPT_CLI:
        case mrlint_commons_1.PackageType.TYPESCRIPT_LIBRARY:
        case mrlint_commons_1.PackageType.CUSTOM:
            return false;
    }
}
function updateWorkspaceVersions(dependencies) {
    if (dependencies == null) {
        return undefined;
    }
    return (0, immer_1.default)(dependencies, (draft) => {
        for (const [dep, version] of Object.entries(dependencies)) {
            if (version.startsWith("workspace")) {
                draft[dep] = "workspace:*";
            }
        }
    });
}
//# sourceMappingURL=package-json.js.map