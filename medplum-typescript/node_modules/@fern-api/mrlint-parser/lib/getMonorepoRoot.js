"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMonorepoRoot = void 0;
const promises_1 = require("fs/promises");
const path_1 = __importDefault(require("path"));
const posix_1 = require("path/posix");
const zod_1 = require("zod");
const readConfig_1 = require("./readConfig");
const MONOREPO_ROOT_FILES = new Set([".mrlint.root.json", ".mrlint.root.yml"]);
const RootConfigSchema = zod_1.z.strictObject({
    packages: zod_1.z.string(),
    sharedConfigs: zod_1.z.string(),
});
async function getMonorepoRoot({ cwd = process.cwd() } = {}) {
    const configPath = await closest({
        currentDirectory: cwd,
        predicate: (filepath) => MONOREPO_ROOT_FILES.has(path_1.default.basename(filepath)),
    });
    const config = await (0, readConfig_1.readConfig)(configPath, (contents) => RootConfigSchema.parse(contents));
    if (config == null) {
        throw new Error("Failed to read config: " + configPath);
    }
    return {
        fullPath: path_1.default.dirname(configPath),
        config,
    };
}
exports.getMonorepoRoot = getMonorepoRoot;
async function closest({ currentDirectory, predicate, }) {
    const contents = await (0, promises_1.readdir)(currentDirectory);
    for (const filename of contents) {
        const filepath = path_1.default.join(currentDirectory, filename);
        if (predicate(filepath)) {
            return filepath;
        }
    }
    if (currentDirectory === (0, posix_1.parse)(currentDirectory).root) {
        throw new Error("Failed to find file");
    }
    return closest({
        currentDirectory: path_1.default.dirname(currentDirectory),
        predicate,
    });
}
//# sourceMappingURL=getMonorepoRoot.js.map