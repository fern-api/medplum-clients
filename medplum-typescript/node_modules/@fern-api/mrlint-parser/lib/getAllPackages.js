"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllPackages = void 0;
const mrlint_commons_1 = require("@fern-api/mrlint-commons");
const promises_1 = require("fs/promises");
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const readConfig_1 = require("./readConfig");
const PackageConfigSchema_1 = require("./schemas/PackageConfigSchema");
const promisifiedGlob = (0, util_1.promisify)(glob_1.default);
async function getAllPackages(monorepoRoot) {
    const packages = [];
    const rootPackageJson = await getPackageJson(monorepoRoot.fullPath);
    if (rootPackageJson == null) {
        throw new Error("No package.json found in monorepo root");
    }
    if (rootPackageJson.workspaces == null || rootPackageJson.workspaces.length === 0) {
        throw new Error("No 'workspaces' found in root package.json");
    }
    const packageJsons = await promisifiedGlob(`${monorepoRoot.fullPath}/${rootPackageJson.workspaces.join("|")}/package.json`, {
        ignore: "**/node_modules/**",
    });
    for (const packageJson of packageJsons) {
        const packageDirectory = path_1.default.dirname(packageJson);
        const rawConfig = await (0, readConfig_1.readConfig)(path_1.default.join(packageDirectory, ".mrlint.json"), (contents) => PackageConfigSchema_1.PackageConfigSchema.parse(contents));
        packages.push({
            relativePath: path_1.default.relative(monorepoRoot.fullPath, packageDirectory),
            config: rawConfig != null ? convertConfig(rawConfig) : undefined,
            packageJson: await getPackageJson(packageDirectory),
        });
    }
    return packages;
}
exports.getAllPackages = getAllPackages;
async function getPackageJson(packageDirectory) {
    try {
        const packageJson = (await (0, promises_1.readFile)(path_1.default.join(packageDirectory, "package.json"))).toString();
        return JSON.parse(packageJson);
    }
    catch (e) {
        return undefined;
    }
}
function convertConfig(rawConfig) {
    var _a;
    const baseConfig = {
        private: rawConfig.private,
        rules: (_a = rawConfig.rules) !== null && _a !== void 0 ? _a : {},
    };
    switch (rawConfig.type) {
        case "cli":
            return Object.assign(Object.assign({}, baseConfig), { type: mrlint_commons_1.PackageType.TYPESCRIPT_CLI, cliName: rawConfig.cliName, pathToCli: rawConfig.pathToCli });
        case "library":
            return Object.assign(Object.assign({}, baseConfig), { type: mrlint_commons_1.PackageType.TYPESCRIPT_LIBRARY });
        case "react-library":
            return Object.assign(Object.assign({}, baseConfig), { type: mrlint_commons_1.PackageType.REACT_LIBRARY });
        case "react-app":
            return Object.assign(Object.assign({}, baseConfig), { type: mrlint_commons_1.PackageType.REACT_APP });
        case "custom":
            return Object.assign(Object.assign({}, baseConfig), { type: mrlint_commons_1.PackageType.CUSTOM });
    }
}
//# sourceMappingURL=getAllPackages.js.map