"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleFileSystemDiffs = void 0;
const mrlint_commons_1 = require("@fern-api/mrlint-commons");
const chalk_1 = __importDefault(require("chalk"));
const diff_1 = require("diff");
const promises_1 = require("fs/promises");
const path_1 = __importDefault(require("path"));
async function handleFileSystemDiffs({ fileSystem, logger, shouldFix, }) {
    var _a;
    const result = mrlint_commons_1.Result.success();
    await fileSystem.visitTouchedFiles(async ({ fullPath, relativePath, contents }) => {
        try {
            const formatted = await (0, mrlint_commons_1.formatFileContents)({
                filepath: fullPath,
                fileContents: contents,
                prettierParser: undefined,
            });
            await fileSystem.writeFile(relativePath, formatted);
        }
        catch (error) {
            logger.warn({
                message: `Failed to prettify ${relativePath}`,
                error,
            });
        }
    });
    const touchedFiles = fileSystem.getTouchedFiles().filter((file) => file.newContents !== file.originalContents);
    if (shouldFix) {
        await writeFiles({
            touchedFiles,
            logger,
        });
    }
    else if (touchedFiles.length > 0) {
        result.fail();
        for (const touchedFile of touchedFiles) {
            logger.error({
                message: `${touchedFile.relativePath} differs from expected value`,
                additionalContent: getDiff((_a = touchedFile.originalContents) !== null && _a !== void 0 ? _a : "", touchedFile.newContents),
            });
        }
    }
    fileSystem.clearCache();
    return result;
}
exports.handleFileSystemDiffs = handleFileSystemDiffs;
async function writeFiles({ touchedFiles, logger, }) {
    const result = mrlint_commons_1.Result.success();
    for (const touchedFile of touchedFiles) {
        const fileDirectory = path_1.default.dirname(touchedFile.fullPath);
        try {
            await (0, promises_1.mkdir)(fileDirectory, { recursive: true });
            await (0, promises_1.writeFile)(touchedFile.fullPath, touchedFile.newContents);
            logger.info({
                message: chalk_1.default.green(`Fixed ${touchedFile.relativePath}`),
            });
        }
        catch (error) {
            logger.error({
                message: `Failed to write ${touchedFile.relativePath}`,
                error,
            });
            result.fail();
        }
    }
    return result;
}
function getDiff(before, after) {
    const diff = (0, diff_1.diffLines)(before, after, {});
    const indexOfFirstDiff = diff.findIndex((part) => part.added || part.removed || false);
    const indexOfLastDiff = findLastIndex(diff, (part) => part.added || part.removed || false);
    const diffStrings = [];
    for (let i = indexOfFirstDiff; i <= indexOfLastDiff; i++) {
        const part = diff[i];
        const prefix = part.added ? "+" : part.removed ? "-" : " ";
        const writer = part.added ? chalk_1.default.green : part.removed ? chalk_1.default.red : chalk_1.default.gray;
        const diffString = part.value
            .split("\n")
            .map((line) => writer(`${prefix} ${line}`))
            .join("\n");
        diffStrings.push(diffString);
    }
    return diffStrings.join("\n");
}
function findLastIndex(items, predicate) {
    let i = items.length - 1;
    while (i >= 0) {
        if (predicate(items[i])) {
            break;
        }
        i--;
    }
    return i;
}
//# sourceMappingURL=handleFileSystemDiffs.js.map