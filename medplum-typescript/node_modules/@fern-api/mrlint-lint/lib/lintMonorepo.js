"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintMonorepo = void 0;
const mrlint_commons_1 = require("@fern-api/mrlint-commons");
const mrlint_virtual_file_system_1 = require("@fern-api/mrlint-virtual-file-system");
const addDevDependencies_1 = require("./addDevDependencies");
const handleFileSystemDiffs_1 = require("./handleFileSystemDiffs");
const lintPackage_1 = require("./package-rules/lintPackage");
async function lintMonorepo({ monorepo, rules, loggers, shouldFix }) {
    const result = mrlint_commons_1.Result.success();
    const fileSystem = new mrlint_virtual_file_system_1.LazyVirtualFileSystem(monorepo.root.fullPath);
    const fileSystems = {
        getFileSystemForMonorepo: () => fileSystem,
        getFileSystemForPackage: (p) => fileSystem.getFileSystemForPrefix(p.relativePath),
    };
    const [monorepoRules, packageRules] = partition(rules, (rule) => rule.type === mrlint_commons_1.RuleType.MONOREPO);
    const devDependenciesToAdd = {};
    const packagesToLint = monorepo.packages.filter(isLintablePackage);
    for (const packageToLint of packagesToLint) {
        const loggerForPackage = loggers.getLoggerForPackage(packageToLint);
        loggerForPackage.debug("Linting...");
        const devDependenciesForPackage = new Set();
        result.accumulate(await (0, lintPackage_1.lintPackage)({
            monorepo,
            packageToLint,
            rules: packageRules.filter((rule) => ruleAppliesToPackage(rule, packageToLint)),
            fileSystems,
            getLoggerForRule: loggers.getLoggerForRule,
            addDevDependency: (dependency) => {
                devDependenciesForPackage.add(dependency);
            },
        }));
        if (devDependenciesForPackage.size > 0) {
            if (packageToLint.packageJson == null) {
                loggerForPackage.error("Cannot add dependencies because package.json does not exist");
            }
            else if (packageToLint.packageJson.name == null) {
                loggerForPackage.error('Cannot add dependencies because package.json does not have a "name"');
            }
            else {
                devDependenciesToAdd[packageToLint.packageJson.name] = {
                    package: packageToLint,
                    devDependenciesToAdd: devDependenciesForPackage,
                };
            }
        }
        loggerForPackage.debug("Done linting.");
    }
    for (const monorepoRule of monorepoRules) {
        result.accumulate(await monorepoRule.run({
            monorepo,
            fileSystems,
            logger: loggers.getLoggerForRule({ rule: monorepoRule, package: undefined }),
        }));
    }
    result.accumulate(await (0, handleFileSystemDiffs_1.handleFileSystemDiffs)({
        fileSystem,
        logger: loggers.getLogger(),
        shouldFix,
    }));
    result.accumulate(await (0, addDevDependencies_1.addDevDependencies)({
        devDependencies: devDependenciesToAdd,
        shouldFix,
        loggers,
    }));
    return result;
}
exports.lintMonorepo = lintMonorepo;
function partition(items, predicate) {
    const aList = [];
    const bList = [];
    for (const item of items) {
        if (predicate(item)) {
            aList.push(item);
        }
        else {
            bList.push(item);
        }
    }
    return [aList, bList];
}
function ruleAppliesToPackage(rule, mrlintPackage) {
    return mrlintPackage.config.type != null && rule.targetedPackages.includes(mrlintPackage.config.type);
}
function isLintablePackage(p) {
    return getLintablePackage(p) != null;
}
function getLintablePackage(p) {
    if (p.config == null) {
        return undefined;
    }
    return Object.assign(Object.assign({}, p), { config: p.config });
}
//# sourceMappingURL=lintMonorepo.js.map