"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LazyVirtualFileSystem = void 0;
const promises_1 = require("fs/promises");
const path_1 = __importDefault(require("path"));
const FileSystem_1 = require("./FileSystem");
class LazyVirtualFileSystem {
    constructor(rootDir) {
        this.rootDir = rootDir;
        this.root = getDefaultRoot();
    }
    async readdir(relativePath) {
        const contents = await this.readdirRecursive(this.root, [], path_1.default.normalize(relativePath).split(path_1.default.sep));
        const toReturn = {};
        for (const [filename, node] of Object.entries(contents)) {
            toReturn[filename] = {
                name: node.name,
                type: node.type,
            };
        }
        return toReturn;
    }
    async mkdir(relativePath) {
        await this.mkdirRecursive(this.root, [], path_1.default.normalize(relativePath).split(path_1.default.sep));
    }
    async readFile(relativePath) {
        var _a;
        const fileContents = await this.traverseToFile(relativePath);
        if (fileContents == null) {
            return undefined;
        }
        return (_a = fileContents.newContents) !== null && _a !== void 0 ? _a : fileContents.originalContents;
    }
    async writeFile(relativePath, contents) {
        await this.traverseToFile(relativePath, { replaceWith: contents });
    }
    getFileSystemForPrefix(prefix) {
        return {
            readFile: (relativePath) => this.readFile(path_1.default.join(prefix, relativePath)),
            writeFile: (relativePath, contents) => this.writeFile(path_1.default.join(prefix, relativePath), contents),
            readdir: (relativePath) => this.readdir(path_1.default.join(prefix, relativePath)),
            mkdir: (relativePath) => this.mkdir(path_1.default.join(prefix, relativePath)),
            getFileSystemForPrefix: (nextPrefix) => this.getFileSystemForPrefix(path_1.default.join(prefix, nextPrefix)),
        };
    }
    async visitTouchedFiles(visitor) {
        const touchedFiles = this.getTouchedFiles();
        for (const changedFile of touchedFiles) {
            await visitor({
                fullPath: changedFile.fullPath,
                relativePath: changedFile.relativePath,
                contents: changedFile.newContents,
            });
        }
    }
    getTouchedFiles() {
        return this.getTouchedFilesRecursive("", this.root);
    }
    clearCache() {
        this.root = getDefaultRoot();
    }
    async readdirRecursive(currentNode, currentPath, remainingPath) {
        if (!currentNode.children.isLoaded) {
            currentNode.children = {
                isLoaded: true,
                value: await this.loadChildren(currentPath.join(path_1.default.sep)),
            };
        }
        const [nextPathPart, ...restOfRemainingPath] = remainingPath;
        if (nextPathPart == null) {
            return currentNode.children.value;
        }
        if (nextPathPart === ".") {
            if (restOfRemainingPath.length === 0) {
                return currentNode.children.value;
            }
            else {
                throw new Error(`Invalid path: ${path_1.default.join(...currentPath, nextPathPart)}`);
            }
        }
        const child = currentNode.children.value[nextPathPart];
        if (child == null) {
            throw new Error(`Path does not exist: ${path_1.default.join(...currentPath, nextPathPart)}`);
        }
        if (child.type !== FileSystem_1.FileType.DIRECTORY) {
            throw new Error(`Path is not a directory: ${path_1.default.join(...currentPath, nextPathPart)}`);
        }
        return this.readdirRecursive(child, [...currentPath, nextPathPart], restOfRemainingPath);
    }
    async loadChildren(relativePath) {
        const newChildren = await (0, promises_1.readdir)(this.getAbsolutePath(relativePath), {
            withFileTypes: true,
        });
        return newChildren.reduce((acc, child) => {
            if (child.isFile()) {
                acc[child.name] = {
                    type: FileSystem_1.FileType.FILE,
                    name: child.name,
                    contents: { isLoaded: false },
                };
            }
            else if (child.isDirectory()) {
                acc[child.name] = {
                    type: FileSystem_1.FileType.DIRECTORY,
                    name: child.name,
                    children: { isLoaded: false },
                };
            }
            return acc;
        }, {});
    }
    async mkdirRecursive(currentNode, currentPath, remainingPath) {
        const [nextDir, ...restOfRemainingDirs] = remainingPath;
        if (nextDir == null) {
            return;
        }
        if (!currentNode.children.isLoaded) {
            currentNode.children = {
                isLoaded: true,
                value: await this.loadChildren(currentPath.join(path_1.default.sep)),
            };
        }
        let existingFileForNextDir = currentNode.children.value[nextDir];
        if (existingFileForNextDir == null) {
            existingFileForNextDir = {
                name: nextDir,
                type: FileSystem_1.FileType.DIRECTORY,
                children: { isLoaded: false },
            };
            currentNode.children.value[nextDir] = existingFileForNextDir;
        }
        if (existingFileForNextDir.type === FileSystem_1.FileType.FILE) {
            throw new Error(`Path is not a directory: ${path_1.default.join(...currentPath, nextDir)}`);
        }
        return this.mkdirRecursive(existingFileForNextDir, [...currentPath, nextDir], restOfRemainingDirs);
    }
    async traverseToFile(relativePath, { replaceWith } = {}) {
        const pathParts = path_1.default.normalize(relativePath).split(path_1.default.sep);
        const filename = pathParts.pop();
        if (filename == null) {
            throw new Error(`Invalid path: ${relativePath}`);
        }
        const containingDirectory = await this.readdirRecursive(this.root, [], pathParts);
        const fileNode = containingDirectory[filename];
        if (fileNode == null) {
            if (replaceWith == null) {
                return undefined;
            }
            const newFileContents = {
                originalContents: undefined,
                newContents: replaceWith,
            };
            containingDirectory[filename] = {
                type: FileSystem_1.FileType.FILE,
                name: filename,
                contents: { isLoaded: true, value: newFileContents },
            };
            return newFileContents;
        }
        if (fileNode.type !== FileSystem_1.FileType.FILE) {
            throw new Error(`Path is not a regular file: ${relativePath}`);
        }
        let fileContents;
        if (fileNode.contents.isLoaded) {
            fileContents = fileNode.contents.value;
        }
        else {
            const fileContentsBuffer = await (0, promises_1.readFile)(this.getAbsolutePath(relativePath));
            fileContents = { originalContents: fileContentsBuffer.toString() };
        }
        if (replaceWith != null) {
            fileNode.contents = {
                isLoaded: true,
                value: Object.assign(Object.assign({}, fileContents), { newContents: replaceWith }),
            };
        }
        return fileContents;
    }
    getTouchedFilesRecursive(currentPath, directory) {
        if (!directory.children.isLoaded) {
            return [];
        }
        return Object.values(directory.children.value).flatMap((child) => {
            switch (child.type) {
                case FileSystem_1.FileType.DIRECTORY:
                    return this.getTouchedFilesRecursive(path_1.default.join(currentPath, child.name), child);
                case FileSystem_1.FileType.FILE: {
                    if (!child.contents.isLoaded || child.contents.value.newContents == null) {
                        return [];
                    }
                    const relativePath = path_1.default.join(currentPath, child.name);
                    return {
                        fullPath: this.getAbsolutePath(relativePath),
                        relativePath,
                        originalContents: child.contents.value.originalContents,
                        newContents: child.contents.value.newContents,
                    };
                }
            }
        });
    }
    getAbsolutePath(relativePath) {
        return path_1.default.join(this.rootDir, relativePath);
    }
}
exports.LazyVirtualFileSystem = LazyVirtualFileSystem;
function getDefaultRoot() {
    return {
        type: FileSystem_1.FileType.DIRECTORY,
        name: "root",
        children: { isLoaded: false },
    };
}
//# sourceMappingURL=LazyVirtualFileSystem.js.map